<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode747. Largest Number At Least Twice of Others]]></title>
    <url>%2F2019%2F03%2F27%2FLeetCode747-Largest-Number-At-Least-Twice-of-Others%2F</url>
    <content type="text"><![CDATA[In a given integer array nums, there is always exactly one largest element. Find whether the largest element in the array is at least twice as much as every other number in the array. If it is, return the index of the largest element, otherwise return -1. Example 1: 1234Input: nums = [3, 6, 1, 0]Output: 1Explanation: 6 is the largest integer, and for every other number in the array x,6 is more than twice as big as x. The index of value 6 is 1, so we return 1. Example 2: 123Input: nums = [1, 2, 3, 4]Output: -1Explanation: 4 isn&apos;t at least as big as twice the value of 3, so we return -1. Note: nums will have a length in the range [1, 50]. Every nums[i] will be an integer in the range [0, 99]. Hints: Scan through the array to find the unique largest element m, keeping track of it’s index maxIndex. Scan through the array again. If we find some x != m with m &lt; 2*x, we should return -1. Otherwise, we should return maxIndex. my code in c++12345678910111213141516171819202122class Solution &#123;public: int dominantIndex(vector&lt;int&gt;&amp; nums) &#123; int m = nums[0]; int index = 0;//1. for (int i=0;i&lt;nums.size();i++) &#123; if (m &lt; nums[i]) &#123; index = i; m = nums[i]; &#125; &#125; for (auto const &amp; num : nums) &#123; if (num != m&amp;&amp;num * 2&gt;m) return -1; &#125; return index; &#125;&#125;; 细节 要返回的是index，不是max，所以要记录maxindex。 总结 O(n^2)time,O(1)space O(n)找到最大数，并记录索引，一定要记录索引啊！！因为要返回的是index! O(n)重新遍历，如果发现有 x!=m 且 2x&gt;m，返-1]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode724. Find Pivot Index]]></title>
    <url>%2F2019%2F03%2F27%2FLeetCode724-Find-Pivot-Index%2F</url>
    <content type="text"><![CDATA[Given an array of integers nums, write a method that returns the “pivot” index of this array. We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index. If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index. Example 1: 123456Input: nums = [1, 7, 3, 6, 5, 6]Output: 3Explanation: The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.Also, 3 is the first index where this occurs. Example 2: 12345Input: nums = [1, 2, 3]Output: -1Explanation: There is no index that satisfies the conditions in the problem statement. Note: The length of nums will be in the range [0, 10000]. Each element nums[i] will be an integer in the range [-1000, 1000]. Hint: We can precompute prefix sums P[i] = nums[0] + nums[1] + … + nums[i-1]. Then for each index, the left sum is P[i] the right sum is P[P.length - 1] - P[i] - nums[i]. 思路 dp 将i的左侧总和记为sum[i] i的右侧总和：sum[length] - sum[i] - nums[i] 跟hint不一样，我的sum.size()=length+1，sum[0]=0.因为i=0时，左侧没有数 my code in c++123456789101112131415161718class Solution &#123;public: int pivotIndex(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; sum; sum.push_back(0);//nums[0]left的sum是0.不能push_back nums[0]！！！ for (int i=1;i&lt;=nums.size();i++) &#123; sum.push_back(sum[i - 1] + nums[i-1]); &#125; for (int i = 0; i &lt; nums.size(); i++) &#123; if (sum[i] == sum[nums.size()] - sum[i] - nums[i]) return i; &#125; return -1; &#125;&#125;; 细节​ 1. 我的思路是 sum[i]不包含 nums[i] 本身。所以vector第一个数不是nums[0],是0. LC in py1234567891011class Solution(object): def pivotIndex(self, nums): # Time: O(n) # Space: O(1) left, right = 0, sum(nums) for index, num in enumerate(nums): right -= num if left == right: return index left += num return -1 设left=0,right=total 从nums的头开始遍历，right-nums[i], 如果left==right,返回当前的i 否则 left+nums[i] 没有left==right，返-1 总结 计算不含nums[i]的leftsum，如果leftsum== total - leftsum -nums[i]，返回i 设leftsum=0,rightsum=total.从头开始遍历,rightsum-nums[i];如果left=right ,返i，否则left+=nums[i]；没有返-1]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array and String]]></title>
    <url>%2F2019%2F03%2F27%2FArray-and-String%2F</url>
    <content type="text"><![CDATA[Introduction to ArrayArray store sequentially accessed randomly（index) one-dimensional array = linear array a fixed capacity：specify the size of the array when we initialize it,inconvenient and wasteful 12345678910111213141516#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; // 1. Initialize int a0[5]; int a1[5] = &#123; 1, 2, 3 &#125;; // other element will be set as the default value // 2. Get Length int size = sizeof(a1) / sizeof(*a1); cout &lt;&lt; "The size of a1 is: " &lt;&lt; size &lt;&lt; endl;//5 // 3. Sort sort(a1, a1 + size); for (int&amp; item : a1) &#123; cout &lt;&lt; " " &lt;&lt; item;//0 0 2 3 4 &#125;&#125; Dynamic Array dynamic array: random access list variable size vector 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; // 1. initialize vector&lt;int&gt; v0; vector&lt;int&gt; v1(5, 0); // 2. make a copy vector&lt;int&gt; v2(v1.begin(), v1.end()); vector&lt;int&gt; v3(v2); // 2. cast an array to a vector int a[5] = &#123;0, 1, 2, 3, 4&#125;; vector&lt;int&gt; v4(a, *(&amp;a + 1));//copy // 5. iterate the vector for (int i = 0; i &lt; v4.size(); ++i) &#123; cout &lt;&lt; " " &lt;&lt; v4[i]; &#125; for (int const&amp; item : v4) &#123; cout &lt;&lt; " " &lt;&lt; item; &#125; for (auto item = v4.begin(); item != v4.end(); ++item) &#123; cout &lt;&lt; " " &lt;&lt; *item; &#125; // 7. sort sort(v4.begin(), v4.end()); &#125; Leetcode [724] 寻找数组的中心索引]]></content>
  </entry>
  <entry>
    <title><![CDATA[Socket Programming]]></title>
    <url>%2F2019%2F03%2F26%2FSocket-Programming%2F</url>
    <content type="text"><![CDATA[Topics Network programming (sockets, RPC(远程过程调用)（Remote Procedure Call）) Network (esp. Internet) architecture Switching, Routing, Congestion control, TCP/IP, Wirelessnetworks Using the network Interface hardware &amp; low-level implementation issues,Naming (DNS域名服务器), Error detection, compression(压缩) Higher level issues Encryption(加密) and Security, caching &amp; content distribution,Peer-to-peer systems(对等网络系统) Building blocks Nodes: Computers, dedicated routers, . . . Links: Coax(同轴电缆), twisted pair(双绞线), fibers, radio . . . point-to-point multiple access – every node sees every packet //每个节点都能互相访问 From Links to Networks: To scale to more nodes, use switching nodes can connect multiple other nodes //多点连接 Recursively, one node can connect multiple networks Protocol layering Application TCP or UDP IP Link Layer Can view network encapsulation as a stack A network packet from A to D must be put in link packets A to B, B to C, and C to D Each layer produces packets that become the payload of the lower-layer’s packets //上层向下层传包 This is almost correct, but TCP/UDP “cheat” to detect certain errors in IP-level information like address （？ OSI layers Physical – sends individual bits Data link – sends frames, handles access control toshared media (e.g., coax) 电缆 Network – delivers packets, using routing Transport – demultiplexes(解复用), provides reliability &amp;flow control Session – can tie together multiple streams (e.g.,audio &amp; video) Presentation – crypto(加密), conversion betweenrepresentations Application – what end user gets, e.g., HTTP (web) Addressing 定址 Each node typically has unique address (or at least is made to think it does when there is shortage) //ipv4可能地址不足 Each layer can have its own addressing Link layer: e.g., 48-bit Ethernet address (interface) //6Bytes Ethernet address Network layer: 32-bit IP address (node) //IPv4 4Bytes, IPv6 8Bytes. IPv4 address IPv4 vs. IPv6 Transport layer: 16-bit TCP port (service) //2Bytes TCP port // HTTP 80 Routing is process of delivering data to destination across multiple link hops hopone portion of the path between source and destination. The hop count refers to the number of intermediate devices through which data must pass between source and destination. A large number of hops between source and destination implies lower real-time performance. Special addresses can exist for broadcast/multicast (???) Hourglass 沙漏 Many application protocols over TCP &amp; UDP IP works over many types of network This is “Hourglass” philosophy of Internet Idea: If everybody just supports IP, can use many different applications over many different networks In practice, some claim narrow waist is now network and transport layers, due to NAT (lecture 12) （插眼。。ip掩蔽 Internet protocol Most computer nets connected by Internet protocol Runs over a variety of physical networks, so can connect Ethernet, Wireless, people behind modem lines, etc. //IP 凌驾于物理网络之上 Every host has a unique 4-byte IP address E.g., www.ietf.org ! 132.151.6.21 //IPv4 Given a node’s IP address, the network knows how to route a packet (lectures 3+4) //有IP地址就可以向他路由包了 But how do you build something like the web? Need naming (look up www.ietf.org) – DNS (lecture 8) Need API for browser, server (CS110/this lecture) Need demultiplexing within a host—E.g., which packets are for web server, which for mail server, etc.? (lecture 4) //主机内部分解包 Want abstraction of inter-process (not just inter-node) communication //进程间通信 ：封装 + IP Solution: Encapsulate another protocol within IP UDP and TCP UDP and TCP most popular protocols on IP 都使用 16位端口号 + 32位IP地址 Applications bind a port &amp; receive traffic to that port 应用从端口收发消息 UDP – unreliable datagram protocol 不可靠报文协议 Exposes packet-switched nature of Internet 透明 Sent packets may be dropped, reordered, even duplicated (but generally not corrupted) 丢包 无序 重复 TCP – transmission control protocol 传输控制协议 Provides illusion of a reliable “pipe” between to processes on two different machines (lecture 5) 在两个主机的进程间提供虚拟可靠”管道” Handles congestion &amp; flow control (lecture 6) 处理 阻塞 和 流量控制 Most applications use TCP Easier interface to program to (reliability, lecture 5) Automatically avoids congestion (don’t need to worry about taking down network, lecture 6) Servers typically listen on well-known ports SSH: 22 Email: 25 Finger: 79 Web / HTTP: 80 Programming Sockets Berkeley sockets API Bottom-level OS interface to networking Important to know and do once Higher-level APIs build on them CS110 review: System calls System calls invoke code in the OS kernel Kernel runs in a more privileged mode than application Can execute special instructions that application cannot Can interact directly with devices such as network card Higher-level functions built on syscall interface printf, scanf, gets, etc. all user-level code File descriptors Most IO done on file descriptors Small integers referencing per-process table in the kernel Examples of system calls with file descriptors: int open(char *path, int flags, …); Returns new file descriptor bound to file path int read (int fd, void *buf, int nbytes); Returns number of bytes read Returns 0 bytes at end of file, or -1 on error int write (int fd, void *buf, int nbytes); Returns number of bytes written, -1 on error (Never returns 0 if nbytes &gt; 0) int close (int fd); Deallocates file descriptor (not underlying I/O resource) to be continued… Reference TCP/IP Ports and Sockets Explained Hop (networking))]]></content>
      <categories>
        <category>Computer Network</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>Socket</tag>
        <tag>port</tag>
        <tag>OSI</tag>
        <tag>Addressings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Network Map]]></title>
    <url>%2F2019%2F03%2F26%2FNetwork-Map%2F</url>
    <content type="text"><![CDATA[CS144 Socket programming ReferenceTransport Layer Understanding the TCP/IP protocol suite tcpip四层模型 三次握手 追踪路由 工具 Network layer IPv4 vs IPv6 （可能是废文 IPV6的特性 ipv4和ipv6的比较 IPV6的传播模式（？还不懂]]></content>
  </entry>
  <entry>
    <title><![CDATA[IPv4 vs IPv6]]></title>
    <url>%2F2019%2F03%2F26%2FIPv4-vs-IPv6%2F</url>
    <content type="text"><![CDATA[本文是阅读《IPv4 vs IPv6 – Why is IPv6 so important?》做的一篇废文。 因为我一点都没学过计网，按自己的理解去翻译的，等我学完再过来review,应该有很多理解错误。 里面有大量我不懂的专业术语，以（？？？）标记，日后深入研究，希望早日理解这些问题。 Intro IPv6 is the newest version of Internet Protocol (IP) The Internet continues to grow and that growth will only be accommodated by IPv6 addresses. WHY IS IPV6 SO IMPORTANT? Every Internet-connected device has its own unique IP address, which is required for websites to know where to send information. IPv6 allows provision for 340 trillion trillion trillion IP addresses. Features of IPV6 Large capacity for IP add. 大容量的ip地址 Simplified header. 简化报头 Direct connectivity between all hosts on the internet.主机直接互连 Automatic configuration of host devices. 主机设备自动配置 Almost instant routing. 即刻路由 Use of multicast to connect with multiple hosts. 多主机间的多广播（？？ Anycast support. 任播支持（？？？ Mobility of hosts to roam different geographical areas while maintaining connection with the same IP address. 漫游移动端维持一样的ip地址 Extensibility of options. 扩展选项 IPV4 VS. IPV6 IPV4 IPV6 manually,increasing the maintenance requirement. auto-configuration,easier to manage. 只用一个ip掩蔽就可以取消数以千万计的非路由地址，大大影响了端到端的整体性。（？？？） 因为有大量的地址空间，所以可以直接定向，NAT的需求适用，但是被淘汰了（不确定 一个人不一定拥有一个ip地址 每平方米有1k多个地址，就是说地址空间多 为通信而设计，允许小范围的更新和同步 大量的地址，可以大量的innovation and collaboration 受限的网络拓扑，意味着 受限的移动性和互操作性（交互性 用ipv6的设备，其移动性和交互性被大大增强了 不同应用中的安全性不一样 在IPV6协议中，包含了网路协议安全（IPSEC），是对IPV4的安全性升级 NAT(network address translation)网络掩蔽、IP掩蔽（科普了也不懂系列。先了解了解，日后深入研究） Remapping one IP address space into another.将IP地址映射另一个IP地址 modifying network address information in the IP header of packets while they are in transit across a traffic routing device).在路由设备或者防火墙传输时，重写包的ip头部网络地址 used as a shortcut快捷 to avoid the need to readdress every host when a network was moved. 当网络被移走时，避免重地址的捷径 It has become a popular and essential tool in conserving global address space in the face of IPv4 address exhaustion. 面对IPV4地址的枯竭，用nat来保存全球地址空间。 One Internet-routable IP address of a NAT gateway网关 can be used for an entire private network. wiki 中文：在计算机网络中,NAT是一种在IP数据包通过路由器或防火墙时,重写来源IP地址或目的IP地址的技术。这种技术被普遍使用在有多台主机但只通过一个公有IP地址访问因特网的私有网络中。它是一个方便且得到了广泛应用的技术。当然，NAT也让主机之间的通信变得复杂，导致了通信效率的降低。 IPV6 ADDRESSING MODES 单一传播 多向传播 任意传播]]></content>
      <categories>
        <category>Computer Network</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode141. Linked List Cycle]]></title>
    <url>%2F2019%2F03%2F26%2FLeetCode141-Linked-List-Cycle%2F</url>
    <content type="text"><![CDATA[EasyGiven a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Example 1: 123Input: head = [3,2,0,-4], pos = 1Output: trueExplanation: There is a cycle in the linked list, where tail connects to the second node. Example 2: 123Input: head = [1,2], pos = 0Output: trueExplanation: There is a cycle in the linked list, where tail connects to the first node. Example 3: 123Input: head = [1], pos = -1Output: falseExplanation: There is no cycle in the linked list. Follow up: Can you solve it using O(1) (i.e. constant) memory? 常数空间判断环。 思路 快慢指针：判断是否有环，快慢指针相遇就有环；如果有环一定走不到null。 Mine in C++12345678910111213141516class Solution &#123;public: bool hasCycle(ListNode *head) &#123; ListNode* fast,*slow;//1. fast = slow = head; while (fast&amp;&amp;fast-&gt;next)//2. &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if (fast == slow)//3. return true; &#125; return false; &#125;&#125;; 细节 快慢指针。 fast&amp;&amp;fast-&gt;next一起判空。 有环必走不到空，指针相遇就有环。 LC in Python12345678910def hasCycle(self, head): try: slow = head fast = head.next while slow is not fast: slow = slow.next fast = fast.next.next return True except: return False ref:Except-ionally fast Python MediumGiven a linked list, return the node where the cycle begins. If there is no cycle, return null. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Note: Do not modify the linked list. Example 1: 123Input: head = [3,2,0,-4], pos = 1Output: tail connects to node index 1Explanation: There is a cycle in the linked list, where tail connects to the second node. Example 2: 123Input: head = [1,2], pos = 0Output: tail connects to node index 0Explanation: There is a cycle in the linked list, where tail connects to the first node. Example 3: 123Input: head = [1], pos = -1Output: no cycleExplanation: There is no cycle in the linked list. Follow up:Can you solve it without using extra space? 没有额外空间找到入口节点。 思路 在判断是否存在环时，计数记为n。 快指针先走n个，两个指针相遇处为入口处。 Mine in C++123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public:ListNode *detectCycle(ListNode *head) &#123; if (!hasCycle(head)) //2. return nullptr; ListNode* fast, *slow; fast = slow = head; while (count--) &#123; fast = fast-&gt;next; &#125; while (slow!=fast) &#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; return slow;&#125;bool hasCycle(ListNode *head) &#123; ListNode* fast, *slow; fast = slow = head; while (fast&amp;&amp;fast-&gt;next) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; count++;//1. if (fast == slow) return true; &#125; return false;&#125;private: int count = 0;&#125;; Follow up没有额外空间找到入口节点。 No extra space (other than recursive stack)，不能用递归,也不能用全局变量计数，用三个指针，环状检测算法。 环状检测算法描述 确定是否有环 slow走一步 fast走两步 快慢指针相遇，则有环 否则 if (fast-&gt;next == NULL || fast-&gt;next-&gt;next == NULL),没有环 如果有环，返回入口节点 L1 ：头节点 到 入口 的距离 L2：相遇点 到 入口 的距离 C : 环大小 n : 当快慢指针第一次相遇时，fast 遍历过环的次数 根据L1,L2,C的定义得到 相遇时，slow走的总路程： L1 + L2 相遇时，fast走的总路程：L1 + L2 + n * C 因为fast走的是slow的两倍： 2 * (L1+L2) = L1 + L2 + n * C L1 + L2 = n * C L1 = (n - 1) C + (C - L2) 由此推得： 快慢指针第一次相遇时，头节点和入口节点的距离=(沿着指针移动的方向，)相遇节点和入口节点的距离.L1 = (n - 1) C + (C - L2) ,这一步很关键！！！ if (slow == fast){} 同时 入口指针 也开始和 slow指针 一样走动了，一次走一步。 当他们相遇时入口指针就指向入口节点。 return entry; LC in C++123456789101112131415161718192021ListNode *detectCycle(ListNode *head) &#123; if (head == NULL || head-&gt;next == NULL) return NULL; ListNode *slow = head; ListNode *fast = head; ListNode *entry = head; while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if (slow == fast) &#123;// 1. while(slow != entry) &#123;// 2. slow = slow-&gt;next; entry = entry-&gt;next; &#125; return entry;//3. &#125; &#125; return NULL;&#125; LC in Python123456789101112131415161718192021class Solution: # @param head, a ListNode # @return a list node def detectCycle(self, head): try: fast = head.next slow = head while fast is not slow: fast = fast.next.next slow = slow.next except: # if there is an exception, we reach the end and there is no cycle return None # since fast starts at head.next, we need to move slow one step forward slow = slow.next while head is not slow: head = head.next slow = slow.next return head 总结 O(1)space.O(n)time 需要计数的方法：找入口节点分两步，第一检测是否有环：快慢指针相遇，并且计数；第二找到入口：快指针先走size步，相遇就是入口节点。 更优化的方法，三个指针!! 环状检测算法：当快慢指针第一次相遇的节点 meeting,到入口节点entry的距离 （沿着指针移动方向），等于， 入口节点entry 到 头节点head 的距离。所以if(slow==fast)时，开始entry和slow一起移动，直到他们相遇。 最好画图，会很清楚。 Reference Cycle detection (graph theory)) Cycle detection(iterated functions)# Floyd’s cycle-finding algorithm]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode876. Middle of the Linked List]]></title>
    <url>%2F2019%2F03%2F26%2FLeetCode876-Middle-of-the-Linked-List%2F</url>
    <content type="text"><![CDATA[Given a non-empty, singly linked list with head node head, return a middle node of linked list. If there are two middle nodes, return the second middle node. Example 1: 12345Input: [1,2,3,4,5]Output: Node 3 from this list (Serialization: [3,4,5])The returned node has value 3. (The judge&apos;s serialization of this node is [3,4,5]).Note that we returned a ListNode object ans, such that:ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL. Example 2: 123Input: [1,2,3,4,5,6]Output: Node 4 from this list (Serialization: [4,5,6])Since the list has two middle nodes with values 3 and 4, we return the second one. Note: The number of nodes in the given list will be between 1 and 100. 思路 快慢指针：一个走两步，一个走一步，走得快的到null时，走得慢的在中间。 My Code in C++12345678910111213141516171819class Solution &#123;public: ListNode* middleNode(ListNode* head) &#123; ListNode* p1 = head; ListNode* p2 = head; while (p1) &#123; if(p1-&gt;next) p1 = p1-&gt;next-&gt;next;//1.不能用p++，链表不是物理存储的 //2.member access within null pointer of type 'struct ListNode，需要判空 else &#123; break;//2.p1已经是尾节点，就跳出 &#125; p2 = p2-&gt;next; &#125; return p2; &#125;&#125;; 细节 不能用p++，链表不是物理存储的 使用p1 = p1-&gt;next-&gt;next时，需要判空，否则会出member access within null pointer of type ‘struct ListNode..的runtime error.如果p1已经是尾节点，p2就不要再走了，p2就是中间节点。 LC高票Code in C++123456ListNode* middleNode(ListNode* head) &#123; ListNode *slow = head, *fast = head; while (fast &amp;&amp; fast-&gt;next) slow = slow-&gt;next, fast = fast-&gt;next-&gt;next; return slow;&#125; 人家直接在while里一次把判空做好了。。。 Code in Python123456def middleNode(self, head): slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next return slow 总结 快慢指针。 鲁棒性测试：直接fast&amp;&amp;fast-&gt;next一起判空。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Understanding the TCP/IP protocol suite]]></title>
    <url>%2F2019%2F03%2F25%2FUnderstanding-the-TCP-IP-protocol-suite%2F</url>
    <content type="text"><![CDATA[本文是阅读《Understanding the TCP/IP protocol suite》 的读书笔记，文章来自Nassos Katsaounis在serverdensity上发布的博客。 Intro TCP/IP: Transmission Control Protocol/Internet Protocol Developed in the mid 1970’s and widely adopted in the early 1980’s, it has been the standard of computer networking for over 35 years. TCP/IP basics TCP/IP plays a particularly important role in two specific layers: In the Transport Layer, where correct delivery of data is ensured In the Network Layer, where the correct recipient is located Application Layer This layer provides applications the ability to access the services of the other layers Defines the protocols that applications use to exchange data. This layer adds it’s own header and sends down to the Transport layer. Some of the popular protocols of this layer are :HTTP, FTP, SMTP, Telnet, NFS, RIP, etc. Transport Layer It is mainly responsible for providing the application layer with session and datagram communication services. 下层为上层提供服务 This layer adds it’s own headers and sends down to the Network layer. ensure that all the split pieces arrive correctly at the other end. It is concerned with end-to-end transportation of data and setups up a logical connection between the hosts.数据端到端传输，建立主机间逻辑连接。 There are two protocols available in this layer:TCP and UDP TCP in Transport Layer (“How”) establishing reliable data exchange between applications. This ensures that data is not lost or misinterpreted along the way: TCP confirms that the message sent is the message actually received. open a channel of communication between the two computers. breaks the data into small units of information (“segments” or “packets”) as required, confirms correct delivery and reassembles them at the destination. Network Layer The segments sent by the above layers are received here. send this segment of data to a destination host which could be anywhere ( in the same network or may be external network). It provides logical addressing, path determination for the segments to be sent and forwarding . This layer also adds it’s own headers and convert and send the received segments in form of packets.网络层以包的形式传递报文段 Some of the popular protocols of this layer are :Internet Protocol (IP), ICMP, etc. IP in Network Layer (“Where”) send the data to the correct recipient. determines how data will find its intended destination through interconnected networks. dictates the roadmap that data will have to follow. ensures that all packets include the information necessary for each node to be able to forward them to the next. Network Access Layer ( Data Link + Physical Layer) This layer defines the protocols and hardware required to connect a host to a physical network and to deliver data across it. For delivery within a given physical network, packets are sent from the above layer to this layer. The destination can be another host in the network, itself, or a router for further forwarding. So the Network layer has a view of the entire Network whereas the Network Access layer is limited to the physical layer boundary that is often defined by a layer 3 device such as a router. When the physical network is LAN, Ethernet(802.3) ; if the physical network is a WAN, protocols such as Point to Point Protocol (PPP) and Frame relay are common. How it works TCP is activated with every network request/response.For example: In an HTTP request, TCP takes over as soon as the browser knows where the request should be routed, i.e. after DNS resolution has been completed. Based on the socket provided (combination of IP address and server port), the request will reach the target computer and application through the network. The necessary communication channel will open up. data will be broken down to appropriately sized packets. Then, they will be sent over to the server. While the server handles the request and prepares the response accordingly, TCP makes sure that this particular connection channel remains open until the response reaches the source of the request successfully. While moving data around, TCP/IP protocols annotate segments with extra information (headers) in order to be able to perform all the above tasks successfully. Headers include: information regarding the segment sequence number, a number (checksum) to allow confirmation of data validity information about sender and recipient. This added information allows data to be segmented and transmitted as efficiently as possible, making sure it is correctly restructured at the destination, without worrying about structure during transportation. But it also plays an important role in the Three-Way Handshake. Three-way handshake(!important) Unlike User Datagram Protocol (UDP), reliability is a top priority for TCP/IP. UDP serves as an alternative to TCP for different types of communication services where there is no time or need for confirmation that the correct message was successfully received by the intended party. An example of a case like that is a voice call over IP. But in most cases, such confirmation is absolutely necessary. To ensure reliability in communications, TCP establishes a verified connection between the client and the server computer before actual data is transmitted. This is done through the Three-Way Handshake using three segments (hence the “three-way”). How it works(!important) C. SYN(seq:100) to S. SYN : Synchronization requests that the server synchronizes with the sequence numbers that the client will use.(seq:100) new sequence numbers are generated with every new transaction Client state changes to SYN-SENT S. ACK-SYN(ack:101,seq:200) to C. acknowledges (ACK) the request by confirming the Sequence Numbers sent by the client.(ack:101) requests synchronization (SYN) of the client’s Sequence Numbers with its(server) own.(seq:200) Server state changes to SYN-RECEVED C. ACK(ack:201,seq:101) to S. acknowledges (ACK) the Sequence Numbers sent by the server. (ack:201) Client state changes to EATABLISHED Server state changes to EATABLISHED Transmission is ready to begin. Click here to read more about the Three-Way Handshake. The Traceroute utility TCP/IP comes with utilities that assist admins diagnose and understand problems in network performance. The most well-known of these utilities is probably Ping, that allows you to test whether your computer can open a communication channel with a certain host to exchange data, and how fast. In a way, Traceroute takes the Ping utility a few steps further. Data transmitted through networks almost always goes through intermediate nodes before reaching its destination. Traceroute is especially designed to identify all the routers or other network devices (“hops”) between the source and the destination and measure the rate at which data is exchanged with each router. So the purpose of Traceroute is twofold: To determine the path to a destination, complete with intermediate stops To identify possible delay points in this path Using specific switches, the Traceroute command can be configured with regard to maximum hops最大跃点数, timeouts for each reply, hostname resolution and other options. TRACERT可用于对大型网络进行故障排除，其中多个路径可能导致相同的点或涉及许多中间组件（路由器或网桥） To read more about how to use Traceroute click here (for Windows) or here(for Linux). How it worksto be continued…. Reference Learning the TCP/IP Protocol Suite,codeburst.io. Building Blocks of TCP,hpbn.co. Learning the OSI Model,codeburst.io. TCP/IP vs. OSI: What’s the Difference Between the Two Models? Computer network tutorials,geeksforgeeks.]]></content>
      <categories>
        <category>Computer Network</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode387. First Unique Character in a String]]></title>
    <url>%2F2019%2F03%2F25%2FLeetcode387-First-Unique-Character-in-a-String%2F</url>
    <content type="text"><![CDATA[Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1. Examples: 12345s = &quot;leetcode&quot;return 0.s = &quot;loveleetcode&quot;,return 2. Note: You may assume the string contain only lowercase letters. 思路 为每个出现的字符进行计数，并保存他的索引。这些字符是唯一的，所以不能用multimap。 构建一个无序容器，hashtable. unoredered_map。形式：char|(times,index).其中key是字符，value是pair(次数,index) 从头到尾遍历字符串，将每个字符对应的value都更新(次数|index) Code in C++123456789101112131415161718192021class Solution &#123;public: int firstUniqChar(string s) &#123; unordered_map&lt;char,pair&lt;int,int&gt;&gt; m;//key:char:字符。value：int；次数,int:index int index =s.size(); for(int i=0;i&lt;s.size();i++) &#123; m[s[i]].first++;//value.first:出现次数++ m[s[i]].second=i;//value.sencon:字符出现的索引更新为最新 &#125; for(auto const &amp;it : m) &#123; if(it.second.first==1)//这里不能忘记写second啊，只有second才说明是value！ &#123; index=min(index,it.second.second);//这里一定要写min(index,curindex)，否则会返回最后一次的index,而不是第一次出现的！！ &#125; &#125; return index==s.size()?-1:index; &#125;&#125;; 细节 int index =s.size();定义一个全局变量，最后判断index有没有变化，没有变化说明没有唯一字符，返回-1. if(it.second.first==1)//这里不能忘记写second啊，只有second才说明是value！ index=min(index,it.second.second);//这里一定要写min(index,curindex)，否则会返回最后一次的index,而不是第一次出现的！！ 总结 看到字符串计数问题就要想到hash table，用空间换时间，很快查找O(1)。因为统计次数，所以key不能重复，也就是不能用multimap,所以用unordered_map！！ 注意是无序!!不要用map，他是rbt实现的，构建树的时候就已经排好了序，计数类的题目是不需要排序的，很浪费时间!!O(logn)。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>String</tag>
        <tag>unordered_map</tag>
        <tag>Unordered Containers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Taking Hash Tables Off The Shelf]]></title>
    <url>%2F2019%2F03%2F25%2FTaking-Hash-Tables-Off-The-Shelf%2F</url>
    <content type="text"><![CDATA[本文是阅读《Taking Hash Tables Off The Shelf》和《Hashing Out Hash Functions》的读书笔记，文章来自Vaidehi Joshi在medium上发布baseCS系列，该栏目用可爱的漫画来生动地解释计算机基础、数据结构、算法、理论在实践中的应用。 Part 1. Intro It’s hard to understand breadth first search if you don’t already know Big O notation. And Big O notation doesn’t mean anything to you unless you’ve seen it in action, in the context of an algorithm. Metaphors比喻 can be a great way of learning through analogy类比, and they’re useful in illustrating otherwise complicated concepts. Books on books on books array or linked list:O(n) space+time using binary search : O(logn) space+time not the most efficient to find Mappings to make our lives easier Hash tables : an array + a hash function what makes them so efficient for our purposes is that they create a mapping, which is a relationship between two sets of data. Hash tables are made up of sets of pairs: a key and a value, often referred to as (k, v). The idea here is that if you have the key in one set of data, you can find the value that corresponds to it in another set of data. In the case of a hash table, it is the hash function that creates the mapping. Since we’re working with arrays, the key is the index of the array, and the value is the data that lives at that index. The hash function’s job is to take an item in as input, and calculate and return the key for where that item should live in the hash table. Example 1Hash bucketsHash table has a size of 12, every single book needs to be stored somewhere within these twelve slots. Code in JS1234567891011function bookHashing(bookTitle, hashTableSize) &#123; // Remove any spaces from book title. var strippedBookTitle = bookTitle.replace(/\s/g, '') // Divide the length of the title by the hash table size. // Return the remainder. return strippedBookTitle.length % hashTableSize;&#125;bookHashing("The Grapes of Wrath", 12);// 4bookHashing("The Sound and the Fury", 12);// 6 CollisionA collision occurs when two elements are supposed to be inserted at the same place in an array. For starters, we can be sure that no hash function will always return a unique hash bucket value for every item that give it. In fact, a hash function will always input multiple elements to the same output (hash bucket), because the size of our dataset will usually be larger than the size of our hash table. Super cool constant timePractical contextHash functions that lean on alphabetization always result in 26 hash buckets. An equal distribution of data amongst all the possible hash buckets. EfficiencyHash tables leverage constant time search, which is what makes them so powerful. It also only takes constant time to insert or delete an item into a hash table, because we’re always going to lean on our hash function to determine where to add or remove something! Libraries around the world use the Dewey Decimal Classification System, which is really just a hash table with 10 buckets (and of course, a complex hash function that still I don’t quite understand yet). Part 2. Intro everything has its drawbacks. Hash tables, are really great options for storing and retrieving specific data, quickly. They’re not always the best tool for the job — for example, they’re not great for finding ordered data . hash tables do intrinsically have some issues of their own, and the usefulness of a hash table is tied directly to its hash function. Hash table, are you any good?a good hash table hinges on how good of a hash function the hash table has. Collisions occur whenever Collision resolution tactics There are a handful of ways to handle collisions in a hash function, and the important thing to remember that none of them is necessarily the “right tactic” to use. It all depends on your dataset, the size of your hash table, and what operations you know you’ll want to perform on the table later on. Linear Probing looking for the next empty hash bucket nearby. This is a kind of rehashing, and this technique is known as linear probing. The interesting thing about linear probing is that if the next hash bucket is also filled by an element, the hash function will just continue to probe through the hash table until it finds an empty bucket, cycling back if necessary. Clustering simply moving over to the next available hash bucket and inserting an element at the “next free space” leads to something called clustering. either our hash function isn’t using up the entire hash table range it’s not spreading data evenly across the hash buckets of our hash table. well-spaced : data is spread across the table, across many different hash buckets, and spans the entire range of the table Clustered vs. well-balanced tables this again depends on our dataset. If we have a lot of elements that are ending up at one hash bucket, and we use linear probing to solve the problem of collision, we’ll end up with a clustered table! if designed a good hashing function, and table is big enough to accommodate our dataset, then linear probing can be a great solution for handling collisions. Chaining store multiple things in one hash bucket. a handy dandy linked list!! Instead of storing a single item at each hash bucket, we can chain multiple elements together so that each key of the table has a pointer that references a linked list. O(n) time:searching through a linked list takes as much time as there are elements. Chaining still averages out to a constant search time we should have approximately the same size of linked lists at any hash bucket where there is a collision. The great thing about this is that, with a good hash function, chaining still averages out to have a search time of O(1), or constant lookup time. The power is all in the function Unix and Linux operating systems use an internal hash table in order to store the contents of all the directories that are referenced by the environmental PATHvariable. If you’ve ever used a version of the rehash command, what you were really doing when you ran that command was recomputing and rehashing the system’s internal hash table! Spell checker C++中无序容器的支持关联式容器用于搜索大量数据。用hash table的时间复杂度为O(1)。 unordered_multiset123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;unordered_set&gt;void test_unordered_multiset(long&amp; value)&#123; cout &lt;&lt; "\ntest_unordered_multiset().......... \n"; unordered_multiset&lt;string&gt; c;//note.1 char buf[10]; clock_t timeStart = clock(); for(long i=0; i&lt; value; ++i) &#123; try &#123; snprintf(buf, 10, "%d", rand()); c.insert(string(buf));//note.2 &#125; catch(exception&amp; p) &#123; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; " " &lt;&lt; p.what() &lt;&lt; endl; abort(); &#125; &#125; cout &lt;&lt; "milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; cout &lt;&lt; "unordered_multiset.size()= " &lt;&lt; c.size() &lt;&lt; endl; cout &lt;&lt; "unordered_multiset.max_size()= " &lt;&lt; c.max_size() &lt;&lt; endl; //357913941 cout &lt;&lt; "unordered_multiset.bucket_count()= " &lt;&lt; c.bucket_count() &lt;&lt; endl; //note.3 cout &lt;&lt; "unordered_multiset.load_factor()= " &lt;&lt; c.load_factor() &lt;&lt; endl; cout &lt;&lt; "unordered_multiset.max_load_factor()= " &lt;&lt; c.max_load_factor() &lt;&lt; endl;//note.4 cout &lt;&lt; "unordered_multiset.max_bucket_count()= " &lt;&lt; c.max_bucket_count() &lt;&lt; endl; for (unsigned i=0; i&lt; 20; ++i) &#123; cout &lt;&lt; "bucket #" &lt;&lt; i &lt;&lt; " has " &lt;&lt; c.bucket_size(i) &lt;&lt; " elements.\n"; &#125; string target = get_a_target_string(); &#123; timeStart = clock(); auto pItem = find(c.begin(), c.end(), target); //比 c.find(...) 慢很多 cout &lt;&lt; "std::find(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, " &lt;&lt; *pItem &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl; &#125; &#123; timeStart = clock(); auto pItem = c.find(target); //比 std::find(...) 快很多 .note.5 cout &lt;&lt; "c.find(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, " &lt;&lt; *pItem &lt;&lt; endl;//note.6 else cout &lt;&lt; "not found! " &lt;&lt; endl; &#125; c.clear(); &#125; 定义set时只用声明value的类型即可，因为key等于value:unordered_multiset c; set直接插入value即可:c.insert(string(buf)); 容器总bucket数：c.bucket_count()。篮子数一定比元素总数多，当篮子数等于元素总数时，篮子总数就会double,然后打散元素重新放入到篮子中去。每个bucket中不一定有元素。选取的前二十个bucket中没有一个有元素很正常。 载重因子:c.load_factor()，最大为1。每个篮子的链表不能太长，否则影响查找效率。 容器自带的find永远比std的find快，上篇已经讲过了。 set打印时，直接解引用：*pItem。 unordered_multimap12345678910111213141516171819202122232425262728293031323334#include &lt;unordered_map&gt;void test_unordered_multimap(long&amp; value)&#123; cout &lt;&lt; "\ntest_unordered_multimap().......... \n"; unordered_multimap&lt;long, string&gt; c;//note.1 char buf[10]; clock_t timeStart = clock(); for (long i = 0; i&lt; value; ++i) &#123; try &#123; snprintf(buf, 10, "%d", rand()); //multimap 不可使用 [] 進行 insertion c.insert(pair&lt;long, string&gt;(i, buf));//note.2 &#125; catch (exception&amp; p) &#123; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; " " &lt;&lt; p.what() &lt;&lt; endl; abort(); &#125; &#125; cout &lt;&lt; "milli-seconds : " &lt;&lt; (clock() - timeStart) &lt;&lt; endl; cout &lt;&lt; "unordered_multimap.size()= " &lt;&lt; c.size() &lt;&lt; endl; cout &lt;&lt; "unordered_multimap.max_size()= " &lt;&lt; c.max_size() &lt;&lt; endl; //357913941 long target = get_a_target_long(); timeStart = clock(); auto pItem = c.find(target);//note.3 cout &lt;&lt; "c.find(), milli-seconds : " &lt;&lt; (clock() - timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, value=" &lt;&lt; (*pItem).second &lt;&lt; endl;//note.4 else cout &lt;&lt; "not found! " &lt;&lt; endl;&#125; 定义map的时候，注意模板类型：unordered_multimap&lt;long, string&gt; c; 。 要注意的依旧是multimap 不可使用 [] 進行 insertion，需要用pair分别指定key和value的类型。因为key是可以重复的: c.insert(pair&lt;long, string&gt;(i, buf)); target是key,根据key找到item:auto pItem = c.find(target); 取得value的方法,pair的第二个：(*pItem).second 。 unordered_set12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;unordered_set&gt;void test_unordered_set(long&amp; value)&#123; cout &lt;&lt; "\ntest_unordered_set().......... \n"; unordered_set&lt;string&gt; c; char buf[10]; clock_t timeStart = clock(); for(long i=0; i&lt; value; ++i) &#123; try &#123; snprintf(buf, 10, "%d", rand()); c.insert(string(buf)); &#125; catch(exception&amp; p) &#123; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; " " &lt;&lt; p.what() &lt;&lt; endl; abort(); &#125; &#125; cout &lt;&lt; "milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; cout &lt;&lt; "unordered_set.size()= " &lt;&lt; c.size() &lt;&lt; endl; cout &lt;&lt; "unordered_set.max_size()= " &lt;&lt; c.max_size() &lt;&lt; endl; //357913941 cout &lt;&lt; "unordered_set.bucket_count()= " &lt;&lt; c.bucket_count() &lt;&lt; endl; cout &lt;&lt; "unordered_set.load_factor()= " &lt;&lt; c.load_factor() &lt;&lt; endl; cout &lt;&lt; "unordered_set.max_load_factor()= " &lt;&lt; c.max_load_factor() &lt;&lt; endl; cout &lt;&lt; "unordered_set.max_bucket_count()= " &lt;&lt; c.max_bucket_count() &lt;&lt; endl; for (unsigned i=0; i&lt; 20; ++i) &#123; cout &lt;&lt; "bucket #" &lt;&lt; i &lt;&lt; " has " &lt;&lt; c.bucket_size(i) &lt;&lt; " elements.\n"; &#125; string target = get_a_target_string(); &#123; timeStart = clock(); auto pItem = find(c.begin(), c.end(), target); //比 c.find(...) 慢很多 cout &lt;&lt; "std::find(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, " &lt;&lt; *pItem &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl; &#125; &#123; timeStart = clock(); auto pItem = c.find(target); //比 std::find(...) 快很多 cout &lt;&lt; "c.find(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, " &lt;&lt; *pItem &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl; &#125; &#125; unordered_map1234567891011121314151617181920212223242526272829303132333435#include &lt;unordered_map&gt;void test_unordered_map(long&amp; value)&#123; cout &lt;&lt; "\ntest_unordered_map().......... \n"; unordered_map&lt;long, string&gt; c; char buf[10]; clock_t timeStart = clock(); for(long i=0; i&lt; value; ++i) &#123; try &#123; snprintf(buf, 10, "%d", rand()); c[i] = string(buf); &#125; catch(exception&amp; p) &#123; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; " " &lt;&lt; p.what() &lt;&lt; endl; abort(); &#125; &#125; cout &lt;&lt; "milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; cout &lt;&lt; "unordered_map.size()= " &lt;&lt; c.size() &lt;&lt; endl; //357913941 cout &lt;&lt; "unordered_map.max_size()= " &lt;&lt; c.max_size() &lt;&lt; endl; long target = get_a_target_long(); timeStart = clock(); //! auto pItem = find(c.begin(), c.end(), target); //map 不適用 std::find() auto pItem = c.find(target);//note.1 cout &lt;&lt; "c.find(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, value=" &lt;&lt; (*pItem).second &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl; &#125; 注意map不适用std的find():auto pItem = c.find(target); Resources Basics of Hash Tables, Prateek Garg Data Structure and Algorithms — Hash Table, Tutorialspoint Hash Tables, Professor John Morris CS210 Lab: Hash Table,University of Regina, Dept. of Computer Science Hash Tables, SparkNotes Introduction to Hash Tables, Professor Steve Cutchin Hash Function, Wolfram Mathworld Dictionaries and Hash Tables, Professor Sinisa Todorovic Linear Probing Hash Tables, Department of Computer Science, RMIT University Problem Solving with Algorithms and Data Structures: Hashing, Interactive Python Hash Tables, Professors Robert Sedgewick &amp; Kevin Wayne Introduction to Hashing, Professor Ananda Gunawardena]]></content>
      <categories>
        <category>Data Structures</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>unordered_map</tag>
        <tag>Unordered Containers</tag>
        <tag>Linux</tag>
        <tag>Operating System</tag>
        <tag>unordered_set</tag>
        <tag>unordered_multimap</tag>
        <tag>unordered_multiset</tag>
        <tag>Unix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[I see a red node, and I want it painted black!]]></title>
    <url>%2F2019%2F03%2F24%2FI-see-a-red-node-and-I-want-it-painted-black%2F</url>
    <content type="text"><![CDATA[本文是阅读《Painting Nodes Black With Red-Black Trees》的读书笔记，文章来自Vaidehi Joshi在medium上发布baseCS系列，该栏目用可爱的漫画来生动地解释计算机基础、数据结构、算法、理论在实践中的应用。 Intro Different approaches to solving similar problems. We depend on as programmers daily are actually built upon more naive solutions that were initially invented by someone else: Merge sort was derived as early as 1945. bubble sort and the earliest iterations of insertion sort, were invented in 1956. timsort: a hybrid of both insertion and merge sort , in 2002. It is wise to lean on solutions that have already been created by others and build upon them to create our own. AVL trees, a type of self-balancing tree that build upon the ideas of binary search trees. Red-black tree builds upon both of these two tree structures. A very disciplined tree Red-black trees were invented in 1978, by two researchers named Leonidas J. Guibas and Robert Sedgewick, at Xerox PARC, a research and development company based in Palo Alto, California. Definition a type of self-balancing binary search tree,very similar to other self-balancing trees, such as AVL trees. adhere to a strict set of rules to maintain a log time complexity and stays balanced. Rules Every single node in the tree must be either red or black. The root node of the tree must always be black. Two red nodes can never appear consecutively, one after another; a red node must always be preceded by a black node (it must have a black parent node), and a red node must always have black children nodes. Every branch path — the path from a root node to an empty (null) leaf node — must pass through the exact same number of black nodes. A branch path from the root to an empty leaf node is also known as an unsuccessful search path, since it represents the path we would take if we were to search for a node that didn’t exist within the tree. Example a null leaf node is always considered to be a black node, not red. these 4 rules are super strict and very easy to break. Proof A chain of three nodes cannot possibly every be a valid red-black tree. Following the rules of red The trickiest time to follow the rules of red-black trees is when we’re growing or shrinking the tree. A perfectly-balanced red-black tree is great, but most data structures tend to have elements and data inserted and removed from them. When it comes to red-black trees, this can be a little daunting at first. inserting a nodestrategy 1 : red Inserting a node and immediately coloring it red makes it much easier to identify and subsequently fix any violations. The first step is basically ignoring the red-black rules, and initially just figuring out where the node would go according to the rules of a normal binary search tree. At first, when we insert this node, we’ll break rule four.Instead, if we recolor our inserted node with a value of 3 to be red, instead of black, we don’t violate any of our four red-black tree rules. insert another nodestrategy 2 : recoloring recoloring nodes is one well-used technique for handling insertions and deletions into a red-black tree. locate the position for the node and recolor it to be red. However, we could also recolor the black parent node, 4, to be red instead of black. strategy 3 : rotations Rotations tend to move around and restructure the subtrees of a larger red-black tree, which can also be helpful in preventing any rule violations. left-rotation : left-rotating on the root node, 4, so that it’s right child, 11, becomes the new parent ; the subtree of 9-5-10 moved from the right subtree to the left. right-rotation : right-rotate on the new parent node, 11, and shift it down so that it once again becomes the right child of 11 ; The same subtree of 9-5-10 moved from the left subtree back to the right. Example 1Remember it’s easiest to start off by always inserting a red node, and then recoloring and rotation as necessary, afterwards. start with a single root node of 21, which will be red. recolor node 21 to be black. insert a node with a value of 8 , as the left child of the root. We can insert it as a red node. insert a node with a value of 3. rotate the grandparent node (the root) and then recolor. right-rotate the root node, and shift 21 down to become the right child of 8. recolor our original parent node of the newly-inserted node (which is now the right child), 21, and the root node, 8. If we recolor 8 and 21, our root node is back to being black, and our two child nodes are both red. The benefits of painting it blackwhat about inserting elements into a much larger red-black tree? Complicated Example 2 recoloring the parent nodes of our newly-inserted node, 10. This at least solves the problem of rule three being broken! can’t recolor 16 to be black, because if we did that, we’d be violating rule four. there are no parent nodes left to recolor (except for the root node, which we don’t want to make red!), we can now lean on rotations to help us out. rotating node 16 to the right, we’ve effectively pushed down nodes 21, 27, and 29.注意这里将16的右子树移到21的左边了! two consecutive red nodes that are still breaking rule three: 16 and 21. left-rotating node 16 and making it the new root node. perform a left-rotation on nodes 9 and 10 so that they both are on the left subtree rather than the right subtree. recolor our root (as well as it’s left child, to make sure that we don’t violate rule 4). Time Complexity and Space Complexity Compared to AVL trees, red-black trees are less-perfectly balanced. generally need fewer rotations during insertion/deletion with a red-black tree, which makes red-black trees superior for growing or shrinking a free, but less efficient for searching compared to AVL trees. The best example of a red-black trees in use today is the Linux kernel’s Completely Fair Scheduler (CFS), which was introduced as recently as 2007. This scheduler handles resource allocation for executing process from within the CPU, and actually uses red-black trees under the hood! The duality二元性 of color in red-black trees is a key part to all four of its rules, and an important part of keeping the tree balanced. As we already know, each node in a red-black tree must be either red or black. This is effectively an added piece of information that every single node must keep track of; at first, this might seem silly, because we’re tracking yet another piece of information in each node, which takes up space! However, tracking the color of a node requires only 1 bit of storage. 1 bit is a single binary digit , is a super minuscule amount of space to store either the color red or black. StoryRobert Sedgewick, who is now a professor at Princeton (and teaches an online algorithms course!), explained this story himself: A lot of people ask why did we use the name red–black. Well, we invented this data structure, this way of looking at balanced trees, at Xerox PARC which was the home of the personal computer and many other innovations that we live with today entering[sic] graphic user interfaces, ethernet and object-oriented programmings[sic] and many other things. But one of the things that was invented there was laser printing and we were very excited to have nearby color laser printer that could print things out in color and out of the colors the red looked the best. So, that’s why we picked the color red to distinguish red links, the types of links, in three nodes. C++的有序关联式容器底部支持我容易弄混map和unordered_map的底部支持。学了红黑树之后，了解到rbt具有有序的特性，而unordered_map是一种无序的关联式容器，所以unordered_map是用hash table实现的！！！C++11以前GUN版本的unordered_map是叫做hash_map。 以下内容来自侯捷老师的《STL标准库与泛型编程》课程中的测试代码，演示了各种有序关联式容器的使用效果。 multiset123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;set&gt;void test_multiset(long&amp; value)&#123; cout &lt;&lt; "\ntest_multiset().......... \n"; multiset&lt;string&gt; c; char buf[10]; clock_t timeStart = clock(); for (long i = 0; i&lt; value; ++i) &#123; try &#123; snprintf(buf, 10, "%d", rand()); c.insert(string(buf)); &#125; catch (exception&amp; p) &#123; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; " " &lt;&lt; p.what() &lt;&lt; endl; abort(); &#125; &#125; cout &lt;&lt; "milli-seconds : " &lt;&lt; (clock() - timeStart) &lt;&lt; endl; cout &lt;&lt; "multiset.size()= " &lt;&lt; c.size() &lt;&lt; endl; cout &lt;&lt; "multiset.max_size()= " &lt;&lt; c.max_size() &lt;&lt; endl; //214748364 string target = get_a_target_string(); &#123; timeStart = clock(); auto pItem = find(c.begin(), c.end(), target); //比 c.find(...) 慢很多 cout &lt;&lt; "std::find(), milli-seconds : " &lt;&lt; (clock() - timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, " &lt;&lt; *pItem &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl; &#125; &#123; timeStart = clock(); auto pItem = c.find(target); //比 std::find(...) 快很多 cout &lt;&lt; "c.find(), milli-seconds : " &lt;&lt; (clock() - timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, " &lt;&lt; *pItem &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl; &#125; c.clear();&#125; 最后清空容器 multimap123456789101112131415161718192021222324252627282930313233343536#include &lt;map&gt;void test_multimap(long&amp; value)&#123; cout &lt;&lt; "\ntest_multimap().......... \n"; multimap&lt;long, string&gt; c; char buf[10]; clock_t timeStart = clock(); for (long i = 0; i&lt; value; ++i) &#123; try &#123; snprintf(buf, 10, "%d", rand()); //multimap 不可使用 [] 做 insertion c.insert(pair&lt;long, string&gt;(i, buf)); &#125; catch (exception&amp; p) &#123; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; " " &lt;&lt; p.what() &lt;&lt; endl; abort(); &#125; &#125; cout &lt;&lt; "milli-seconds : " &lt;&lt; (clock() - timeStart) &lt;&lt; endl; cout &lt;&lt; "multimap.size()= " &lt;&lt; c.size() &lt;&lt; endl; cout &lt;&lt; "multimap.max_size()= " &lt;&lt; c.max_size() &lt;&lt; endl; //178956970 long target = get_a_target_long(); timeStart = clock(); auto pItem = c.find(target); cout &lt;&lt; "c.find(), milli-seconds : " &lt;&lt; (clock() - timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, value=" &lt;&lt; (*pItem).second &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl; c.clear();&#125; multimap 不可使用 [] 做 insertion,要用内置类型pair&lt;key,vale&gt; ，因为key是可能重复的。 set12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;set&gt;void test_set(long&amp; value)&#123; cout &lt;&lt; "\ntest_set().......... \n"; set&lt;string&gt; c; char buf[10]; clock_t timeStart = clock(); for (long i = 0; i&lt; value; ++i) &#123; try &#123; snprintf(buf, 10, "%d", rand()); c.insert(string(buf)); &#125; catch (exception&amp; p) &#123; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; " " &lt;&lt; p.what() &lt;&lt; endl; abort(); &#125; &#125; cout &lt;&lt; "milli-seconds : " &lt;&lt; (clock() - timeStart) &lt;&lt; endl; cout &lt;&lt; "set.size()= " &lt;&lt; c.size() &lt;&lt; endl; cout &lt;&lt; "set.max_size()= " &lt;&lt; c.max_size() &lt;&lt; endl; //214748364 string target = get_a_target_string(); &#123; timeStart = clock(); auto pItem = find(c.begin(), c.end(), target); //比 c.find(...) 慢很多 cout &lt;&lt; "std::find(), milli-seconds : " &lt;&lt; (clock() - timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, " &lt;&lt; *pItem &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl; &#125; &#123; timeStart = clock(); auto pItem = c.find(target); //比 std::find(...) 快很多 cout &lt;&lt; "c.find(), milli-seconds : " &lt;&lt; (clock() - timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, " &lt;&lt; *pItem &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl; &#125; c.clear();&#125; 这里set的实际大小是32768，因为每个key是不重复的，他的类型是long,4个字节，范围是0~32767,2^15-1. 用容器对应的find()方法比std全局的find()方法要快很多，百万级数据是20ms的差别！ map123456789101112131415161718192021222324252627282930313233343536#include &lt;map&gt;void test_map(long&amp; value)&#123; cout &lt;&lt; "\ntest_map().......... \n"; map&lt;long, string&gt; c; char buf[10];//clock_t timeStart = clock(); for(long i=0; i&lt; value; ++i) &#123; try &#123; snprintf(buf, 10, "%d", rand()); c[i] = string(buf); &#125; catch(exception&amp; p) &#123; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; " " &lt;&lt; p.what() &lt;&lt; endl; abort(); &#125; &#125; cout &lt;&lt; "milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; cout &lt;&lt; "map.size()= " &lt;&lt; c.size() &lt;&lt; endl; cout &lt;&lt; "map.max_size()= " &lt;&lt; c.max_size() &lt;&lt; endl; long target = get_a_target_long(); timeStart = clock(); auto pItem = c.find(target); cout &lt;&lt; "c.find(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, value=" &lt;&lt; (*pItem).second &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl; c.clear(); &#125; 构建百万级数据容器的时候花了22秒，但是在搜索的时候很快！说明rbt很适合搜索！！ 而由于rbt比avl的平衡性差一些，所以在搜索方面avl更快，而rbt在建树速度上优于avl！！ 可以直接用[]，c[i] = string(buf);。i是不重复的。 Resources Coursera Lecture 45 — Red-Black BSTs, Robert Sedgewick Generic Red-Black Tree, Dr. Richard Wiener Red-Black Trees, Professor Jim Skrentny Red/Black Tree Visualization, Professor David Galles Red-Black Tree Introduction, GeeksforGeeks]]></content>
      <categories>
        <category>Data Structures</category>
      </categories>
      <tags>
        <tag>RBT</tag>
        <tag>multiset</tag>
        <tag>Linux</tag>
        <tag>map</tag>
        <tag>set</tag>
        <tag>multimap</tag>
        <tag>Associative Containers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我在JitHub上的插眼汇总]]></title>
    <url>%2F2019%2F03%2F23%2F%E6%88%91%E5%9C%A8JitHub%E4%B8%8A%E7%9A%84%E6%8F%92%E7%9C%BC%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[💎 build-your-own-x - 制作你的 ?写轮子总是一件愉快的事情，做完之后绝对会感到很多的成就感！ 这个项目收集了很多方面的很多教程，比较有趣的有：搜索引擎、AR、Bot、前端库、数据库、神经网络、操作系统还有程序设计语言等等，够你玩了！ 不过这些内容都是全英文的，对英文要求较高~ 快去制作你的轮子吧！ GitHub 项目地址🔗 github.com Creating Your Own Containers Write your own Operating System Implementing a Key-Value Store 输了一大串命令回车后才发现命令打错字母了怎么办？输入f*ck帮你轻松搞定😈️GitHub项目 TheFuck：github.com]]></content>
      <categories>
        <category>Projects</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B tree,B+ tree,B* tree,RBT,AVL]]></title>
    <url>%2F2019%2F03%2F23%2FB-tree-B-tree-B-tree-RBT-AVL%2F</url>
    <content type="text"><![CDATA[whats B tree? self balancing search tree. each node can hold multiple keys. all leaf nodes are the same distance from the root. an extension of self-balancing binary search trees. allow each node to hold multiple keys and have multiple children. designed to take advantage of systems that can read and write in large blocks, and are commonly used in databases and file systems. B-Tree，RBT or AVL tree? When using a RB tree, B- tree or an AVL tree? What are the key points before deciding on the choice? explain with a scenario . Answer B-tree 适合存海量数据 When you’re managing more than thousands of items and you’re paging them from a disk or some slow storage medium. Can have variable number of children which allow it to hold many records but still maintain a short height tree. A good general-purpose ordered container data structure, even in main memory. Even when virtual memory isn’t an issue, cache-friendliness缓存友好 often is. B+ trees are particularly good for sequential access - the same asymptotic渐近 performance as a linked list, but with cache-friendliness close to a simple array. All this and O(log n) search, insert and delete. B+ trees do have problems, though - such as the items moving around within nodes when you do inserts/deletes, invalidating pointers to those items. this means you get fairly easy O(n) merging of trees - convert both trees to lists, merge them, then convert back to a tree. RB tree 适合增删 when you’re doing fairly frequent inserts, deletes and retrievals检索 on the tree. Has less strict rules around rebalancing which make insertions/deletions quicker than AVL tree. RB trees also have better performance O(1) on the rebalance which makes them more suitable for persistent datastructures with roll-back and roll-forward. AVL tree 适合检索 when your inserts and deletes are infrequent relative to your retrievals. More strictly balanced so lookups are faster than RB tree. B-Tree vs Hash Table In MySQL, an index type is a b-tree, and access an element in a b-tree is in logarithmic amortized time O(log(n)). On the other hand, accessing an element in a hash table is in O(1). Why is a hash table not used instead of a b-tree in order to access data inside a database? Answer You can only access elements by their primary key in a hashtable. This is faster than with a tree algorithm (O(1) instead of log(n)), but you cannot select ranges (everything in between xand y). Tree algorithms support this in Log(n) whereas hash indexes can result in a full table scan O(n). Also the constant overhead of hash indexes is usually bigger (which is no factor in theta notation, but it still exists). Also tree algorithms are usually easier to maintain, grow with data, scale, etc. Hash indexes work with pre-defined hash sizes, so you end up with some “buckets” where the objects are stored in. These objects are looped over again to really find the right one inside this partition. Todays hash tables algorithms usually scale, but scaling can be inefficient. There are indeed scalable hashing algorithms. they evolved(进化) from scalable replication where re-hashing is not easy. Its called RUSH - Replication Under Scalable Hashing, and those algorithms are thus called RUSH algorithms. However there may be a point where your index exceeds a tolerable size compared to your hash sizes and your entire index needs to be re-built. Usually this is not a problem, but for huge-huge-huge databases, this can take days. The trade off for tree algorithms is small and they are suitable for almost every use case and thus are default. B trees and B+ trees? In a b- tree you can store both keys and data in the internal and leaf nodes In a b+ tree you have to store the data in the leaf nodes only. Is there any advantage of doing the above in a b+ tree? Why not use b-trees instead of b+ trees everywhere, as intuitively they seem much faster? I mean, why do you need to replicate the key(data) in a b+ tree? Answear Advantages of B+ trees: B+ trees don’t have data associated with interior内部 nodes, more keys can fit on a page of memory. Therefore, it will require fewer cache misses in order to access data that is on a leaf node. The leaf nodes of B+ trees are linked, so doing a full scan of all objects in a tree requires just one linear pass through all the leaf nodes. A B tree would require a traversal of every level in the tree. This full-tree traversal will likely involve more cache misses than the linear traversal of B+ leaves. Advantage of B trees: Because B trees contain data with each key, frequently accessed nodes can lie closer to the root, and therefore can be accessed more quickly. What’s a B*Tree? Did they just mean binary search tree? Answer No. A node in a B*Tree can have many keys (which point to many children). They operate by comparing keys in order to select a child node, much like a binary tree. But, the intent is that each node is stored on disk, and can be read into memory at once. Thus, the number of disk accesses required would match the depth of the tree. Note that the * indicates the nodes are at least 2/3 full. Reference When to choose RB tree, B-Tree or AVL tree? B-Tree vs Hash Table Differences between B trees and B+ trees What’s a B*Tree? to be continued… Further Reading Painting Nodes Black With Red-Black Trees Busying Oneself With B-Trees How does a red-black tree work? How to easily remember Red-Black Tree insert and delete? Red Black Tree versus B Tree Applications of red-black trees Red-Black Trees What additional rotation is required for deletion from a Top-Down 2-3-4 Left-leaning Red Black tree? Statistical performance of purely functional maps and sets Red black tree over avl tree Difference between red-black trees and AVL trees bitmap]]></content>
      <categories>
        <category>Data Structures</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>B tree</tag>
        <tag>B+ tree</tag>
        <tag>B* tree</tag>
        <tag>RBT</tag>
        <tag>AVL</tag>
        <tag>mysql</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode263. Ugly Number]]></title>
    <url>%2F2019%2F03%2F23%2FLeetCode263-Ugly-Number%2F</url>
    <content type="text"><![CDATA[第一题Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. Example 1: 123Input: 6Output: trueExplanation: 6 = 2 × 3 Example 2: 123Input: 8Output: trueExplanation: 8 = 2 × 2 × 2 Example 3: 123Input: 14Output: false Explanation: 14 is not ugly since it includes another prime factor 7. Note: 1 is typically treated as an ugly number. Input is within the 32-bit signed integer range: [−2^31, 2^31 − 1]. 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。 思路 丑数就是因子不能包含除了2，3，5以外的数，1也是丑数。 从2开始，将n除以2，一直除到不包含2这个因子为止；然后开始整除3；开始整除5;最后将2，3，5三个因子除尽，丑数必为1，判断是否为1即可。 可以直接写成for(int i=2;i&lt;=5;i++)，里面包含4，因为4可以拆成2*2,不影响丑数的定义。 C++ code1234567891011class Solution &#123;public: bool isUgly(int num) &#123; for(int i=2;i&lt;=5&amp;&amp;num;i++) &#123; while(num%i==0) num/=i; &#125; return num==1; &#125;&#125;; 第二题找到第n个丑数 Write a program to find the n-th ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. Example: 123Input: n = 10Output: 12Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers. Note: 1 is typically treated as an ugly number. n does not exceed 1690. 思路 The naive approach is to call isUgly for every number until you reach the nth one. Most numbers are not ugly. Try to focus your effort on generating only the ugly ones. An ugly number must be multiplied by either 2, 3, or 5 from a smaller ugly number. The key is how to maintain the order of the ugly numbers. Try a similar approach of merging from three sorted lists: L1, L2, and L3. Assume you have Uk, the kth ugly number. Then Uk+1 must be Min(L1 2, L2 3, L3 * 5). 细节 uglynum容器中的每一个数都要经过2，3，5的洗礼，取到接受洗礼的数中最小的一个作为勇者并放入丑数容器中。如果被选中的勇者是经过2洗礼的，那么就让2取洗礼容器中的下一个数，所以2的指针++ 为什么不用if else判断呢，因为在选中最小的数中，是最小公倍数，所以有可能因子包含2，3，5，所以只要判断是不是当前指针所指数的倍数就好，如果是的话，就要洗礼丑数容器中的下一个数。 C++ code123456789101112131415161718class Solution &#123;public: int GetUglyNumber_Solution(int index) &#123; if(index&lt;=6)return index; vector&lt;int&gt; a; a.push_back(1); int t2=0,t3=0,t5=0; while(a.size()&lt;index)//这里不能用等号 &#123; a.push_back(min(min(a[t2]*2,a[t3]*3),a[t5]*5));//此时预演，指针还没有动 //判断新加入的丑数是不是当前每个因子指针的倍数，如果是的话，就往前移动一格，说明已经对旧丑数做了乘以因子的处理了 if(a.back()==a[t2]*2) t2++; if(a.back()==a[t3]*3) t3++; if(a.back()==a[t5]*5) t5++;//这里千万不能用if else啊！！ &#125; return a.back(); &#125;&#125;; 总结 关键点是维护好丑数的顺序，融合三个有序序列的最小值，这个最小值加入到丑数数组中，也是有序的。 因为丑数数组是一个有序的的数组，想到用DP来解决，DP的精髓就是把大问题分解成小问题，而且要保存小问题的解。怎么保存呢，可以开三个数组，但是用指针会更方便。本题用三个指针，以下标的形式，a[t2],a[t3],a[t5],来分别指向丑数容器中要乘以2，3，5的数。 最新的丑数就是在这三个指针所指的数上再分别乘以2，3，5后，其中的最小一个。新的丑数中可能也还有别的两个因子，所以要判断是否是其他因子的倍数，然后移动相关的指针，注意每个因子都要判断。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>pointer</tag>
        <tag>Dynamic Programming</tag>
        <tag>Math</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ STL篇 仿函数]]></title>
    <url>%2F2019%2F03%2F23%2FC-STL%E7%AF%87-%E4%BB%BF%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[引入 六大部件之一。只为算法服务，比如排序，累加等算法，如果需要自定义准则，就需要自己写仿函数附加到STL中去。 必须重载()，模仿函数。 三大分类：算术类 Arithmetic;逻辑运算类 Logical;相对关系类 Relational 123456789101112//算术类 Arithmetictemplate&lt;class T&gt; struct plus:public binary_function&lt;T,T,T&gt;&#123; T operator()(const T&amp;x,const T&amp;y) const &#123;return x+y;&#125; &#125;;template&lt;class T&gt; struct minus:public binary_function&lt;T,T,T&gt;&#123; T operator()(const T&amp;x,const T&amp;y) const &#123;return x-y;&#125; &#125;; 123456//逻辑运算类 Logicaltemplate&lt;class T&gt; struct logical_and:public binary_function&lt;T,T,bool&gt;&#123; bool operator()(const T&amp;x,const T&amp;y) const &#123;return x&amp;&amp;y;&#125; &#125;; 123456789101112131415//相对关系类 Relationaltemplate&lt;class T&gt; struct equal_to:public binary_function&lt;T,T,bool&gt;&#123; bool operator()(const T&amp;x,const T&amp;y) const &#123;return x==y;&#125; &#125;;template&lt;class T&gt; struct less:public binary_function&lt;T,T,bool&gt;&#123; bool operator()(const T&amp;x,const T&amp;y) const &#123;return x&lt;y;&#125; &#125;;template&lt;typename Iterator,typename Cmp&gt;Algorithm(Iterator itr1,Iterator itr2,Cmp comp)&#123;...&#125; to be continued…]]></content>
      <categories>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>Function Object</tag>
        <tag>functors</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 函数篇 lambda表达式]]></title>
    <url>%2F2019%2F03%2F23%2FC-%E5%87%BD%E6%95%B0%E7%AF%87-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[以下为从wiki、侯捷老师的深入STL、stackoverflow中research的资料。 wikic++11提供了匿名函数的支持，叫做lambda表达式，形式如下： 1[capture](parameters) mutable exception attribute -&gt; return_type &#123;body&#125; 必须用[]括起来的capture列表来开始一个lambda表达式的定义。 lambda函数的形参表比普通函数的形参表多了三条限制： 参数不能有缺省值 不能有可变长参数列表 不能有无名参数 如果没有形参，且没有mutable、exception、attribute声明，参数的圆括号可以省略。如果有声明，即使参数为空，也不能省略。 如果函数体就只有一个return语句，或者返回值为void，那么返回值类型声明可以省略： 1[capture](para)&#123;body&#125; Example1234[](int x,int y)&#123;return x+y;&#125;//return中隐式获得返回值类型，返回值类型是decltype(x+y)。[](int&amp; x)&#123;++x;&#125;//没有return语句，返回值为void[]()&#123;++global_x;&#125;[]&#123;++global_x;&#125;//没有参数，可以省略() 闭包 lambda函数可以捕获lambda函数外的具有automatic storage duration的变量，即函数的局部变量与函数形参变量。函数体与这些变量的集合合起来称做闭包)。 这些外部变量在声明lambda表达式时列在在方括号[]中。空的方括号表示没有外界变量被capture或者按照默认方式捕获外界变量。这些变量被传值捕获或者引用捕获。 对于传值捕获的变量，默认为只读（这是由于lambda表达式生成的为一个函数对象，它的operator()成员缺省有const属性）。修改这些传值捕获变量将导致编译报错。 但在lambda表达式的参数表的圆括号后面使用mutable关键字，就允许lambda函数体内的语句修改传值捕获变量，这些修改与lambda表达式（实际上是用函数对象实现）有相同的生命期，但不影响被传值捕获的外部变量的值。 lambda函数可以直接使用具有static存储期的变量。如果在lambda函数的捕获列表中给出了static存储期的变量，编译时会给出警告，仍然按照lambda函数直接使用这些外部变量来处理。因此具有static存储期的变量即使被声明为传值捕获，修改该变量实际上直接修改了这些外部变量。 编译器生成lambda函数对应的函数对象时，不会用函数对象的数据成员来保持被“捕获”的static存储期的变量。 123456[]//没有定义任何变量，但是必须列出空的方括号。lambda表达式中尝试使用任何外部变量都会导致编译错误。[x,&amp;y] //x按值传递，y按引用传递[&amp;]//任何被使用的外部变量都按引用传递[=]//任何被使用的外部变量都按值传递[&amp;,x]//x按值传入，其它变量按引用传入[=,&amp;z]//z按引用传入，其它变量按值传入 Example1234vector&lt;int&gt; some_list&#123;1,2,3,4,5&#125;;int total=0;for_each(begin(some_list),end(some_list), [&amp;total](int x)&#123;total+=x;&#125;); this指针在类的非静态成员函数中定义的lambda表达式可以显式或隐式捕捉this指针，从而可以引用所在类对象的数据成员与函数成员。 lambda函数的函数体中，可以访问下述变量： 函数参数 局部声明的变量 类数据成员：要求lambda表达式声明在类成员函数中，对象的this指针必需显式捕获声明。 具有静态存储期的变量（如全局变量） 被捕获的外部变量 显式捕获的变量 隐式捕获的变量，使用默认捕获模式（传值或引用）来访问。 模板类型lambda函数的数据类型是函数对象，保存时必须用std::function模板类型或auto关键字。 123456789101112131415161718192021222324252627282930#include &lt;vector&gt;#include &lt;functional&gt;#include &lt;iostream&gt;using namespace std;double eval(std::function &lt;double(double)&gt; f, double x = 2.0)&#123; return f(x);&#125;int main()&#123; std::function&lt;double(double)&gt; f0 = [](double x) &#123;return 1; &#125;; auto f1 = [](double x) &#123;return x; &#125;; decltype(f0) fa[3] = &#123; f0,f1,[](double x) &#123;return x*x; &#125; &#125;; std::vector&lt;decltype(f0)&gt; fv = &#123; f0,f1 &#125;; fv.push_back([](double x) &#123;return x*x; &#125;);//fv.size()=3 for (int i = 0; i&lt;fv.size(); i++) std::cout &lt;&lt; fv[i](2.0) &lt;&lt; std::endl;//1,2,4 for (int i = 0; i&lt;3; i++) std::cout &lt;&lt; fa[i](2.0) &lt;&lt; std::endl;//1,2,4 for (auto &amp;f : fv) std::cout &lt;&lt; f(2.0) &lt;&lt; std::endl;//1,2,4 for (auto &amp;f : fa) std::cout &lt;&lt; f(2.0) &lt;&lt; std::endl;//1,2,4 std::cout &lt;&lt; eval(f0) &lt;&lt; std::endl;//1 std::cout &lt;&lt; eval(f1) &lt;&lt; std::endl;//2 std::cout &lt;&lt; eval([](double x) &#123;return x*x; &#125;) &lt;&lt; std::endl;//4 return 0;&#125; C++11 侯捷 C++ 11 introdued lamndas,allowing the definition of inline functionality,which can be used as a parameter or a local object. Lambdas change the way the C++ standard library is used. 仿函数。其实是一个对象类型。用()可以直接调用，一个仿函数对象。 A lambda is a definition of functionality that can be defined inside statements and expressions. You can use a lambda as an inline function. The minimal lambda funcion hsa no paramemter and simply does something: Lambdas The type of a lambda is an anonymous function object(or functor) that is unique for each lambda expression. To declare objects of that type,you need templates or auto. If you need type ,you can use decltype(),which is ,required to pass a lambda as hash function or ordering or sorting criterion to associative or unordered containers. 1234567auto cmp=[](const Person&amp;p1,const Person&amp;p2)&#123; return p1.lastname()&lt;p2.lastname()|| (p1.lastname()==p2.lastname()&amp;&amp; p1.firstname()&lt;p2.firstname());&#125;;...std::set&lt;Person,decltype(cmp)&gt; coll(cmp); You need the type of the lambda for the declaration of the set, decltype must be used,which yields the type of a lambda object,such as cmp. Note that you also have to pass the lambda object to the constructor of coll;otherwise,coll would call the default constructor for the sorting criterion(准则) passed,and by rule lambdas have no default constructor and no assignment operator.(lambda没有默认构造函数，也没有赋值操作。) So,for a sorting criterion,a class defining the function objects might still be more intuitive.（如果用lambda写排序准则，由于没有默认构造函数，所以使用的时候容易出错。 12345678910111213141516171819template&lt;class Key, class Compare=less&lt;Key&gt;, class Alloc=alloc&gt;class set&#123;public://typedefs:...typedef Compare key_compare;typedef Compare value_compare;private:typedef rb_tree&lt;key_type,value_type, identity&lt;value_type&gt;, key_compare,Alloc&gt;rep_type;rep_type t;//red-black tree representing setpublic:...set():t(Compare())&#123;&#125;//调用默认构造函数explicit set(const Compare&amp; comp):t(const)&#123;&#125;&#125; Function objects are a very powerful way to customize the behavior of STL algorithms,and can encapsulate both code and data (unlike plain functions). But Function objects are inconvenient to define because of the need to entire classes. Moreover,they are not defined in the place in yout source code where you are trying to use them, and the non-locality makes them more difficult to use. Libraries have attempted to mitigate(减轻) some of the problems of verbosity(冗长) and non-locality ,but dont offer much help because the syntax becomes complicated and the compiler errors are not very friendly. Using function objects from libraries is also less efficient since the function objects defined as data members are not in-lined. Lambda expressions address these problems. The following code snippet shows a lambda expression used in a program to integers between variables x and y from a vector of integers. 123456789vector&lt;int&gt; vi&#123;5,28,50,83,70,590,245,59,24&#125;;int x = 30;int y = 100;vi.erase(remove_if(vi.begin(),vi.end(), [x,y](int n)&#123;return x&lt;n&amp;&amp;n&lt;y;&#125;), vi.end());//把(30,100)内的数字拿掉for(auto i:vi) cout&lt;&lt;i&lt;&lt;'';//5 28 590 245 24cout&lt;&lt;endl; 12345678910111213class LambdaFunctor&#123;public: LambdaFunctor(int a,int b):m_a(a),m_b(b)&#123;&#125; bool operator()(int n) const&#123; return m_a&lt;n&amp;&amp;n&lt;m_b; &#125;private: int m_a; int m_b; &#125;;v.erase(remove_if(v.begin(),v.end(), LambdaFunctor(x,y)), v.end()); stackoverflowref:stackoverflow Q: 123What is a lambda expression in C++11? When would I use one? What class of problem do they solve that wasn't possible prior to their introduction?A few examples, and use cases would be useful. A: The problem C++ includes useful generic functions like std::for_each and std::transform, which can be very handy. Unfortunately they can also be quite cumbersome to use, particularly if the functor you would like to apply is unique to the particular function. 123456789101112131415#include &lt;algorithm&gt;#include &lt;vector&gt;namespace &#123; struct f &#123; void operator()(int) &#123; // do something &#125; &#125;;&#125;void func(std::vector&lt;int&gt;&amp; v) &#123; f f; std::for_each(v.begin(), v.end(), f);&#125; If you only use f once and in that specific place it seems overkill to be writing a whole class just to do something trivial and one off. In C++03 you might be tempted to write something like the following, to keep the functor local: 12345678void func2(std::vector&lt;int&gt;&amp; v) &#123; struct &#123; void operator()(int) &#123; // do something &#125; &#125; f; std::for_each(v.begin(), v.end(), f);&#125; however this is not allowed, f cannot be passed to a template function in C++03. The new solutionC++11 introduces lambdas allow you to write an inline, anonymous functor to replace the struct f. For small simple examples this can be cleaner to read (it keeps everything in one place) and potentially simpler to maintain, for example in the simplest form: 123void func3(std::vector&lt;int&gt;&amp; v) &#123; std::for_each(v.begin(), v.end(), [](int) &#123; /* do something here*/ &#125;);&#125; Lambda functions are just syntactic（句法） sugar for anonymous functors. Return typesIn simple cases the return type of the lambda is deduced(推导) for you, e.g.: 12345void func4(std::vector&lt;double&gt;&amp; v) &#123; std::transform(v.begin(), v.end(), v.begin(), [](double d) &#123; return d &lt; 0.00001 ? 0 : d; &#125; );&#125; however when you start to write more complex lambdas you will quickly encounter cases where the return type cannot be deduced by the compiler, e.g.: 12345678910void func4(std::vector&lt;double&gt;&amp; v) &#123; std::transform(v.begin(), v.end(), v.begin(), [](double d) &#123; if (d &lt; 0.0001) &#123; return 0; &#125; else &#123; return d; &#125; &#125;);&#125; -&gt;：explicitly specify a return typeTo resolve this you are allowed to explicitly specify a return type for a lambda function, using -&gt; T: 12345678910void func4(std::vector&lt;double&gt;&amp; v) &#123; std::transform(v.begin(), v.end(), v.begin(), [](double d) -&gt; double &#123; if (d &lt; 0.0001) &#123; return 0; &#125; else &#123; return d; &#125; &#125;);&#125; “Capturing” variablesSo far we’ve not used anything other than what was passed to the lambda within it, but we can also use other variables, within the lambda. If you want to access other variables you can use the capture clause (the [] of the expression), which has so far been unused in these examples, e.g.: 12345678910void func5(std::vector&lt;double&gt;&amp; v, const double&amp; epsilon) &#123; std::transform(v.begin(), v.end(), v.begin(), [epsilon](double d) -&gt; double &#123; if (d &lt; epsilon) &#123; return 0; &#125; else &#123; return d; &#125; &#125;);&#125; You can capture by both reference and value, which you can specify using &amp; and =respectively。（见闭包） The generated operator() is const by default, with the implication(意义) that captures will be const when you access them by default. This has the effect that each call with the same input would produce the same result, however you can mark the lambda as mutable to request that the operator() that is produced is not const.]]></content>
      <categories>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>Function Object</tag>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次游戏沙龙分享会]]></title>
    <url>%2F2019%2F03%2F22%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%B8%B8%E6%88%8F%E6%B2%99%E9%BE%99%E5%88%86%E4%BA%AB%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[Messiah引擎回忆录 Sparse Voxel Octree Cone Tracing C++ Hot Reload 迭代/重做的选择 天下引擎： 插件层：PhysX/fMod/Behavior/umbra/BEAST 游戏层：AI/寻路/车辆/场景管理/渲染管线/渲染引擎/光照/材质/天气 框架层：主循环-&gt;Thread pool-&gt;IO /内存管理/网络通信/脚本系统 系统层：Windows(跨平台抽象，主手游市场）/Direct X（跨API抽象） 90%的手机都是四核以上，场景更新-&gt;渲染引擎-&gt;图形API Main Thread:Tick-&gt;Render-&gt;Present Game Thread:Tick-&gt;Render Render Thread:Prensent-&gt;Commit to Device-&gt;Present 烘焙：预计算光照，大部分3D手游选择烘焙。CloudGI:完全跑在GPU上的烘培引擎。 游戏成长之路 CS理论：算法/数据结构/设计模式。图形学。物理仿真。分布式计算。高性能网络。人工智能。 脚本python。S/C全服秒热更。深度改造Python虚拟机。 C/C++:极其高效的语言，对效率有极致要求的核心模块。C++17。多线程任务系统。3D渲染器。网络底库。数学库。 有限状态机FSM：以数据驱动代码，而不是代码就是数据。 好的代码出来步需要写第二次（DRY原则），这就是程序员之间的差别了，这里面水太深了，技术栈的背后是深厚扎实的理论算法数据结构基础在做支撑。 应该成为一个发明流水线的程序员，而不是在流水线上作业的程序员。 用代码去提升生产效率，而不是成为生产效率的瓶颈。 行为树（Behavior Tree)：四个结点+1个规则。 角色移动同步：对实时性有极致要求，tcp协议无法满载极致的低延迟需求（它的拥塞控制，完全可靠的特性），所以用udp的低延迟协议（更优的丢包重传算法，应答模型，支持半可靠包。）400ms延迟，40%丢包极限工况下依然能工作。 航位推测算法（Dead Reckoning)。 一些碎碎念人类在生活中要受到精神与物质的双重束缚，在这些束缚中就失去了理想和自由。于是人们用剩余的精神创造一个自由的世界，它就是游戏。 跟牛奶老师一样，游戏已然是一种精神上的寄托。尽管现在玩游戏的时间已经压榨到没有了，是因为想成为一个maker，而不是普通的player，所以会好好补技术栈！虽然我现在水平很菜，但是做了一个从小到大以来，为数不多的自己选择的决定（上一个是转系考软件工程，我真的非常努力去实现了）。 虽然走的很慢，但是如果是为了热爱，方向就是对的。就像我喜欢写代码，喜欢玩游戏，喜欢计算机，喜欢ACG，喜欢东方，喜欢LOL……尽管没有人可以永远陪我一起分享这些快乐，可我还是喜欢他们，因为他们给我带来了感动，这些是我精神世界中的宝藏啊，我愿意为他们付出时间、金钱、精力。 之前浪费了不少时间在无聊的事情上，导致现在技术栈太浅了，也许等我技术到了一定的水平，自然可以遇到和我讨论这些技术的大佬了呢，那种灵感碰撞出的火花真是让人向往啊！]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的offer之路]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%88%91%E7%9A%84offer%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[腾讯提前批 后端C++2019/3/22/16：00/34mins ​ 扎心了，第一次面试就是面的腾讯爸爸。约的是视频面试，我还特意画了个妆，结果是电话面试ORZ。 打招呼 看你最近在刷题？（他有我微信）是的。那我看你的笔试分数不怎么高呢。emmm,我当时按错了，以为后面有选择题。面试官：别紧张，我就调侃你一下。（我真的超紧张。 自我介绍：本科专业。研究方向。做的项目。 问题 单向链表逆转：我突然脑子短路，直接问提示。之后我说用三个指针从头开始遍历……打断：简单描述。我脑子一团浆糊：没有说清楚。“你说的也差不多是那个意思。”我后来发现我连函数入口检查的鲁棒性测试都没有讲。 数据库，B树，B树索引：不会(见：B tree,B+ tree,B* tree,RBT,AVL 2G内存怎么实现：hash表。“hash表？？？””不清楚，大数问题没看，bitmap？”“……下一题” TCP三次握手四次挥手：不会。(见：Understanding the TCP/IP protocol suite 快排：随机取一个数，从头到尾遍历数组，小的放在这个数左边，大的放在右边。“时间复杂度？”：nlogn。为什么：因为是用二分法的思想，所以是对数。稳定吗：不稳定，最差n^2。为什么会n^2：因为随机取得数可能没有取好。 Linux进程查看：不会。 虚函数：多态的实现，基类的虚函数需要在派生类中实现，动态绑定的时候，系统会根据虚表找到调用对象所指的虚指针，然后在程序运行的时候，去调用重写的虚函数。（自我感觉很啰嗦 G是F的基类，F是C的基类，C还可以有继承么：可以，只要没有声明final就可以，C++11的两个关键字final禁止重写,override显示声明是虚函数。 C继承于F，并且向上转型，调用的重写方法是哪个对象的：C的，系统会找到虚指针，然后根据C对象的this指针，放入到调用方法的参数中。 堆的实现：STL里面有一个优先队列和multiset.优先队列是最？堆实现的。multiset是rbt实现的最？堆。（我忘了，复习过但是没掌握好。）简单的说说建最小堆：跟堆顶比较，如果比堆顶大就放右子树，然后再和右子树比较。如果比堆顶小，就交换位置，然后堆顶放左子树。（我没有掌握好。看过一点 内存泄漏：指针没有初始化，可能指向某个未知的位置，野指针。或者一个变量在离开作用域之前没有释放掉他的资源，后面无法获取这个变量，就不能释放了，会造成内存泄漏。这就是基类的析构函数要定义成虚函数的原因。（自我感觉很啰嗦 mvc：是.Net的一种设计模式。mvc分别代表什么：m是模型。v是视图。c是控制器。作用：模型是对象。v是前端交互。c是业务逻辑访问。（大概是3-4年前做得一个项目，我都忘了mvc是什么了。很久没碰了。 在公司做什么：客户端框架插件的设计。（其实没什么很大的进步 讲讲数学建模竞赛的项目：多维度的数据分析，用的pca降维，然后预测。（啰嗦，被打断 用过java吗：没有，但是可以学。“我们这个应用java缺人。。”“…” 提问我有什么需要提升的地方？ 语言组织方便欠缺，最好要简短精确地回答问题。（我承认平常跟人类交流沟通少了，另外知识体系网络不够扎实，脑海中地逻辑结构不是很清晰。需要每天自省，做过的题目要好好地review，掌握牢固。深入消化理解。 如果是后台开发，对计网需要了解，tcp/ip这方面要看一看。（我应该去补补这种基础课，虽然不是科班出身，但是志愿的行业无论是服务器还是游戏都需要扎实的基本功。 什么时候会收到消息？ 如果有其它部门捞你的话，会给你发邮件的。 总结这可能是我离鹅爸爸最近的一次吧。我对自己的反思： 不够自信：导致对话的时候居然有点颤抖，不自信的原因还是因为自己没有准备完备，这样给面试官的印象不会太好，可能会觉得我这个人不靠谱，不干练。 知识网络没有构建好：还有很多基础性的知识我都没有答上来。尤其是计网，操作系统，Linux。需要恶补。还好c++的问题都比较熟。数据结构的回答不是很好，可能刷题有点盲目，需要对刷过的题目有很深的理解，经常复盘。 态度问题：我可能开始就觉得没有希望，所以准备的也不是很完备。但是这一次面试之后，我的信念更坚定了，已经迈出了第一步，开始认认真真地复盘。这次的面试给我了一些希望，我觉得只要努力，有准备，还是有机会的。 写在后面这几天有点沉迷玩博客的构建了，把春招这事看得很佛系，本来基础并不是很好的我貌似也没有把春招看得很重要，主要把宝压在秋招了。现在看看还是应该给自己更多的压力，对自己要求高一点。另外昨天看了猪厂的游戏引擎沙龙分享，我对进入游戏行业已经迫不及待+蠢蠢欲动了。 阿里2019/3/25 企业智能/16：40/9mins 面阿里就是用来自闭的。 开头 自我介绍 为什么面阿里 做过什么项目吗？ 问题 链表和数组的区别：数组：随机访问性强、查找速度快；插入和删除效率低，可能浪费内存，内存空间要求高，必须有足够的连续内存空间；数组大小固定，不能动态拓展。链表：插入删除速度快；内存利用率高，不会浪费内存；大小没有固定，拓展很灵活；不能随机查找，必须从第一个开始遍历，查找效率低。 环形链表的入口节点：确定是否有环，双指针一个走一步，一个走两步+环的个数计数；找到的入口：两个指针，一个先走n步，另外一个再走，两个指针相遇就是环的入口节点。(见：LeetCode141. Linked List Cycle 链表的中间节点：一个指针一次遍历两个节点，另一个节点一次遍历一个节点，当快指针遍历到空节点时，慢指针指向的位置为链表的中间位置，这种解决问题的方法称为快慢指针方法。(见：LeetCode876. Middle of the Linked List OSI模型七层结构：物理层、物理链路层、网络层、运输层、会话层、表示层、应用层。(见：Understanding the TCP/IP protocol suite 后记电面官：学生时代还是要把学校的课上好..（我自闭了QAQ）]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>B tree</tag>
        <tag>C++</tag>
        <tag>TCP/IP</tag>
        <tag>Linked List</tag>
        <tag>Linux</tag>
        <tag>Heap</tag>
        <tag>Operating System</tag>
        <tag>process</tag>
        <tag>quicksort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面经收录]]></title>
    <url>%2F2019%2F03%2F22%2F%E9%9D%A2%E7%BB%8F%E6%94%B6%E5%BD%95%2F</url>
    <content type="text"><![CDATA[《C/C++程序员面试宝典》 梁镇宇 清华大学出版社 C/C++ C++基础数据类型：整数型、浮点型、void型。 操作符优先级：从右至左结合的有三个：单目运算符、条件运算符、赋值运算符。 左值和右值：左值是一个地址，右值是一个地址存放的内容。右值不能放在赋值语句的左边。变量是左值，可以出现在赋值语句的左边。数字字面值是右值，不能被赋值。 变量初始化：复制初始化、直接初始化。如果变量在定义的时候没有被初始化，他的值是不确定的。直接初始化的执行效率更高，复制初始化要擦除对象的当前值并用新值代替。系统有时候会默认初始化变量。内置类型变量是否自动初始化取决于变量定义的位置。函数体外定义的变量都初始化为0，函数体内的内置类型变量不自动初始化，除了作为赋值操作符的左操作数，否则未初始化的变量没有意义。类自身定义了怎么初始化，构造函数，如果类中没有定义某个类中变量的初始化，使用默认构造函数。 声明和定义：extern:声明变量名但不定义它。不会分配存储空间，它说明变量定义在程序的其它地方，含有初始化的extern声明被当作是定义，变量可以声明多次，只能定义一次。 1extern int a; 操作系统 os：管理计算机的硬件资源，软件资源，数据资源，控制程序运行，提供操作接口，为其它应用软件提供支持等的软件系统。 根据任务的处理方式 简单批处理系统 多道程序批处理系统：利用了处理机的空闲时间。 多道程序分时系统：现代操作系统。一个作业只在一个时间片的时间内使用cpu，时间到就剥夺作业的cpu使用权，根据算法将cpu分给其它作业使用。Unix,Linux，DOS,Windows,Mac等。 网络操作系统：一台计算机通过一个网络接口控制器连接网络，进行网络通信功能，网络资源的管理和使用的操作系统。 操作系统的最小调度单位：线程。进程是操作系统中正在运行的一个应用程序，线程是系统分配处理器时间资源的基本单元。一个进程至少包括一个线程，通常称作主线程。 资源的最小单位是进程。进程由进程控制块、程序段、数据段三部分组成。使用线程可以实现应用程序同时做几件事互不干扰。线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源。线程与同属一个进程的其它线程共享进程所有的全部资源，一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。子进程和父进程有不同代码和数据空间，多个线程共享进程的数据空间，每个线程由自己的执行堆栈和程序计数器为其执行上下文。多线程主要为了利用CPU时间，同时在一个进程内运行多个任务。 进程和线程的区别： 一个程序至少由一个进程，一个进程至少有一个线程。 进程在执行过程中拥有独立的内存单元，多个线程共享进程所拥有的内存。 进程可以独立运行，线程不能独立执行，必须依存在进程中，使用该进程的应用程序提供多个线程执行控制。 任何实现多线程同步：多线程是为了使得线程并行地工作以完成多项任务，以提高系统的效率。 好处： 把占据长时间的程序中的任务作为一个单独的线程放到后台处理。用户界面可以继续响应用户的操作。 加快程序的处理速度。 在一些等待的任务实现上，如用户输入、文件读写、网络收发数据等，可以释放一些资源如内存占用等。 多线程同步：思想是避免多个线程对同一资源的访问，这个资源可以是一个对象、或者是一个方法、或者是一段代码。 实现方法： 临界区 互斥量 信号量 C/C++面试题实战 进程之间通信的途径： 共享存储系统 消息传递系统 管道：以文件系统为基础 进程死锁的原因：死锁是两个或多个并发进程中，如果每个进程持有某种资源而又等待别的进程释放他们保持的资源，否则不能向前推进。 根本原因是：系统能够提供的资源个数比要求该资源的进程数少，具体如下： 系统资源不足 进程推进顺序非法 死锁的4个必要条件： 互斥条件：一个资源每次只能被一个进程使用。 请求和保持条件:一个进程因请求资源而阻塞时，对以获得的资源保持不放。 不剥夺条件：进程已获得的资源，在没使用完之前，不能强行剥夺。 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。 死锁的处理： 鸵鸟算法忽略该问题。 检测死锁并恢复。 仔细地对资源进行动态分配，以避免死锁。 破环死锁产生的4个必要条件之一，防止死锁产生。 操作系统中进程调度策略： windows和linux的区别 FCFS先来先服务 优先级 时间片轮转 多级反馈 类的静态成员和非静态成员的区别 类的static成员在类被实例化前创建，类的静态成员每个类中只有一个，静态函数的实现里不能使用非静态成员。 纯虚函数怎么定义：此函数是一个接口，子类定义时必须实现该接口。 1virtual void f()=0; 数组和链表区别：数组大小固定，顺序存储。链表大小可变，随机存储。 ISO七层模型：物理层、物理链路层、网络层、运输层、会话层、表示层、应用层。 to be continued…]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 语言篇 constexpr]]></title>
    <url>%2F2019%2F03%2F22%2FC-%E8%AF%AD%E8%A8%80%E7%AF%87-constexpr%2F</url>
    <content type="text"><![CDATA[指定变量或函数的值能出现在常量表达式中[c++11] 细节 C++11 constexpr 函数使用递归而非迭代 constexpr 函数必须用条件运算符?:来抛异常，提示错误 constexpr声明的函数，必须把一切放在单条 return 语句中。 使用volatile的时候，不允许优化，只能在运行时计算。 ExampleDefinition of a C++11 constexpr function which computes factorials and a literal type that extends string literals: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;stdexcept&gt; // C++11 constexpr functions use recursion rather than iteration（C++11 constexpr 函数使用递归而非迭代）// (C++14 constexpr functions may use local variables and loops)（C++14 constexpr 函数可使用局部变量和循环）constexpr int factorial(int n)&#123; return n &lt;= 1 ? 1 : (n * factorial(n - 1));&#125; // literal classclass conststr &#123; const char* p; std::size_t sz;public: template&lt;std::size_t N&gt; constexpr conststr(const char(&amp;a)[N]): p(a), sz(N - 1) &#123;&#125; // constexpr functions signal errors by throwing exceptions // in C++11, they must do so from the conditional operator ?: // constexpr 函数通过抛异常来提示错误 // C++11 中，它们必须用条件运算符?:这么做 constexpr char operator[](std::size_t n) const &#123; return n &lt; sz ? p[n] : throw std::out_of_range(""); &#125; constexpr std::size_t size() const &#123; return sz; &#125;&#125;; // C++11 constexpr functions had to put everything in a single return statement.constexpr声明的函数，必须把一切放在单条 return 语句中。// (C++14 doesn't have that requirement)constexpr std::size_t countlower(conststr s, std::size_t n = 0, std::size_t c = 0)&#123; return n == s.size() ? c : 'a' &lt;= s[n] &amp;&amp; s[n] &lt;= 'z' ? countlower(s, n + 1, c + 1) : countlower(s, n + 1, c);&#125;//这个函数的功能是计算小写字母的数字。 // output function that requires a compile-time constant, for testingtemplate&lt;int n&gt;struct constN&#123; constN() &#123; std::cout &lt;&lt; n &lt;&lt; '\n'; &#125;&#125;; int main()&#123; std::cout &lt;&lt; "4! = " ; constN&lt;factorial(4)&gt; out1; // computed at compile time //在编译的时候已经计算好了constN&lt;24&gt; out1; volatile int k = 8; // disallow optimization using volatile std::cout &lt;&lt; k &lt;&lt; "! = " &lt;&lt; factorial(k) &lt;&lt; '\n'; // computed at run time //使用volatile的时候，不允许优化，只能在运行时计算。 std::cout &lt;&lt; "the number of lowercase letters in \"Hello, world!\" is "; constN&lt;countlower("Hello, world!")&gt; out2; // implicitly converted to conststr //"Hello, world!"隐式转换到conststr&#125; Output: 1234! = 248! = 40320the number of lowercase letters in "Hello, world!" is 9 to be continued…]]></content>
      <categories>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>constexpr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode179. Largest Number]]></title>
    <url>%2F2019%2F03%2F21%2FLeetCode179-Largest-Number%2F</url>
    <content type="text"><![CDATA[Given a list of non negative integers, arrange them such that they form the largest number. Example 1: 12Input: [10,2]Output: &quot;210&quot; Example 2: 12Input: [3,30,34,5,9]Output: &quot;9534330&quot; Note: The result may be very large, so you need to return a string instead of an integer. 思路std::sort + lambda 123456789101112131415class Solution &#123;public: string largestNumber(vector&lt;int&gt; &amp;num) &#123; vector&lt;string&gt; arr; for(auto i:num) arr.push_back(to_string(i)); sort(begin(arr), end(arr), [](string &amp;s1, string &amp;s2)&#123; return s1+s2&gt;s2+s1; &#125;); string res; for(auto s:arr) res+=s; while(res[0]=='0' &amp;&amp; res.length()&gt;1) res.erase(0,1); return res; &#125;&#125;; 1.将所有int转为string，放入容器中，to_string(int)。 2.用stl将容器中的string按照自定义的方法排序。这是一个很巧的解法。 12std::sort(begin(arr),end(arr), [](string &amp;s1,string &amp;s2)&#123;return s1+s2&gt;s2+s1;&#125;) 这是一个lambda表达式。它使得排序后的结果让前面遍历过的string连接起来永远是最大的。 用&gt;可以比较string的大小。两个字符串自左向右逐个字符相比（按ASCII值大小相比较），直到出现不同的字符或遇’\0’为止。 当两个数的位数一样，则直接可以应用字符串的比较。如 1"1346" &gt; "1111" == true 例子： 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string str1("235"); string str2("121"); bool result; result = str1 &gt; str2; cout&lt;&lt;result&lt;&lt;endl; // 1 str1 = "1111"; result = str1 &gt; str2; cout&lt;&lt;result&lt;&lt;endl; // 0 str1 = "111"; result = str1 &gt; str2; cout&lt;&lt;result&lt;&lt;endl; // 0 return 0;&#125; 3.将容器中排序好的string加起来。这里有一个细节，如果第一个数是0或者string的长度不为零，就将0去掉。 12while(res[0]=='0' &amp;&amp; res.length()&gt;1) res.erase(0,1); 复习一下std::vector::erase iterator erase( iterator pos );(C++11 前) iterator erase( const_iterator pos );(C++11 起) iterator erase( iterator first, iterator last );(C++11 前) iterator erase( const_iterator first, const_iterator last );(C++11 起) 1) 移除位于 pos 的元素。2) 移除范围 [first; last) 中的元素。 C++ code123456789101112131415161718192021222324class Solution &#123;public: string largestNumber(vector&lt;int&gt;&amp; nums) &#123; std::vector&lt;string&gt; a; for(auto const &amp; item:nums) &#123; a.push_back(to_string(item)); &#125; sort(a.begin(),a.end(),[](string &amp; a,string &amp;b)&#123;return a+b&gt;b+a;&#125;); string ret; for(auto const &amp; item:a) &#123; ret+=item; &#125; if(ret[0]=='0') return "0"; else return ret; &#125;&#125;; 改进：结果的第一个字符为0，直接返回”0”. 12if(ret[0]=='0') return "0"; 细节：ret[0]是一个char,而非string，所以用’’，否则报错。 总结1.本题考的是字符串排序的内容，要用到sort+lambda表达式。其中lambda表达式的写法是重点。 2.语法：to_string(int)。将int转string放入容器。 3.string 的大小比较用&gt;，返回bool值。 4.最后把容器中的值用+操作符重载，将字符串链接起来。 5.如果第一个字符是‘0’,就返回”0” 扩展如果要求最小的数，也用lambda函数。另外，用类来指定方法比class要更好。 12345678910111213141516171819202122232425class Solution &#123;public: string PrintMinNumber(vector&lt;int&gt; numbers) &#123; vector&lt;string&gt; a; for (auto const&amp; item : numbers) &#123; a.push_back(to_string(item)); &#125; sort(a.begin(), a.end(), MyCompare); string ret; for (auto const&amp; it : a) ret += it; if (ret[0] == '0') return "0"; return ret; &#125;private: static bool MyCompare(const string&amp;str1, const string &amp;str2) &#123; return str1 + str2 &lt; str2 + str1;//最小的数 &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Sort</tag>
        <tag>Array</tag>
        <tag>Permutations</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode400. Nth Digit]]></title>
    <url>%2F2019%2F03%2F20%2FLeetCode400-Nth-Digit%2F</url>
    <content type="text"><![CDATA[Find the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, … Note:n is positive and will fit within the range of a 32-bit signed integer (n &lt; 231). Example 1: 12345Input:3Output:3 Example 2: 12345678Input:11Output:0Explanation:The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10. 思路 计算n是几位数-记为digit 这里比较复杂。方法是从n里面减去[1,9]9个,[10,99]90*2个,[100,999]900*3个……这些区间所占数字总个数，得到的n是剩下的在digit位数中，所用掉的数字总数。 这些区间的基底是9，然后每次base都乘以10，再乘以digit位数，就得到前面范围的总数字数。可以把base*digit看作是底线，多出来的在digit进位后计算。 注意这里base要用long,否则会溢出。 123456while (n - base * digit &gt; 0) &#123; n -= base * digit; base *= 10; digit++; &#125; 找到n所在的数是多少-记为num n=10，nth=(1)/2=0,nth+base=10,他指的数是10,index=(1)%2=1 n=11，nth=(2)/2=1,nth+base=11,他值的数是10,index=(2)%2=0 n=12，nth=(3)/2=1,nth+base=11,他指的数是11,index=(3)%2=1 n=13，nth=(4)/2=2,nth+base=12,他所指的数是11，index=(4)%2=0 从两位数开始找规律，发现num的值和index有关，如果index==0时，num=nth+base-1;否则num=nth+base; 确定n在num中的位置，返回该位置的值 已知了index和num就可以把num转换为string来做这道题. 上一步中index==0，是上一个数的最后一位，所以让index=digit位。 int-&gt;string-&gt;char-&gt;int的步骤如下123string a = to_string(int);a = char;//char可以强制转换为string，a现在还是stringint b = stoi(a);//inline int stoi(const string&amp;) C++ code12345678910111213141516171819202122232425262728class Solution &#123;public: int findNthDigit(int n) &#123; //1.计算位数 int digit=1; long base=9; while(n-base*digit&gt;0) &#123; n-=base*digit; base*=10; digit++; &#125; //2.找到num int nth=n/digit; int index=n%digit; int num=0; num=pow(10,digit-1)+((index==0)?nth-1:nth); //3.转换字符串 if(index==0) index=digit;//很容易忘掉 string a=to_string(num); a=a[index-1]; return stoi(a); &#125;&#125;; 总结 难点是第一步，怎么求n所在的数字的位数，观察1位数，两位数，三位数后，发现前面数的总和是base*digit，并且base是以十为倍数，9为底倍增的。记下溢出的n就是在当前digit位数中数字的总量。 找规律，发现num跟nth还有index有关系，共同点是都要加pow(10,digit-1),不同点是index==0的时候，nth要减一，因为那是上一个数。 最后一步是字符串转化的问题，关键语法to_string(int),(string)char,stoi(const string&amp;)。 细节：base要用long，遇到迭代的倍增变量最好都用long.]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode233.Number of Digit One]]></title>
    <url>%2F2019%2F03%2F18%2FLeetCode233-Number-of-Digit-One%2F</url>
    <content type="text"><![CDATA[Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n. Example: Input: 13Output: 6Explanation: Digit 1 occurred in the following numbers: 1, 10, 11, 12, 13. 法一 - 按位参考leetcode官方解答。 1.个位数上的1： 每10个数内，出现一次1 如果个位数不为0，一定会出现一次1. n/10 + min(0,max(1,(n%10-1+1))) 2.十位上的1： 每100次，十位上出现10次1。 当十位数大于1，会出现10次1;如161x(x:[0,9]),+x+1次;16y0(y:[2,9])=+10次。所以只可能加0~10次。 设个位数为x，x = n%100-10 。而且x是大于等于0的，所以用max(0,x)，由于要加x+1次，所以用 max(0,x+1) n/100 * 10 + min(10, max(0 , （n%100-10） +1)) 3.百位上的1： 每1000次，百位上出现100次1. 如果百位上的数字大于了2，百位上出现了100次1（不超过100次） 如果百位数是1或者0，百位上会出现（n%1000 -100)+1次1.（不小于0次） n /1000 *100 + min(100, max(0,n%1000 -100 +1)) 如n=1234 个位的1：1234/101+min(1,4)=123\1+1=124 十位的1：1234/10010 + min(10,25)=12\10+10=130 百位的1：1234/1000100+min(100,（234-100)+1)=1\100+100=200 千位的1：1234/100001000+min(1000,(1234-1000)+1)=0\1000+235=235 总计：124+130+200+235=689 数学模型1n/(degree*10)*degree + min(degree,max(0,n\%(10*degree)-degree+1)) C++ code1234567891011class Solution &#123;public: int countDigitOne(int n) &#123; if(n&lt;=0) return 0; int ret=0; for(long long degree=1;degree&lt;=n;degree*=10) ret += n /(degree*10)*degree + min(degree, max((long long)0, n % (10 * degree) - degree+1)); return ret; &#125;&#125;; T:O(logn)S:O(1) 总结1.这种方法是计算个十百千万位上1出现的次数，找到不同位上1出现次数的规律，解得通用公式，一般是一个分段函数。再将所有位上的次数相加，就是最终结果。2.这道题容易错的地方是n/(degree10)degree不能写成n/10，因为可能n/(degree*10)的结果是0。3.用迭代防止栈溢出，还可以使O(1)。4.防止栈溢出，用long long来表示大数；同时开始ret要赋初值0，否则是一个很大的数；用中的max()时，要用(long long)强制转换。 法二 - 划分参考LC高票回答。 含1的数字 1的个数 数字范围 1 1 [1,9] 10 11 12 13 14 15 16 17 18 19 11 [10,19] 21 1 [20,29] 31 1 [30,39] 41 1 [40,49] 51 1 [50,59] 61 1 [60,69] 71 1 [70,79] 81 1 [80,89] 91 1 [90,99] 总计 11+1*9=20 [001,099] 100 101 102 103 104 105 106 107 108 109 11 [100,109] 110 111 112 113 114 115 116 117 118 119 21 [110,119] 120 121 122 123 124 125 126 127 128 129 11 [120,129] … … … 总计 21+11*9=120 [100,199] … 20 [200,299]=[0,99] … 20 [300,399]=[0,99] … … … … 20 [900,999]=[0,99] 总计 120+20*9=300 [001,999] 对于任意两位数，十位数上的数字+1就代表1出现的个数 当十位数大于等于2的时候(x+8)/10，要再加上多出来的10个1. 如：n=3141592,按个十百千万位来划分 当m=100时，a=31415,b=92;百位数1的前缀是””到”3141”.所以是3142次。 所以百位是1的时候，出现了 (a/10+1)*100 次。 当m=1000时，a=3141,b=592；千位数1的前缀是””到”314”，一共315次。 因为最后一个千位数是1，所以最后一次没有满1000次，而是”000”到”592”，一共593次。 所以千位是1的时候，出现了(a/10*1000)+(b+1)次 为了判断最后一位是否为1.用（a+8)/10来获取满载的次数，用a%10==1来判断是否需要添加额外的次数。 C++ code12345678910111213141516class Solution &#123;public:int countDigitOne(int n) &#123; if(n&lt;=0) return 0; int ret=0; for(long long degree=1;degree&lt;=n;degree*=10) &#123; long long a = n/degree; long long b = n%degree; ret+=(a+8)/10 *degree//满载 +(a%10==1)*(b+1);//a的最后一位为1，会加剩下的余数+1 &#125; return ret;&#125;&#125;; 总结1.这种方法的思想是把大范围的数划分为小范围的数来计算。2.前缀的最后一位如果大于等于2就进满载，即(a+8)/10*degree。如果题目问的是3出现的大小，就大于等于4进满载(a+4)/10*degree。3.判断最后一位是不是1(a%10==1)，如果是1就要加(剩下的余数+1),加1是尾号为000的时候。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用C++写的一个吃豆人的小游戏]]></title>
    <url>%2F2019%2F03%2F17%2Fpacman%2F</url>
    <content type="text"><![CDATA[刷题太自闭了，不如做个小游戏减减压吧。下午摸鱼看了个视频，用c++做了一个小游戏，吃豆人。主要收获是学了一点点OOP+数学+数据结构+操作系统。游戏思路如下。 消息队列每一个窗口程序有一个消息队列,系统把消息放到队列里面,设置一个循环来翻译队列中的消息.然后分发这个消息. 12345678910// 主消息循环: //while (GetMessage(&amp;msg, nullptr, 0, 0))//如果没有消息,就阻塞在这里,不会返回. while (PeekMessage(&amp;msg, nullptr, 0, 0,PM_REMOVE))&#123; //修改后即使没有消息.也不会阻塞. if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg))&#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; &#125; GDI画点12345678910HWND g_hWnd = nullptr;//定义一个全局变量int APIENTRY wWinMain(_In_ HINSTANCE hInstance,_In_opt_ HINSTANCE hPrevInstance,_In_ LPWSTR lpCmdLine,_In_ int nCmdShow)&#123;HDC hdc = ::GetDC(g_hWnd);//传入全局变量的句柄int x = rand()%WLENGTH ; //[0,WLENGTH)int y = rand()%HLENGTH ; //[0,HLENGTH)SetPixel(hdc, x, y, RGB(rand()%255, rand() % 255, rand() % 255));::DeleteDC(hdc);//释放hdc &#125; 画线12345678910111213HDC hdc = ::GetDC(g_hWnd);HPEN hPen = CreatePen(PS_SOLID, 3, RGB(rand()%255, rand() % 255, rand() % 255));//新画笔HPEN hOldPen = (HPEN)SelectObject(hdc, hPen);//选中画笔int x = rand() % WLENGTH;int y = rand() % HLENGTH;int xx = rand() % WLENGTH;int yy = rand() % HLENGTH;MoveToEx(hdc, x, y, nullptr);LineTo(hdc, xx, yy);SelectObject(hdc, hOldPen);//恢复老画笔DeleteObject(hPen);//删除画笔ReleaseDC(g_hWnd, hdc);Sleep(1);//使当前线程暂停1s 画矩形123456789101112131415161718HDC hdc = ::GetDC(g_hWnd);//空心矩形。 HPEN hPen = CreatePen(PS_SOLID, 2, RGB(255, 0, 0));HPEN holdPen = (HPEN)SelectObject(hdc, hPen);Rectangle(hdc, 100, 200, 300, 500);//左上角和右下角坐标。(100,200),(300,500)SelectObject(hdc, holdPen);DeleteObject(hPen);//实心矩形HBRUSH hBrush = CreateSolidBrush(RGB(0, 0, 255));RECT rect;rect.left = 50;rect.right = 150;rect.top = 270;rect.bottom = 370;FillRect(hdc, &amp;rect, hBrush);DeleteObject(hBrush); ReleaseDC(g_hWnd, hdc); 画弧12345678910111213141516HDC hdc = ::GetDC(g_hWnd); HPEN hPen = CreatePen(PS_SOLID, 2, RGB(255, 0, 0));HPEN holdPen = (HPEN)SelectObject(hdc, hPen);//圆。左上右下 Ellipse(hdc, 200, 150, 300, 250);//椭圆。左上右下Ellipse(hdc, 200, 170, 300, 250);//弧形Arc(hdc,100, 100, 300, 250,//矩形200,150,//起始点200,200//终点);SelectObject(hdc, holdPen);DeleteObject(hPen); ReleaseDC(g_hWnd, hdc); 画玩家123456789101112//闭嘴void Draw0() &#123;int x = 300, y = 300;//中心点int r = 100;//圆的半径HDC hdc = ::GetDC(g_hWnd);//人脸Ellipse(hdc, x - r, y - r, x + r, y + r);//嘴巴MoveToEx(hdc, x, y, nullptr);LineTo(hdc, x - r, y);ReleaseDC(g_hWnd,hdc);&#125; 123456789101112131415161718192021222324#define PI 3.1415926f//半张嘴void Draw1() &#123; int x = 300, y = 300;//中心点 int r = 100;//圆的半径 HDC hdc = ::GetDC(g_hWnd); //脸 int x0, y0; int x1, y1; x0 = x + (r*sin(PI*1.25f)); y0 = y - (r*cos(PI*1.25f)); x1 = x - (r*sin(PI*0.75f)); y1 = y + (r*cos(PI*0.75f)); Arc(hdc, x-r, y-r, x+r, y+r,//矩形 x0, y0,//起始点 x1, y1);//终点 //嘴巴 MoveToEx(hdc, x0, y0, nullptr); LineTo(hdc, x, y); MoveToEx(hdc, x1, y1, nullptr); LineTo(hdc, x, y); ReleaseDC(g_hWnd, hdc);&#125; 12345678910111213//全张嘴。半圆+竖线void Draw2() &#123; int x = 300, y = 300;//中心点 int r = 100;//圆的半径 HDC hdc = ::GetDC(g_hWnd); Arc(hdc, x - r, y - r, x + r, y + r, x, y + r, x, y - r); MoveToEx(hdc,x, y - r, nullptr); LineTo(hdc, x, y + r); ReleaseDC(g_hWnd, hdc);&#125; 动画123456789101112131415161718192021222324252627282930313233//画玩家//控制时间static DWORD dwTime = GetTickCount();if (GetTickCount() - dwTime &gt;= 40) dwTime = GetTickCount();//更新时间 else continue;//跳出 //清除上一次画布HDC hdc = GetDC(g_hWnd);RECT rc;GetClientRect(g_hWnd,&amp;rc);//rc获得窗口大小HBRUSH hbr = CreateSolidBrush(RGB(255, 255, 255));FillRect(hdc, &amp;rc, hbr);//窗口刷白DeleteObject(hbr);ReleaseDC(g_hWnd, hdc);//0：闭嘴//1.半张//2.全张//3.半张//4.闭嘴static int iFrame = 0;//设置一个静态变量来循环播放iFrame++;if (iFrame &gt;= 5) iFrame = 0;switch (iFrame)&#123; case 0: Draw0();break; case 1: Draw1();break; case 2: Draw2();break; case 3: Draw1();break; case 4: Draw0();break;&#125; 地图类抽象类地图的设计12345678910111213141516171819202122232425262728//抽象类地图，三关类的父类class GMap&#123; //保护类:子类可以访问到，通用变量protected: static int LD;//障碍物尺寸 static int PD;//豆子半径 void InitOp();//初始化玩家和敌人 bool mapData[MAPLENTH][MAPLENTH];//地图数据 bool peaMapData[MAPLENTH][MAPLENTH];//豆子数据 COLORREF color;//地图颜色public: void DrawMap(HDC &amp;hdc);//绘制地图 void DrawPeas(HDC &amp;hdc);//绘制豆子 GMap() &#123;&#125;; virtual ~GMap(); //为了让玩家类和敌人类可以访问到地图类，声明友元 friend class GObject; friend class PacMan;&#125;;//继承class Stage_1 :public GMap &#123;private: bool static initData[MAPLENTH][MAPLENTH];//初始化地图public: Stage_1();//构造函数&#125;; 抽象类地图的实现123456789101112131415161718192021222324252627282930313233343536373839int GMap::LD = 36;//墙宽int GMap::PD = 3;//豆子的半径void GMap::InitOp()//初始化敌人和玩家的位置没有豆子&#123; peaMapData[E_ROW][E_COLUMS] = false; peaMapData[P_ROW][P_COLUMS] = false;&#125;void GMap::DrawMap(HDC &amp;memDC)&#123;HBRUSH hBrush = CreateSolidBrush(color);for (int i = 0; i &lt; MAPLENTH; i++) &#123;for (int j = 0; j &lt; MAPLENTH; j++) &#123;//绘制墙壁,x对应列,y对应行if (!mapData[i][j]) &#123;RECT rect;rect.left = j * LD;rect.top = i * LD;rect.right = (j + 1) * LD;rect.bottom = (i + 1) * LD;FillRect(memDC, &amp;rect, hBrush);&#125;&#125;&#125;DeleteObject(hBrush);&#125;void GMap::DrawPeas(HDC &amp;hdc)&#123; for (int i = 0; i &lt; MAPLENTH; i++)&#123;for (int j = 0; j &lt; MAPLENTH; j++)&#123;if (mapData[i][j]) &#123;//画豆子,把豆子放在一个矩形里面Ellipse(hdc,(LD / 2 - PD) + j*LD,//left(LD / 2 - PD) + i*LD,//top(LD / 2 + PD) + j*LD,//right(LD / 2 + PD) + i*LD);&#125;&#125;&#125;&#125;//bottomGMap::~GMap()&#123;&#125;//初始化地图#define A true#define B falsebool Stage_1::initData[MAPLENTH][MAPLENTH] = &#123;.....&#125;;#undef A#undef B//取消宏定义，防止歧义 可移动对象类的设计 基类GObject的部分变量 123456789101112131415public:static GMap *pStage; //指向地图类的指针,设置为静态,使所有自类对象都能够使用相同的地图void DrawBlank(HDC &amp;hdc);// 画空白protected://想让玩家类和敌人类访问这些数据//祯数int m_nFrame;//判断物体是否到达逻辑坐标位置bool Achive();//逻辑碰撞检测,将物体摆放到合理的位置bool Collision();//将实际坐标转换为逻辑坐标int PtTransform(int k) //到达逻辑点后更新数据virtual void AchiveCtrl(); 敌军对象 123456789101112131415161718class Enemy : public GObject&#123;protected: void Catch();//是否抓住玩家 void virtual MakeDecision(bool b) = 0; //确定方向.AI实现.三种敌人重写 COLORREF color;public: static std::shared_ptr&lt;PacMan&gt; player;//智能指针，指向玩家，静态变量 void virtual Draw(HDC &amp;hdc);//绘制自己 Enemy(int x, int y) : GObject(x, y)//构造函数 &#123; this-&gt;m_nSpeed = ENERMYSPEED;//设置速度 m_dir = LEFT;//设置朝向 m_cmd = UP;//设置移动方向 &#125; void virtual action();//要重写的动作&#125;; class RedOne : public Enemy //随机移动 class BlueOne : public RedOne //守卫者 class YellowOne : public RedOne //扰乱者 玩家对象 123456789101112131415161718class PacMan : public GObject&#123;protected: virtual void AchiveCtrl();//重写虚函数public: POINT GetPos();//获取位置 bool IsOver();//游戏是否结束 bool IsWin();//玩家是否赢得游戏 void Draw(HDC &amp;hdc);//绘制自己 void SetTwCommand(TWARDS command);//设置玩家下一步指令 PacMan(int x, int y) : GObject(x, y)//构造函数 &#123; this-&gt;m_nSpeed = PLAYERSPEED;//玩家速度 m_cmd = m_dir = LEFT;//设置方向 &#125; void action();//动作重写 void SetOver();//设置游戏结束函数&#125;; 可移动对象的实现123456789101112131415161718192021//将实际坐标转换为逻辑坐标int GObject::PtTransform(int k)&#123; return (k - (pStage-&gt;LD) / 2) / pStage-&gt;LD;&#125;//判断物体是否到达逻辑坐标位置bool GObject::Achive()&#123; int n = (m_ptCenter.x - pStage-&gt;LD / 2) % pStage-&gt;LD; // 计算x坐标的余数 int k = (m_ptCenter.y - pStage-&gt;LD / 2) % pStage-&gt;LD; // 计算y坐标的余数 bool l = (n == 0 &amp;&amp; k == 0); // 如果两个余数都为0,说明到达中心位置 return l;&#125;//到达逻辑点后更新数据void GObject::AchiveCtrl()&#123; if (Achive()) &#123; m_nArray = PtTransform(m_ptCenter.x); //更新列 m_nRow = PtTransform(m_ptCenter.y); //更新行 &#125;&#125; 将上一帧的图像清除,画这一帧的图像.1234567891011121314151617void GObject::DrawBlank(HDC &amp;hdc)&#123; // 申请资源,并交给智能指针处理 HBRUSH hbr = ::CreateSolidBrush(RGB(255, 255, 255)); //创建画刷，绘制矩形函数要求使用 std::shared_ptr&lt;HBRUSH&gt; phbr(&amp;hbr, [](auto hbr) &#123; //把资源交给智能指针处理，自动释放 // 离开 DrawBlank函数时,会自动调用释放资源 DeleteObject(*hbr); &#125;); RECT rect; rect.top = m_nY - RD; rect.left = m_nX - RD; rect.right = m_nX + RD; rect.bottom = m_nY + RD; FillRect(hdc, &amp;rect, *phbr);//绘制空白矩形&#125; 碰撞检测1234567891011121314151617181920212223242526272829303132333435363738394041424344bool GObject::Collision()&#123; bool b = false; //执行重写的AchiveCtrl函数消除豆子 AchiveCtrl(); //判断指令的有效性 if (m_nArray &lt; 0 || m_nRow &lt; 0 || m_nArray &gt; MAPLENTH - 1|| m_nRow &gt; MAPLENTH - 1) b = true; else if (Achive()) &#123; switch (m_cmd) &#123;//判断行进的方向 case LEFT://判断下一个格子是否能够通行 if (m_nArray &gt; 0 &amp;&amp; !pStage-&gt;mapData[m_nRow][m_nArray - 1]) &#123; b = true;//指令无效 &#125;break; //以下方向的判断原理相同 case RIGHT: ... case UP: ... case DOWN: ...&#125; if (!b) m_dir = m_cmd; //没撞墙,指令成功 &#125; //依照真实的方向位移 m_nX = m_ptCenter.x; m_nY = m_ptCenter.y; int MAX = pStage-&gt;LD * MAPLENTH + pStage-&gt;LD / 2; int MIN = pStage-&gt;LD / 2; switch (m_dir) &#123; //判断行进的方向 case LEFT://判断下一个格子是否能够通行 if (m_nArray &gt; 0 &amp;&amp; !pStage-&gt;mapData[m_nRow][m_nArray - 1]) &#123; b = true; break;&#125;//碰撞了 m_ptCenter.x -= m_nSpeed;//向左位移 if (m_ptCenter.x &lt; MIN) m_ptCenter.x = MAX;//穿墙 break; //以下方向的判断原理相同 case RIGHT: ... case UP: ... case DOWN: ... &#125; return b;&#125; 敌军对象 123456789// 抓住，游戏结束void Enermy::Catch()&#123; int DX = m_ptCenter.x - player-&gt;GetPos().x; int DY = m_ptCenter.y - player-&gt;GetPos().y; if ((-RD &lt; DX &amp;&amp; DX &lt; RD) &amp;&amp; (-RD &lt; DY &amp;&amp; DY &lt; RD)) &#123; player-&gt;SetOver(); &#125;&#125; 敌军对象绘制 1234567891011121314151617181920212223242526void Enermy::Draw(HDC &amp;hdc)&#123; HPEN pen = ::CreatePen(0, 0, color); HPEN oldPen = (HPEN)SelectObject(hdc, pen); //绘制半圆型的头 //根据祯数来绘制身体和“腿部” if (m_nFrame % 2 == 0) &#123; //矩形的身子 //从左往右绘制“腿部” &#125; else &#123; //绘制身体 //从左往右绘制“腿部” &#125; //根据方向绘制眼睛 switch (m_dir) &#123; case UP: case DOWN: case LEFT: case RIGHT: &#125; m_nFrame++; //准备绘制下一祯 SelectObject(hdc, oldPen);//还原画笔 DeleteObject(pen);//删除画笔对象 return;&#125; 敌军对象的行为123456void Enermy::action()&#123; bool b = Collision();//碰撞检测 MakeDecision(b);//设定方向 Catch();//开始捕捉&#125; 游戏主体逻辑12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 玩家对象,智能指针// 自己 auto g_me = std::make_shared&lt;PacMan&gt;(P_ROW, P_COLUMS);// 设定四个敌人对象auto e1 = std::make_shared&lt;RedOne&gt;(E_ROW, E_COLUMS);auto e2 = std::make_shared&lt;RedOne&gt;(E_ROW, E_COLUMS);auto e3 = std::make_shared&lt;BlueOne&gt;(E_ROW, E_COLUMS);auto e4 = std::make_shared&lt;YellowOne&gt;(E_ROW, E_COLUMS);//静态变量，初始化为第一关地图GObject::pStage = MapArray[s_n]; //引用静态成员变量// 设定玩家Enermy::player = g_me; // 主消息循环:// 玩家没有被抓,并且关卡&lt;3while (!g_me-&gt;IsOver() &amp;&amp; s_n &lt; STAGE_COUNT) &#123;// 判断是否赢得比赛if (g_me-&gt;IsWin()) &#123;s_n++;// 重设自己和敌人位置 // 判断是否完成了3关,如果完成,退出游戏,否则进入下一关if (s_n &lt; 3) &#123; continue;&#125;// 继续进行循环else break;&#125;// 跳出循环// 获取消息if (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) &#123;TranslateMessage(&amp;msg);DispatchMessage(&amp;msg);&#125;// 判断时间,否则画得太快，敌人一下就把我们抓住了就游戏结束了if (GetTickCount() - dwLastTime &gt;= 40) &#123;dwLastTime = GetTickCount();&#125;else &#123;// 时间不到,本次不进行绘画continue;&#125;// 获得设备HDC hdc = ::GetDC(g_hwnd);// 不使用时自动释放std::shared_ptr&lt;HDC__&gt; dc(hdc, [](auto hdc) &#123;::ReleaseDC(g_hwnd, hdc);&#125;);// 画豆子MapArray[s_n]-&gt;DrawPeas(hdc);// 画地图MapArray[s_n]-&gt;DrawMap(hdc);// 画敌人及自动运动 // 画自己 // 自己向前移动 // 获取按键 : 控制自己的方向 // 如果游戏结束if (g_me-&gt;IsOver()) &#123;... &#125;// 否则,提示赢得游戏else &#123; ...&#125; 金手指1234567891011//快速通关if (GetAsyncKeyState('B') &amp; 0x8000)&#123; for (int i = 0; i &lt; MAPLENTH; i++) &#123; for (int j = 0; j &lt; MAPLENTH; j++) &#123; peaMapData[i][j] = false; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Projects</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Game</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode172. Factorial Trailing Zeroes]]></title>
    <url>%2F2019%2F03%2F15%2FLeetCode172-Factorial-Trailing-Zeroes%2F</url>
    <content type="text"><![CDATA[Given an integer n, return the number of trailing zeroes in n!. Example 1: 123Input: 3Output: 0Explanation: 3! = 6, no trailing zero. Example 2: 123Input: 5Output: 1Explanation: 5! = 120, one trailing zero. Note: Your solution should be in logarithmic time complexity. The idea is: The ZERO comes from 10. The 10 comes from 2 x 5 And we need to account for all the products of 5 and 2. likes 4×5 = 20 … So, if we take all the numbers with 5 as a factor, we’ll have way more than enough even numbers to pair with them to get factors of 10 Example OneHow many multiples of 5 are between 1 and 23? There is 5, 10, 15, and 20, for four multiples of 5. Paired with 2’s from the even factors, this makes for four factors of 10, so: 23! has 4 zeros. Example TwoHow many multiples of 5 are there in the numbers from 1 to 100? because 100 ÷ 5 = 20, so, there are twenty multiples of 5 between 1 and 100. but wait, actually 25 is 5×5, so each multiple of 25 has an extra factor of 5, e.g. 25 × 4 = 100，which introduces extra of zero. So, we need know how many multiples of 25 are between 1 and 100? Since 100 ÷ 25 = 4, there are four multiples of 25 between 1 and 100. Finally, we get 20 + 4 = 24 trailing zeroes in 100! The above example tell us, we need care about 5, 5×5, 5×5×5, 5×5×5×5 …. Example ThreeBy given number 4617. 5^1 : 4617 ÷ 5 = 923.4, so we get 923 factors of 5 5^2 : 4617 ÷ 25 = 184.68, so we get 184 additional factors of 5 5^3 : 4617 ÷ 125 = 36.936, so we get 36 additional factors of 5 5^4 : 4617 ÷ 625 = 7.3872, so we get 7 additional factors of 5 5^5 : 4617 ÷ 3125 = 1.47744, so we get 1 more factor of 5 5^6 : 4617 ÷ 15625 = 0.295488, which is less than 1, so stop here. Then 4617! has 923 + 184 + 36 + 7 + 1 = 1151 trailing zeroes. C/C++ code1123456789101112class Solution &#123;public: int trailingZeroes(int n) &#123; int sum=0; while(n&gt;0)&#123; sum+=n/5; n/=5; &#125; return sum; &#125;&#125;;&#125; C/C++ code2123456class Solution &#123;public: int trailingZeroes(int n) &#123; return n==0?0:n/5+trailingZeroes(n/5); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode53. Maximum Subarray]]></title>
    <url>%2F2019%2F03%2F15%2FLeetCode53-Maximum-Subarray%2F</url>
    <content type="text"><![CDATA[Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: 123Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum = 6. Follow up:If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. Optimization problem -DP the format of the sub problem(or the state of each sub problem). recursive 1maxSubArray(A, i) = maxSubArray(A, i - 1) &gt; 0 ? maxSubArray(A, i - 1) : 0 + A[i]; 动态规划用循环做。F(i)=numsi&lt;=0);F(i)=nums[i]+F(i-1)(F(i-1)&gt;0) 细节nums只有{-1}时，所以开始sum=nums[0]，然后从第二个开始循环。 12345678910111213141516171819202122232425class Solution &#123;public: int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123; if(array.empty()) return 0; int cur=array[0]; int max=cur; for(auto it = array.begin()+1;it!=array.end();it++) &#123; if(cur&lt;=0) &#123; cur = *it; &#125; else &#123; cur+=*it; &#125; if(cur&gt;max) &#123; max=cur; &#125; &#125; return max; &#125;&#125;; Divide-and-Conquer The Divide-and-Conquer algorithm breaks nums into two halves and find the maximum subarray sum in them recursively. the maximum subarray spans the two halves. a linear algorithm: starting from the middle element and move to both ends (left and right ends), record the maximum sum we have seen. In this case, the maximum sum is finally equal to the middle element plus the maximum sum of moving leftwards and the maximum sum of moving rightwards. Since we are done with LHS and RHS, we only need to check the case where we pass the middle element.(i.e. the middle element must be included).In that case, since our question asks a continuous subset, it must expand that way. 分治法2*O(n/2)+O(1)=O(n) divide：用递归来分别求左右子集的max merge:用dp来从左右分别线性探索，加上mid 最后找到divide和merge中最大的就是要求的值。12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; return maxSubArray(nums, 0, nums.size() - 1); &#125;private: int maxSubArray(vector&lt;int&gt;&amp; nums, int l, int r) &#123; if (l &gt; r) &#123; return INT_MIN; &#125; //divide: int m = l + (r - l) / 2; int lmax = maxSubArray(nums, l, m - 1);//left int rmax = maxSubArray(nums, m + 1, r);//right int partmax = max(lmax, rmax);//not including mid //Merge: int ml= 0,mr = 0; //left-DP:O(n/2) for (int i = m - 1, sum = 0; i &gt;= l; i--) &#123; sum += nums[i]; ml = max(sum, ml); &#125; //right-DP:O(n/2) for (int i = m + 1, sum = 0; i &lt;= r; i++) &#123; sum += nums[i]; mr = max(sum, mr); &#125; //Merge-including mid,for continuous subset:O(1) int contmax=ml + mr + nums[m]; return max(partmax,contmax); //2*O(n/2)+O(1)=O(n) &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Optimization problem</tag>
        <tag>Divide and Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kadane's Algorithm]]></title>
    <url>%2F2019%2F03%2F15%2FKadane-s-Algorithm%2F</url>
    <content type="text"><![CDATA[Kadane’s algorithm Aka Maximum Sum of Subarray Dynamic Programming Maximum Subarray ProblemFrom Wikipedia In computer science, the maximum subarray problem is the task of finding the contiguous subarray within a one-dimensional array, a[1…n], of numbers which has the largest sum. The task is to find a subarray (contiguous elements) of the given array that has the largest sum. For instance: 1[1, 5, -1, 0, 10] The answer would be 15 or the entire array (it’s also a subarray) 1[0, -1, -5, 0, -4] The answer would be 0 and so on. SolutionsBrute-forceAll you need is going through all sub-arrays, keep the global maximum and compare. Dynamic Programming (Kadane’s Algorithm) O(n) runtime complexity O(1) space. Following function shows the Kadane’s algorithm implementation which uses two variables, one to store the local maximum and the other to keep track of the global maximum: 123456def max_subarray(A): max_ending_here = max_so_far = A[0] for x in A[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far So we assume that the largest subarray is the first element, then we go through A[1:] elements (all elements except the first one). At each step, what we do is: Can current element plus the last largest sum_ help to find a largest subarray (line 4)? If yes, update the max_ending_here or our local maximum, otherwise current element is the largest subarray (array of one). Then update the global maximum or max_so_far if there is a new global maximum. When the loop is over, return the global maximum. ConclusionKadane’s algorithm is a Dynamic Programming approach to solve “the largest contiguous elements in an array” with runtime of O(n).]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 语言篇 CV(const and volatile) Type Qualifiers]]></title>
    <url>%2F2019%2F03%2F14%2FC-%E8%AF%AD%E8%A8%80%E7%AF%87-cv-const-and-volatile-type-qualifiers%2F</url>
    <content type="text"><![CDATA[cv (const and volatile) type qualifiers const - defines that the type is constant. volatile - defines that the type is volatile. const1234567891011121314151617class complex&#123;public: complex (double r = 0, double i = 0): re (r), im (i) &#123; &#125; complex&amp; operator += (const complex&amp;); complex&amp; operator -= (const complex&amp;); complex&amp; operator *= (const complex&amp;); complex&amp; operator /= (const complex&amp;); double real () const &#123; return re; &#125; double imag () const &#123; return im; &#125;private: double re, im; friend complex&amp; __doapl (complex *, const complex&amp;); friend complex&amp; __doami (complex *, const complex&amp;); friend complex&amp; __doaml (complex *, const complex&amp;);&#125;; 只有member fun后面可以用 const定义。成员变量后面不可以写const，写在前面。 const obj 如果调用 non-const member fun会编译出错。 错误：如果定义时没有写成void print() const{}; 就会报错。因为str是const-obj，不能用non-const member fun调用。 例子：STD里的操作符重载来自 TEMPLATE CLASS basic_string的定义。string类的operator[]。 用户可能拿[]来改变字符串。如String str[5]=”a”;由于string的实现机制是共享模式，不可以直接改变内部内容。只能拷贝一份再改变。所以要做cow(copy on write)设计。 如果const String str[2];str是const obj，其内部不可以动。所以不必考虑cow。const obj只会调用const fun，所以const fun不必写cow。 12345678910111213reference operator[](size_type _Off)&#123; // 下标可变序列 // 必须考虑cow return (this-&gt;_Myptr()[_Off]);&#125;const_reference operator[](size_type _Off) const&#123; // 下标不可变序列 // 不必考虑cow return (this-&gt;_Myptr()[_Off]);&#125; 可见const属于签名的一部分，这两个函数可以重载。 C++规定：如果类中有成员函数的const fun 和nonconst fun同时存在，则const obj默认调用const fun，non-const obj默认调用non-const fun。 C++规定：non-const fun（obj可变）可以调用const fun（obj不可变）。 反过来报错。 例子：《cpp primer》15节 -基类的定义1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Quote &#123; /* ** istream&amp;：必须是非常量，因为本操作就是向流读出数据，其状态会改变； ** Quote&amp; ：必须是非常量，因为本操作就是向此对象写入数据，此对象值会改变； */ friend istream&amp; operator&gt;&gt;(istream&amp;, Quote&amp;); /* **ostream&amp; ：必须是非常量，因为本操作就是向流写入数据，其状态会改变； **const Quote&amp; ：引用是因为避免赋值实参；常量是因为通常打印对象不会改变对象本身的值； */ friend ostream&amp; operator&lt;&lt;(ostream&amp;, const Quote&amp;); public: /*这种传递中的代码使用以下变量来控制编译； **变量：IN_CLASS_INITS/DEFAULT_FCNS；对应C++作用：类初始状态设置/default(默认)； */#if defined(IN_CLASS_INITS) &amp;&amp; defined(DEFAULT_FCNS) //若定义类初始值设置及默认值，则定义默认构造函数,不接受任何实参； Quote() = default; #else /*若未定义类初始值及默认值，则定义构造函数，函数体空； **构造函数初始列表为新创建的数据成员price初始化，对应初始化值为 0.0； */ Quote() : price(0.0) &#123; &#125;#endif // !defined(IN_CLASS_INITS) &amp;&amp; defined(DEFAULT_FCNS) //初始化构造函数 Quote(const string &amp;book,double sales_price): bookNo(book),price(sales_price)&#123; &#125; //虚析构函数，动态绑定#ifdef DEFAULT_FCNS virtual ~Quote() = default;#else virtual ~Quote() &#123; &#125;#endif // DEFAULT_FCNS //const fun。 因为bookNo被期望是const obj，所以只能被const fun调用，必须定义为const fun，否则报错。 string isbn() const &#123; return bookNo; &#125; //虚函数。将在派生类中重写，根据书的数量，采取不同的折扣算法。 //因为price（定价）也是const obj,不会被改。所以定义为const fun。 virtual double net_price(size_t n) const &#123; return n*price; &#125;//虚函数返回动态分配的自身副本private: const string bookNo;//书号，被期望是const objprotected:#ifndef IN_CLASS_INITS const double price = 0.0;#else const double price;#endif // !IN_CLASS_INITS&#125;; mutableMay appear in the declaration of a [non-static [class members] of non-reference non-const] type: 1234class X &#123; mutable const int* p; // OK mutable int* const q; // ill-formed&#125;; Mutable is used to specify that the member does not affect the externally visible state of the class (as often used for [mutexes, memo caches, lazy evaluation, and access instrumentation]). 12345678910111213class ThreadsafeCounter &#123; mutable std::mutex m; // The "M&amp;M rule": mutable and mutex go together int data = 0; public: int get() const &#123; std::lock_guard&lt;std::mutex&gt; lk(m); return data; &#125; void inc() &#123; std::lock_guard&lt;std::mutex&gt; lk(m); ++data; &#125;&#125;;]]></content>
      <categories>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>const</tag>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode295.Find Median from Data Stream]]></title>
    <url>%2F2019%2F03%2F14%2FLeetCode295-Find-Median-from-Data-Stream%2F</url>
    <content type="text"><![CDATA[Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. For example,[2,3,4], the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5 Design a data structure that supports the following two operations: void addNum(int num) - Add a integer number from the data stream to the data structure.double findMedian() - Return the median of all elements so far. Example: addNum(1)addNum(2)findMedian() -&gt; 1.5addNum(3)findMedian() -&gt; 2 Follow up: If all integer numbers from the stream are between 0 and 100, how would you optimize it?If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it? 法一开两个stl的优先队列-maxheap。small放前一半大的数，large放后一半大的数。为了让他们的顺序从小到大不变，small的用原数存，large的用负数存。增删O(logn)，查找O(1)细节：1.如果是奇数大小，small.top()就是要求的中位数。如果是偶数，(small.top()-large.top())/2就是中位数，是减不是加2.优先队列的类型是long. -2^31 (which negated is itself, when using 32-bit ints), I use integer types larger than 32 bits.3.(small.top()-large.top())/2.0。要除以2.0，否则返回的是整数 12345678910111213141516171819202122232425262728293031323334class MedianFinder &#123;private: std::priority_queue&lt;long&gt; small,large; public: /** initialize your data structure here. */ MedianFinder() &#123; &#125; void addNum(int num) &#123; small.push(num);//O(logn) large.push(-small.top());//O(logn) small.pop();//O(logn) //保证small大于或者等于large的个数 if(small.size()&lt;large.size()) &#123; small.push(-large.top()); large.pop(); &#125; &#125; double findMedian() &#123; return small.size()&gt;large.size()? small.top():(small.top()-large.top())/2.0; &#125;&#125;;/** * Your MedianFinder object will be instantiated and called as such: * MedianFinder obj = new MedianFinder(); * obj.addNum(num); * double param_2 = obj.findMedian(); */ 法二开两个stl的优先队列-maxheap和minheap，用来存前后一半的数细节：1.如果num小于maxheap.top(),说明在num小的那一半里，放入最大堆，如果不这样的话，可能会排序失败。2.假定maxheap永远大于或者等于minheap的数量，这样如果两个堆相等就是平均值。不相等就是maxheap.top3.利用AVL的思想，保证两个堆的深度之差不超过1，如果超过1,就把max堆顶放入min堆中 1234567891011121314151617181920212223242526272829303132333435class MedianFinder &#123;private: priority_queue&lt;long&gt; maxheap; priority_queue&lt;long, vector&lt;long&gt;, greater&lt;long&gt;&gt; minheap;public: /** initialize your data structure here. */ MedianFinder() &#123; &#125; void addNum(int num) &#123; //细节：如果num小于maxheap.top(),说明在num小的那一半里，放入最大堆，如果不这样的话，可能会排序失败。 if (maxheap.size() == 0 || num &lt; maxheap.top()) &#123; maxheap.push(num); &#125; else minheap.push(num); //平衡二叉树 if (minheap.size()&gt; maxheap.size()) &#123; maxheap.push(minheap.top()); minheap.pop(); &#125; else if (maxheap.size()&gt;1 + minheap.size()) &#123; minheap.push(maxheap.top()); maxheap.pop(); &#125; &#125; double findMedian() &#123; return maxheap.size()&gt;minheap.size() ? maxheap.top() : (maxheap.top() + minheap.top()) / 2.0; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>AVL</tag>
        <tag>priority_queue</tag>
        <tag>Heapsort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 算法篇 std::nth_element]]></title>
    <url>%2F2019%2F03%2F14%2FC-%E7%AE%97%E6%B3%95%E7%AF%87-std-nth-element%2F</url>
    <content type="text"><![CDATA[template&lt; class RandomIt &gt; void nth_element( RandomIt first, RandomIt nth, RandomIt last ); 123456789101112131415#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;functional&gt; int main()&#123; std::vector&lt;int&gt; v&#123;5, 6, 4, 3, 2, 6, 7, 9, 3&#125;; std::nth_element(v.begin(), v.begin() + v.size()/2, v.end()); std::cout &lt;&lt; "The median is " &lt;&lt; v[v.size()/2] &lt;&lt; '\n'; std::nth_element(v.begin(), v.begin()+1, v.end(), std::greater&lt;int&gt;()); std::cout &lt;&lt; "The second largest element is " &lt;&lt; v[1] &lt;&lt; '\n';&#125; 输出： 12The median is 5The second largest element is 7 to be conitued…]]></content>
      <categories>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>Sort</tag>
        <tag>Algorithms library</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[刷题笔记 C/C++基础]]></title>
    <url>%2F2019%2F03%2F13%2F%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-C-C-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[编译Q: 1234567void func()&#123; char b[2]=&#123;0&#125;; strcpy(b,"aaaa");&#125;以下说法那个正确() Debug版崩溃，Release版正常 A: 1234assert 含义是断言，它是标准C++的cassert头文件中定义的一个宏，用来判断一个条件表达式的值是否为ture,如果不为true, 程序会终止，并且报告出错误，这样就很容易将错误定位 通常我们开发的程序有2种模式:Debug模式和Release模式1. 在Debug模式下,编译器会记录很多调试信息,也可以加入很多测试代码,比如加入断言assert，方便我们程序员测试,以及出现bug时的分析解决。2. Release模式下,就没有上述那些调试信息,而且编译器也会自动优化一些代码,这样生成的程序性能是最优的,但是如果出现问题,就不方便分析测试了。因为这样会覆盖不属于自己的内存，这是搭上了程序崩溃的列车，即未定义行为，出现什么后果都有可能的，程序员的职责是保证不越界，而不是追问越界之后会发生什么。 Q: 12345以下叙述正确的是（ ）。可以把define和if定义为用户标识符。×可以把define定义为用户标识符，但不能把if定义为用户标识符。√可以把if定义为用户标识符，但不能把define定义为用户标识符。×define和if都不能定义为用户标识符。× A: 12预定义标识符：define scanf printf include。※ 预定义标识符可以做为用户标识符。 Q: 123456引用标准库，下面的说法哪些是正确的？正确答案: B 你的答案: B (正确)A.语句#include "stdio. h" 是正确的，而且程序编译的速度比#include&lt;stdio. h&gt;要快B.语句#include &lt;stdio. h&gt;是正确的，而且程序编译的速度比#include"stdio. h"要快C.语句#include "stdio. h"和#include &lt;stdio. h&gt;都是正确的，程序编译速度没有区别D.语句#include "stdio. h"是错误的 A: 12通过&lt;&gt;，（库里）一步就找到了通过“”， 由于先从当前目录中找（未找到），再到库中寻找（找到），比前者多了一步，所以花费时间比前者多 C++基础内存管理stackQ:如下C++程序，请问刚进入func函数时，参数在栈中的形式可能为 （左侧为地址，右侧为数据—） 123int i=0x22222222； char szTest[]=”aaaa”; //a的ascii码为0x61 func(I, szTest); //函数原型为void func(int a,char *sz); A: 123450x0013FCF0 0x0013FCF80x0013FCF4 0x222222220x0013FCF8 0x616161611，对于x86，栈的存储：从高到低2，函数调用入栈顺序是：从右到左 表达式sizeofQ： 1234567win32系统里，下面几个sizeof的运行结果是（）int intValue=1024;char str[]="Tencent";const char* ch=str;sizeof(intValue)=__a___;//4sizeof(str)=__b____;//8sizeof(ch)=____c___;//4 A: 1234567891011121314151617181920212223242526272829303132333435363738394041424344451. cppp ex4_29:int x[10]; int *p = x;cout &lt;&lt; sizeof(x) / sizeof(*x);//10/1=10数组所占内存大小/数组每个元素所占内存的大小=数组的容量。因为cpp数组不内置求容量的方法，可以用这个方法求数组容量。无论是整型数组还是字符数组，数组名作为右值的时候都代表数组首元素的首地址。数组名不发生降级（还是数组）：sizeof（数组名），&amp;数组名 数组发生降级（变成指针）: 数组名作为参数传参，数组名参与运算cout &lt;&lt; sizeof(p) / sizeof(*p);//4/4=1 指针的大小/指针所指内容类型int的大小2. char str1[]="Tencent";char str2[]=&#123;'T','e','n','c','e','n','t'&#125;;注意区别：sizeof(str1)=8;//8*sizeof(char)=8;//对于一个数组，返回这个数组占的总空间."Tencent"敏感词有T e n c e n t \0八个字符，所以str数组的长度是8.sizeof(str2)=7; //没有结束符strlen(str1)=7;//strlen不区分是数组还是指针，就读到\0为止返回长度。并且strlen是不把\0计入字符串的长度的。sizeof（char）=1;//char类型占一个字节sizeof（int）=4;//int类型占4个字节sizeof(ch)=sizeof(char*)=4;//ch是一个指针，在 C/C++ 中一个指针占4个字节 3.《cppp》p139：sizeof返回一个表达式或者类型名字所占的字节数。满足右结合律,且与*优先级一样，所以sizeof *p等价于sizeof(*p)。返回值是size_t类型。sizeof不会计算运算对象的值。即使解引用一个无效指针，依然是一个安全的行为，因为指针并没有真正被使用。语法：①sizeof(type);类型大小。②sizeof expr;表达式大小。className data,*p;sizeof(className);//className类型的对象所占空间大小sizeof data;//同sizeof(className)sizeof *p;//同sizeof(className)sizeof p;//指针大小,44.ex4_28:输出每种空间内置类型大小（32位）bool is 1bytes.char is 1bytes.wchar_t is 2bytes.char16_t is 2bytes.char32_t is 4bytes.short is 2bytes.int is 4bytes.long is 4bytes.long long is 8bytes.float is 4bytes.double is 8bytes.long double is 8bytes. 运算符优先级Q: 1234567以下程序的输出结果是（1）。main()&#123; int a=4,b=5,c=0,d; d=!a&amp;&amp;!b||!c; printf("%d\n",d);&#125; A: 123456789101112单目优先级最高。d=0&amp;&amp;0||1。逻辑表达式从左至右。答案为1.[扩展]1.ex4_30：sizeof优先级和解引用*一级，次于成员选择，单目&gt;双目sizeof x + y // (sizeof x)+y . "sizeof" has higher precedence than binary`\+`.sizeof p-&gt;mem[i] // sizeof(p-&gt;mem[i])sizeof a &lt; b // sizeof(a) &lt; bsizeof f() // 如果F返回空，则无定义。否则返回返回指的类型所占大小。2.[]高于*,[]从左往右，*从右往左int *c[4];//16。4个（int*)类型的数组=16int(*d)[4];//4。指向4个int型的数组的指针=4 转型Q: 1234567891011#include &lt;stdio.h&gt;int main(void)&#123; unsigned int a = 1; signed int b = -3; int c; (a+b&gt;0)?(c=1):(c=0); printf("%d",c); return 0;&#125;正确答案: 1 你的答案: 0 (错误) A: 12unsigned int + int = unsigned int + [unsigned int]int 会转换为 unsigned int 字符串、向量、数组字符串数组1.环形队列c[1..m],m为数组长度，f为队头元素在数组中的位置，r是队尾元素的后一位置(顺时针),若队列非空，队列中元素个数的公式：(r-f+m)%m Q: 12345以下 C 语言指令：int a[5] = &#123;1,3,5,7,9&#125;;int *p = (int *)(&amp;a+1);printf(“%d,%d”,*(a+1) ， *(p-1));运行结果是什么？ A: 1[解]3,9 Q: 12345下列关于对象数组的描述中，( B )是错误的。A.对象数组的下标是从 0 开始的B.对象数组的数组名是一个常量指针C.对象数组的每个元素是同一个类的对象D.对象数组只能赋初值，而不能被赋值。 A: 12B:数组名永远不可能是指针，这是两个类型，只不过函数传递时数组名会退化成指针。D:数组只能初始化赋初值，可以对数组中的成员赋值，但不能对数组赋值。 指针数组Q: 12345678设有以下定义：a[4][3]=&#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;;int (*prt)[3]=a, *p=a[0];则以下能够正确表示数组元素a[1][2]的表达式是哪些？ A. *((*prt+1)[2])B. *(*(p+5))C. (*prt+1)+2D. *(*(a+1)+2)。√ A: 123456789101112131415161718192021222324252627282930313233主要考察.下标和指针转化公式：*(a+n) = a[n]拆分二维数组int a[4][3] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 &#125;;拆分成：int b[3] = &#123;1, 2, 3 &#125;;int c[3] = &#123;4, 5, 6 &#125;;int d[3] = &#123;7, 8, 9 &#125;;int e[3] = &#123;10, 11, 12 &#125;;那么就有：a[4] = &#123; b, c, d, e &#125;; a是数组a中第一个元素b的地址 int (*prt)[3]=a就是int b[3];int *prt = &amp;b;即定义了一个指向“数组第一个元素的地址”的指针prt；a表示的正是b的地址。所以，这里等价于：prt = a。A：* (( * prt+1)[2])*a 即a[0]，也就是b；( b+1) 表示 元素2的地址，也就是a[0][1]的地址；(b+1)[2] → *( (b+1) + 2 ) = *(b+3) = b[3]，越界了！其实就是c[0]，VS上验证过，输出也是B：* ( * (p+5))int *p = a[0]，相当于int *p = b，遇到p直接用b替换就行了！* (p+5)等价于b[5]，也就是c[2]，元素6，前面还多个*，所以这个错的也很明显。C：( * prt+1)+2( * a+1)+2,*优先级高于+,(b+1) + 2 = b+3，是4的地址，也就是c[0]的地址；同样错误。D:下标和指针转化公式：*(a+n) = a[n]，这个正反都可以使用，而且很好用。 声明constQ: 12345678What is output if you compile and execute the following c code?void main()&#123; int i = 11; int const *p = &amp;i; p++; printf("%d",*p);&#125; A: 12345678910111213141516171819202122232425262728293031323334353637383940414243[解]Garbage value。p指是常量，不能改变所指地址。[扩展]1.const用来定义不能改变的变量。所以①对象必须初始化。②一经创造后不能赋值。const int i =get_size();//正确。运行时初始化。const int j = 42;//正确。编译时初始化。const int k;//错误。未初始化。j=33;//错误。不能赋值。const int h = j;//正确。拷贝初始化。拷贝一个对象并不会改变它。2.reference to const：不用做修改绑定的对象。const int c=1024;const int &amp;r1=c;//正确。常量引用指向常量对象。r1 = 31; //错误。常量引用不能赋值。int &amp;r2 = c;//错误。非常量引用不能指向常量对象。int n=1;const int &amp;r3=n;//正确。常量引用指向非常量对象。3.C++规定引用的类型必须和引用对象一致。但是两种例外。①初始化【常量引用】时，允许用任何表达式作为初始值。②允许【常量引用】绑定【非常量】的对象、字面值、表达式。int i =42;const int &amp;r1 = i;//正确。对象const int &amp;r2 = 42;//正确。字面值const int &amp;r3 = r1 *2 ;//正确。表达式int &amp;r4 = r1*2;//错误。非法。常量引用不可以被绑定到非常量引用上。因为常量引用对象的值是不可以改变的。4.当一个常量引用被绑定到另一个类型上发生了什么？double dval =3.14;const int &amp;r1 = dval;//r1的操作是整型运算。而dval是双精度。为了让r1绑定一个整数，编译器会把dval转为int的临时变量：const int temp =dval;const int &amp;r1 =temp;5.const和指针方法是：从右往左阅读。①C++允许【常量引用】绑定【非常量】double dval = 3.14;const double *p = &amp;dval;//正确。p所指对象是常量。不能通过p改变p指向对象的值。（指向常量的指针："自以为"指向了常量，不会改变所指对象的值。）②const指针int num = 0;int *const p = &amp;num;//p是常量。类型是指针。p一直指向num storage_duration static 静态或线程存储期和内部链接。内存中只存在一个。 extern 静态或线程存储期和内部链接。外部变量，可以供所有源文件使用 thread_local 线程存储期。 mutable 不影响存储期或链接。 register (c++17弃用) 放在寄存器中，而非内存中， 效率更高，一般是临时变量 auto (c++11前) 默认都是自动变量 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;mutex&gt; thread_local unsigned int rage = 1; std::mutex cout_mutex;//a synchronization primitive that can be used to protect shared data from being simultaneously accessed by multiple threads. void increase_rage(const std::string&amp; thread_name)&#123; ++rage; // 在锁外修改 OK ；这是线程局域变量 std::lock_guard&lt;std::mutex&gt; lock(cout_mutex); std::cout &lt;&lt; "Rage counter for " &lt;&lt; thread_name &lt;&lt; ": " &lt;&lt; rage &lt;&lt; '\n';&#125; int main()&#123; std::thread a(increase_rage, "a"), b(increase_rage, "b"); &#123; std::lock_guard&lt;std::mutex&gt; lock(cout_mutex); std::cout &lt;&lt; "Rage counter for main: " &lt;&lt; rage &lt;&lt; '\n'; &#125; a.join(); b.join();&#125; output 123Rage counter for a: 2Rage counter for main: 1Rage counter for b: 2 pointerQ: 12345678910111213若有以下说明和定义，在必要的赋值之后，对fun函数的正确调用语句是（）。int fun (int *c) &#123; … &#125; void main() &#123; int (*a)(int*)=fun,"b ( ),w[10],c; … &#125; 正确答案: B 你的答案: D (错误)A. a=a(w)；B. (*a)(&amp;c)；C. b=*b(w);D. fun(b); A: 1234A: a(w)调用正确，但将其返回值赋值给a是错误的，因为返回值是整型数，而a是一函数指针，所以答案A是错误的。B: 因为a指向了函数fun，所以它等价于fun(&amp;c)的调用，是正确的。C: 因b是一个返回值为整型数指针的函数，*b(w)本身就是错误的。D: b后面省掉了括号，因为b是函数，故也是错误的。 C++标准库IO库Q: 12345678910111213141516下面的程序执行后，文件test.txt中的内容是（）. #include &lt;stdio.h&gt; void fun (char *fname,char *st) &#123; FTLE *myf;int i; myf=fopen (fname,"w"); for (i=0;i&lt;strlen(st);i++) fputc (st[i],myf); fclose (myf); &#125; void main() &#123; fun("test.txt","new world")；fun("test.txt","hello,"); &#125; 输出：hello, A: 1234567891011121314151617181920打开文件采用的是w方式，该方法表示会[将原文件清除]，然后再重新写入。fopen存在下面几种模式：r 以只读方式打开文件，该文件必须存在。r+ 以读/写方式打开文件，该文件必须存在。rb+ 以读/写方式打开一个二进制文件，只允许读/写数据。rt+ 以读/写方式打开一个文本文件，允许读和写。w 打开只写文件，若文件存在则长度清为 0，即该文件内容消失，若不存在则创建该文件。w+ 打开可读/写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即[文件原先的内容会被保留]（EOF 符保留）。a+ 以附加方式打开可读/写的文件。若文件不存在，则会建立该文件，如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留（原来的 EOF 符不保留）。wb 以只写方式打开或新建一个二进制文件，只允许写数据。wb+ 以读/写方式打开或建立一个二进制文件，允许读和写。wt+ 以读/写方式打开或建立一个文本文件，允许读写。at+ 以读/写方式打开一个文本文件，允许读或在文本末追加数据。ab+ 以读/写方式打开一个二进制文件，允许读或在文件末追加数据。 Q: 12345已知：int x，y；double z；以下语句中错误的函数调用是（D）。 A.scanf(“%d,%1x,%1e",&amp;x,&amp;y,&amp;z)；√B.scanf(“%2d*%d%1f”,&amp;x,&amp;y,&amp;z)；√C.scanf(“%x%*d%o”,&amp;x,&amp;y)；√D.scanf(“%x%o%6.2f",&amp;x,&amp;y,&amp;z)；× A: 123B：只能获取x的值，y和z都不能正常获取，但是不会报错。C：*格式，表示跳过此数据不读入。放在%与格式d（或者s，c等）之间。 D：scanf中的格式控制符不能指明浮点数的精度，D中%6.2f是错误的。 Q: 123456789101112131415#incude &lt;stdio.h&gt;main()｛ FILE*fp； int i,a[6]=&#123;1,2,3,4,5,6&#125;； fp=fopen("d2.dat","w+")； for(i=0；i&lt;6;i++) fprintf(fp,"%d\n",a [i])； rewind(fp）； for(i=0；i&lt;6;i++) fscanf( fp,"%d",&amp;a[5-i])； fclose(fp）； for(i=0；i&lt;6；i++) printf("%d,",a [i])；//6,5,4,3,2,1,&#125; A: 12345678910[解]fprintf是C/C++中的一个格式化写—库函数，位于头文件&lt;stdio.h&gt;中，其作用是格式化输出到一个流/文件中for(i=0；i&lt;6;i++) fprintf(fp,"%d\n",a [i])； //这句是把a[i]依次写入文件流指针fp 内容为1 2 3 4 5 6rewind(fp）//把文件流指针从新指向文件的开头fscanf 其功能为根据数据格式(format)从输入流(stream)中写入数据(argument)for(i=0；i&lt;6;i++) fscanf( fp,"%d",&amp;a[5-i])；//把文件流指针fp依次指向的内容写入到a[5-i],a[5]=1,a[4]=2,a[3]=3,a[2]=4,a[1]=5,a[0]=6; Q: 1从控制台输入以","分隔的字符串，要求把字符串存入数组中。 A: 123456789101112131415161718192021222324252627282930313233343536373839404142434445[解]#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;vector&gt;#include &lt;array&gt; int main()&#123; string str; getline(cin, str); istringstream input(str); vector&lt;array&lt;char, 100&gt;&gt; v; // 注意：下列循环在从 getline() 返回的流上的 // std::ios_base::operator bool() 返回 false 时终止 for (array&lt;char, 100&gt;a; input.getline(&amp;a[0], 100, '，'); ) &#123; v.push_back(a); &#125; for (auto&amp; a : v) &#123; std::cout &lt;&lt; &amp;a[0] &lt;&lt; '\n'; &#125; return 0;&#125;[扩展]basic_istream&amp; getline( char_type* s, std::streamsize count, char_type delim );//从流释出字符到数组，遇到行尾、指定的分隔符 delim、超过数组容量时停止。int main()&#123; string str; getline(cin, str); std::istringstream input(str); std::vector&lt;int&gt; v; char a[100]; while(input.getline(&amp;a[0], 100, ',')) v.push_back(atoi(a)); for (auto a : v) &#123; std::cout &lt;&lt;a &lt;&lt; '\n'; &#125; return 0;&#125; 类设计者的工具类unionQ: 12345678910若有以下说明和定义union dt&#123;int a; char b; double c;&#125;data;以下叙述中错误的是 ( C ) 。 A.data的每个成员起始地址都相同。√B.变量data所占内存字节数与成员c所占字节数相等。√C.程序段：data.a=5;printf("%f\n",data.c);输出结果为5.000000。×D.data可以作为函数的实参。√ A: 1234567printf函数只是将内存中的数据以不同的类型输出，而不能将内存中的整型数据自动转换为等值的浮点数，故C是错误的。在内存中，实数与整数的存放形式完全不一样，共用体的成员共用的是同一块内存，而不是同一个数值，因此选项C是错误的。浮点数存储格式为IEEE754标准，以32位float(4字节)为例，float i = 21.375；i在计算机存储分为三个部分，- 符号位S- 阶码E,阶码E用偏移值表示- 尾码M,尾码M用原码表示 12345S为符号位，1代表负数，0代表整数，E代表偏移127的幂，M代表尾数。由于i&lt;0,所以S = 1,对于E ,i 的二进制表示为10101.011，然后二进制右移4位，让最左边保留一位1，即10101.011 = 1.0101011*2^4,那么E = 127+4 = 131=10000011,对于M，就是小数点后的的数0101011，由于要保证位23位，所以在末尾补0，即M=0101011000000000000000所以i的存储为S+ E+M= 1-10000011-01010110000000000000000. classQ:下面程序的输出是什么？ 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;class parent&#123; int i;//未声明访问权限则默认private,它和结构体的唯一区别protected: int x;//子类可以访问x,不能访问ipublic: parent() &#123; x = 0; i = 0; &#125; void change() &#123; x++; i++; &#125; void display();&#125;;class son :public parent&#123;public: void modify();&#125;;void parent::display() &#123; cout &lt;&lt; "x=" &lt;&lt; x &lt;&lt; endl; &#125;void son::modify() &#123; x++; &#125;int main()&#123; son A; //A.x=0 ; A.i=0 parent B;//B.x=0;B.i=0 A.display();//x=0 A.change();//执行parent::change().A.x=1; A.i=1 A.modify();//执行son::modify().A.x=2; A.i=1 A.display();//x=2 B.change();//执行parent::change().B.x=1; B.i=1 B.display();//x=1 &#125; A: 1234567输出：x=0 x=2 x=1- 子类会继承父类除构造函数和析构函数之外[所有的数据成员和成员函数]。虽然son不能继承parent的构造函数,但初始化A时强制调用了parent的构造函数。- 实例化后，[子类和父类的对象互不影响]。- 类的成员变量[未声明访问权限则默认private]，这是它和结构体的唯一区别。- 基类的private成员不能被子类访问，但其protected成员可以被子类访问，两者均不可在类外访问，故文中子类可以访问x,不能访问i static membersQ: 12345关于类的静态成员的描述：A. 静态成员不属于对象，是类的共享成员。√B. non-const static数据成员要在类外定义和初始化,const static的数据成员必须在类里初始化。√C. 静态成员函数不拥有this指针，需要通过类参数访问对象成员。√D. 只有静态成员函数可以操作静态数据成员。× A: 重载普通函数的重载Q1: 12345下列对重载函数的描述中，_____A_______是错误的。A.重载函数中不允许使用默认参数.B.重载函数中编译时根据参数表进行选择C.构造函数重载将会给初始化带来多种方式D.不要使用重载函数来描述毫无相干的函数 A1: 12345一般情况下，在函数调用时形参从实参那里取得值，因此实参的个数应于形参相同。有时多次调用同样的实参，c++提供简单的处理办法，给实参一个默认值，这样形参就不必从实参取值了。如有一函数申明float area (float r=6.5)；指定r的默认值为6.5。如果在调用此函数时，确认r的值为6.5，则可以不必给出实参的值，如： area( )； //相当于area（6.5）；如果不想使形参取默认值，则通过实参另行给出。如：area(7.5)。 Q2: 123456以下不是double compare(int,int)的重载函数的是()正确答案: D 你的答案: D (正确)int compare(double,double)double compare(double,double)double compare(double,int)int compare(int,int) A2: 1234567891011121314重载函数与类型无关，所以不看类型。- 成员函数被重载的特征： 1. 相同的范围（在同一个类中）； 2. 函数名字相同； 3. 参数不同； 4. virtual 关键字可有可无。- 覆盖是指派生类函数覆盖基类函数，特征是： 1. 不同的范围（分别位于派生类与基类）； 2. 函数名字相同； 3. 参数相同； 4. 基类函数必须有 virtual 关键字。- 隐藏是指派生类的函数屏蔽了与其同名的基类函数，规则如下： 1. 如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无 virtual 关键字，基类的函数将被隐藏（注意别与重载混淆）。 2. 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有 virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。 运算符重载Q: 123456有关运算符重载正确的描述是（D）正确答案: D 你的答案: A (错误)c++语言允许在重载运算符时改变运算符的操作个数c++语言允许在重载运算符时改变运算符的优先级c++语言允许在重载运算符时改变运算符的结合性c++语言允许在重载运算符时改变运算符原来的功能 A: 12c ++语言允许在重载运算符时改变运算符原来的功能。例如将“ + + "符号重载时，可以定义为“--"的功能。但是，不提倡这样做，重载运算符最好仍保持原有的功能。与普通函数的重载规则不同，这里的对象是运算符（运算符重载是特殊的函数重载），运算符重载有自己的规则，不要混为一谈。 动态绑定纯虚函数Q1: 123456关于纯虚函数，下列表述正确的是？（ B ）正确答案: B 你的答案: C (错误)A.派生类必须实现基类的纯虚函数B.纯虚函数的声明总是以“=0”结束C.纯虚函数是给出实现版本（即无函数体定义）的虚函数D.含有纯虚函数的类一定是派生类 A1: 123A.含有纯虚函数的类是抽象类，对于继承抽象类的派生类来说，如果[派生类实现了基类的纯虚函数，则派生类可以实例化]。若派生类没有实现该纯虚函数，则该[派生类也是抽象类]，即不能实例化。C.纯虚函数是需要在该类下不实现而[在派生类中实现]的函数。D.含有纯虚函数的类一定是[基类]，需要[派生类]来[实现其虚函数的功能]。 Q2: 1234如果不使用多态机制，那么通过基类的指针虽然可以指向派生类对象，但是只能访问从基类继承的成员。正确答案: A 你的答案: A (正确)A.是B.否 A2: 1若不使用多态机制，则动态绑定不存在。即基类与派生类虚函数无法根据指针指向的对象动态选择。 虚函数就无法使用。 面向对象Q: 12345在C++面向对象编程语言中，以下阐述 A.接口中可以用虚方法。×B.一个类可以实现多个接口。√C.接口不能被实例化。√D.接口中可以包含已经实现的方法。× A: 123接口是指[只包含纯虚函数]的[抽象类]。A:接口和普通的抽象类不一样。所以A不对，必须是纯虚函数。D:接口即只包含纯虚函数的抽象类，所以D是不对的。]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[刷题笔记 操作系统]]></title>
    <url>%2F2019%2F03%2F13%2F%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[内存管理Q1. 164位系统和32位系统的区别 A1. 1238位的cpu，一次处理一个8位的数据，比如'10001000'，如果'+1'这个运算，cpu要先做'+'，再做'1'传给cpu16位的cpu，一次处理2个字节(16位)32位的cpu，一次处理4个字节 type 32bit - byte count 64bit - byte count range bool 1 ture,false char 1 -128~127(-2^7~2^7-1) unsigned char 1 0~255(0~2^8-1) short 2 -32768~32767(-2^15~2^15-1) unsigned short 2 0~65535(2^16-1) int 4 (-2^31~2^31-1) unsigned int 4 (0~2^32-1) long 4 8 unsigned long 4 8 long long 8 -2^64~2^64-1 float 4 -2^128~2^128，精度为6~7位有效数字 double 8 -2^1024~2^1024，精度为15~16位 long double 8 -2^1024~2^1024，精度为15~16位 * 4 8 除了long和指针有区别之外，其它不变。 进程线程Q: 12345下面哪些方式可以用于线程之间的同步？ 临界区。√互斥区。√事件。√信号量。√ A: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647进程中线程同步的四种常用方式：- 临界区（CCriticalSection） 当多个线程访问一个独占性共享资源时，可以使用临界区对象。[拥有临界区的线程]可以访问被保护起来的资源或代码段，其他线程若想访问，则被挂起，直到拥有临界区的线程放弃临界区为止。具体应用方式： 1. 定义临界区对象CcriticalSection g_CriticalSection; 2. 在访问共享资源（代码或变量）之前，先获得临界区对象，g_CriticalSection.Lock（）； 3. 访问共享资源后，则放弃临界区对象，g_CriticalSection.Unlock（）； - 事件（CEvent） 事件机制，则允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。比如在某些网络应用程序中，一个线程如A负责侦听通信端口，另外一个线程B负责更新用户数据，利用事件机制，则线程A可以通知线程B何时更新用户数据。 每个Cevent对象可以有两种状态：有信号状态和无信号状态。 Cevent类对象有两种类型：人工事件和自动事件。 自动事件对象，在被至少一个线程释放后自动返回到无信号状态； 人工事件对象，获得信号后，释放可利用线程，但直到调用成员函数ReSet()才将其设置为无信号状态。 在创建Cevent对象时，默认创建的是自动事件。 1. 1234CEvent( BOOL bInitiallyOwn=FALSE, //指定事件对象初始化状态，TRUE为有信号，FALSE为无信号； BOOL bManualReset=FALSE, //指定要创建的事件是属于人工事件还是自动事件。TRUE为人工事件，FALSE为自动事件； LPCTSTR lpszName=NULL, LPSECURITY_ATTRIBUTES lpsaAttribute=NULL); 2. BOOL CEvent：：SetEvent(); 将Cevent类对象的状态设置为有信号状态。 如果事件是人工事件，则Cevent类对象保持为有信号状态，直到调用成员函数ResetEvent()将其重新设为无信号状态时为止。 如果为自动事件，则在SetEvent（）后将事件设置为有信号状态，由系统自动重置为无信号状态。 3. BOOL CEvent：：ResetEvent(); 将事件的状态设置为无信号状态，并保持该状态直至SetEvent（）被调用为止。 由于自动事件是由系统自动重置，故自动事件不需要调用该函数。 4. 一般通过调用WaitForSingleObject（）函数来监视事件状态。 - 互斥量（CMutex） 互斥对象和临界区对象非常相似，只是其[允许在进程间]使用，而临界区[只限制与同一进程的各个线程]之间使用，但是更节省资源，更有效率。 - 信号量（CSemphore） 当需要一个计数器来[限制可以使用某共享资源的线程数目]时，可以使用“信号量”对象。 CSemaphore类对象保存了对当前访问某一个指定资源的线程的计数值，该计数值是[当前还可以使用该资源的线程数目]。 如果这个计数达到了零，则所有对这个CSemaphore类对象所控制的资源的访问尝试都被放入到一个队列中等待，直到超时或计数值不为零为止。 CSemaphore( LONG lInitialCount = 1, //信号量对象的初始计数值，即可访问线程数目的初始值； LONG lMaxCount = 1, //信号量对象计数值的最大值，该参数决定了同一时刻可访问由信号量保护的资源的线程最大数目； LPCTSTR pstrName = NULL, LPSECURITY_ATTRIBUTES lpsaAttributes = NULL ); 一般是将当前可用资源计数设置为最大资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就减1，只要当前可用资源计数大于0，就可以发出信号量信号。如果为0，则放入一个队列中等待。 线程在处理完共享资源后，应在离开的同时通过ReleaseSemaphore（）函数将当前可用资源数加1。]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 面向对象篇 Union]]></title>
    <url>%2F2019%2F03%2F13%2FC-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AF%87-Union%2F</url>
    <content type="text"><![CDATA[Rules The union is only as big as necessary to hold its [largest data] member. The other data members are allocated in the [same bytes] as part of that [largest member]. The details of that allocation are [implementation-defined], and it’s [undefined behavior] to read from the member of the union that [wasn’t most recently written]. Many compilers implement, as a [non-standard language extension], the ability to [read inactive] members of a union. 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdint&gt;union S&#123; std::int32_t n; // occupies 4 bytes std::uint16_t s[2]; // uint16_t:unsigned integer type with width of exactly 16 // occupies 4 bytes(2*2=4) std::uint8_t c; // uint8_t:unsigned integer type with width of exactly 8 // occupies 1 byte&#125;; // the whole union occupies 4 bytes[rule.1] int main()&#123; S s = &#123;0x12345678&#125;; // initializes the first member, s.n is now the active member // at this point, reading from s.s or s.c is undefined behavior[rule.3] std::cout &lt;&lt; std::hex &lt;&lt; "s.n = " &lt;&lt; s.n &lt;&lt; '\n'; s.s[0] = 0x0011; // s.s is now the active member // at this point, reading from n or c is UB but most compilers define it[rule.4] std::cout &lt;&lt; "s.c is now " &lt;&lt; +s.c &lt;&lt; '\n' // 11 or 00, depending on platform &lt;&lt; "s.n is now " &lt;&lt; s.n &lt;&lt; '\n'; // 12340011 or 00115678&#125; output 123s.n = 12345678s.c is now 0s.n is now 115678 Member allocatingEach member is allocated as if it is the only member of the class. Conctors and Dectors of membersIf members of a union are classes with [user-defined constructors] and [destructors], to switch the active member, [explicit destructor] and [placement new] are generally needed: 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt; union S&#123; std::string str; std::vector&lt;int&gt; vec; ~S() &#123;&#125; // needs to know which member is active, only possible in union-like class &#125;;// the whole union occupies max(sizeof(string), sizeof(vector&lt;int&gt;))[rule.1] int main()&#123; S s = &#123;"Hello, world"&#125;; // at this point, reading from s.vec is undefined behavior[rule.3] std::cout &lt;&lt; "s.str = " &lt;&lt; s.str &lt;&lt; '\n'; s.str.~basic_string(); new (&amp;s.vec) std::vector&lt;int&gt;;//placement new // now, s.vec is the active member of the union s.vec.push_back(10); std::cout &lt;&lt; s.vec.size() &lt;&lt; '\n'; s.vec.~vector();//explicit destructor&#125; output 12s.str = Hello, world1 Member lifetime1234567891011121314151617181920union A &#123; int x; int y[4]; &#125;;struct B &#123; A a; &#125;;union C &#123; B b; int k; &#125;;int f() &#123; C c; // does not start lifetime of any union member c.b.a.y[3] = 4; // OK: "c.b.a.y[3]", names union members c.b and c.b.a.y; // This creates objects to hold union members c.b and c.b.a.y return c.b.a.y[3]; // OK: c.b.a.y refers to newly created object&#125; struct X &#123; const int a; int b; &#125;;union Y &#123; X x; int k; &#125;;void g() &#123; Y y = &#123; &#123; 1, 2 &#125; &#125;; // OK, y.x is active union member (9.2) int n = y.x.a; y.k = 4; // OK: ends lifetime of y.x, y.k is active member of union y.x.b = n; // undefined behavior: y.x.b modified outside its lifetime, // "y.x.b" names y.x, but X's default constructor is deleted, // so union member y.x's lifetime does not implicitly start&#125; Anonymous unions12345678910int main()&#123; union &#123; int a; const char* p; &#125;; a = 1; p = "Jennifer";&#125; Union-like classesA union-like class is either a (non-union) class that has at least one anonymous union as a member or a union. A union-like class has a set of variant members: the non-static data members of its member anonymous unions; in addition, if the union-like class is a union, its non-static data members that are not anonymous unions. Union-like classes can be used to implement tagged unions. 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt; // S has one non-static data member (tag), three enumerator members (CHAR, INT, DOUBLE), // and three variant members (c, i, d)struct S&#123; enum&#123;CHAR, INT, DOUBLE&#125; tag; union &#123; char c; int i; double d; &#125;;&#125;; void print_s(const S&amp; s)&#123; switch(s.tag) &#123; case S::CHAR: std::cout &lt;&lt; s.c &lt;&lt; '\n'; break; case S::INT: std::cout &lt;&lt; s.i &lt;&lt; '\n'; break; case S::DOUBLE: std::cout &lt;&lt; s.d &lt;&lt; '\n'; break; &#125;&#125; int main()&#123; S s = &#123;S::CHAR, 'a'&#125;; print_s(s); s.tag = S::INT; s.i = 123; print_s(s);&#125; output 12a123]]></content>
      <categories>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>OOP</tag>
        <tag>union</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 语言篇 Named requirements]]></title>
    <url>%2F2019%2F03%2F12%2FC-%E8%AF%AD%E8%A8%80%E7%AF%87-Named-requirements%2F</url>
    <content type="text"><![CDATA[Utilities library:Type support std::is_objectDefined in header &lt;type_traits> (c++11) cv-qualified type, value is true. function, reference, or void types, value is false. 12template&lt; class T &gt; struct is_object; 12345678910111213141516#include &lt;iostream&gt;#include &lt;type_traits&gt; int main() &#123; class cls &#123;&#125;; std::cout &lt;&lt; std::boolalpha; //IO library:IO manipulators std::cout &lt;&lt; std::is_object&lt;int&gt;::value &lt;&lt; '\n'; //true,cv-qualified type std::cout &lt;&lt; std::is_object&lt;int&amp;&gt;::value &lt;&lt; '\n'; //false,reference type std::cout &lt;&lt; std::is_object&lt;cls&gt;::value &lt;&lt; '\n'; //true,cv-qualified type std::cout &lt;&lt; std::is_object&lt;cls&amp;&gt;::value &lt;&lt; '\n'; //false,reference type&#125; Named Requirements: Library-Wide Function Object A FunctionObject type is the type of an object that can be used on the left of the function call operator. （能以函数调用语法调用的对象。） RequirementsThe type T satisfies FunctionObject if The type T satisfies std::is_object, and Given f, a value of type T or const T args, suitable argument list, which may be empty Notes※ Functions and references to functions are not function object types, but can be used where function object types are expected due to function-to-pointer implicit conversion(pointers to functions指向函数的指针). Standard library All pointers to functions satisfy this requirement. All [Function objects] defined in &lt;functional> Some [return types of functions] of &lt;functional> Predicate The Predicate requirements describe a callable that returns a value testable as a bool.谓词要求描述可调用对象返回可作为 bool 测试的值。 Predicate is typically used with algorithms that take input data (individual objects/containers) and a predicate, which is then called on input data to decide on further course of action. Some examples of predicate usage in C++ standard library are: std::all_of, std::any_of,std::none_of Take an array of elements and a predicate as an input. Call predicate on individual input elements, and return true if for all/any/none elements, predicate returns true. 123456789101112131415161718192021222324252627282930int main()&#123; std::vector&lt;int&gt; v(10, 2); std::partial_sum(v.begin(), v.end(), v.begin()); //&lt;numeric&gt;,计算范围 [first, last) 的子范围中元素的部分和，并写入到始于 d_first 的范围。默认版本用 operator+ ，第二版本用给定的二元函数 op 对元素求和. std::cout &lt;&lt; "Among the numbers: "; std::copy(v.begin(), v.end(), std::ostream_iterator&lt;int&gt;(std::cout, " ")); std::cout &lt;&lt; '\n'; //all_of:若一元谓词对范围中所有元素返回 true 则为 true ，否则为 false 。若范围为空则返回 true 。 if (std::all_of(v.begin(), v.end(), [](int i)&#123; return i % 2 == 0; &#125;)) &#123; std::cout &lt;&lt; "All numbers are even\n"; &#125; //none_of: 若一元谓词不对范围中任何元素返回 true 则为 true ，否则为 false 。若范围为空则返回 true 。 if (std::none_of(v.cbegin(), v.cend(), std::bind(std::modulus&lt;int&gt;(), std::placeholders::_1, 2))) &#123; std::cout &lt;&lt; "None of them are odd\n"; &#125; //any_of: 若一元谓词对范围中至少一个元素返回 true 则为 true ，否则为 false 。若范围为空则返回 false 。 struct DivisibleBy &#123; const int d; DivisibleBy(int n) : d(n) &#123;&#125; bool operator()(int n) const &#123; return n % d == 0; &#125; &#125;; if (std::any_of(v.cbegin(), v.cend(), DivisibleBy(7))) &#123; std::cout &lt;&lt; "At least one number is divisible by 7\n"; &#125;&#125; output: 1234Among the numbers: 2 4 6 8 10 12 14 16 18 20 All numbers are evenNone of them are oddAt least one number is divisible by 7 std::find_if Take sequence of elements, and a predicate. Return first element in the sequence, for which predicate returns value equal to true 12345678910111213141516171819202122int main()&#123; int n1 = 3; int n2 = 5; std::vector&lt;int&gt; v&#123;0, 1, 2, 3, 4&#125;; auto result1 = std::find(std::begin(v), std::end(v), n1); auto result2 = std::find(std::begin(v), std::end(v), n2); if (result1 != std::end(v)) &#123; std::cout &lt;&lt; "v contains: " &lt;&lt; n1 &lt;&lt; '\n';//v contains: 3 &#125; else &#123; std::cout &lt;&lt; "v does not contain: " &lt;&lt; n1 &lt;&lt; '\n'; &#125; if (result2 != std::end(v)) &#123; std::cout &lt;&lt; "v contains: " &lt;&lt; n2 &lt;&lt; '\n'; &#125; else &#123; std::cout &lt;&lt; "v does not contain: " &lt;&lt; n2 &lt;&lt; '\n';//v does not contain: 5 &#125;&#125; In other words, if an algorithm takes a [Predicate] pred and an [iterator] first, it should be able to test the object of the type pointed to by the iterator first using the given predicate via a construct like if(pred(*first)) {…} .The function object [pred] shall not apply any [non-constant function] through the [dereferenced iterator]. This function object may be a [pointer to function] or [an object of a type with an appropriate function call operator]. BinaryPredicate BinaryPredicate is a set of requirements expected by some of the standard library facilities from the user-provided arguments. Given a BinaryPredicate bin_pred and a pair of iterators iter1 and iter2 or an iterator iter and a value value, the expression bin_pred(iter1, iter2) or, respectively, bin_pred(*iter, value), must be contextually convertible to bool.In addition, evaluation of that expression is not allowed to call non-const member functions of the dereferenced iterators. Requirements Predicate CopyConstructible (unless otherwise specified) Compare Compare is a set of requirements expected by some of the standard library facilities from the user-provided function object types. The return value of the function call operation applied to an object of a type satisfying Compare, when contextually converted to bool, yields true if the first argument of the call appears before the second in the strict weak ordering relation induced by this type, and false otherwise. As with any BinaryPredicate(二元谓词), evaluation of that expression is not allowed to call non-const functions through the dereferenced iterators. RequirementsThe type T satisfies Compare if The type T satisfies BinaryPredicate, andGiven comp, an object of type T equiv(a, b), an expression equivalent to !comp(a, b) &amp;&amp; !comp(b, a) The following expressions must be valid and have their specified effects Expression Return type Requirements comp(a, b) implicitly convertible to bool Establishes strict weak ordering relation with the following propertiesFor all a, comp(a,a)==falseIf comp(a,b)==true then comp(b,a)==falseif comp(a,b)==true and comp(b,c)==true then comp(a,c)==true equiv(a, b) bool Establishes equivalence relationship with the following propertiesFor all a, equiv(a,a)==trueIf equiv(a,b)==true, then equiv(b,a)==trueIf equiv(a,b)==true and equiv(b,c)==true, then equiv(a,c)==true Note: comp induces a strict total ordering on the equivalence classes determined by equiv to be continued…to be reviewed…]]></content>
      <categories>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>Function Object</tag>
        <tag>C++</tag>
        <tag>Predicate</tag>
        <tag>BinaryPredicate</tag>
        <tag>Compare</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 算法篇 std::sort_heap]]></title>
    <url>%2F2019%2F03%2F12%2FC-%E7%AE%97%E6%B3%95%E7%AF%87-std-sort-heap%2F</url>
    <content type="text"><![CDATA[STL堆操作(函数模板) is_heap(v.begin(), v.end()) 检查范围 [first, last) 中的元素是否为最大堆。[c++11] auto heap_end = is_heap_until(v.begin(), v.end()); 检验范围 [first, last) 并寻找始于 first 且为最大堆的最大范围，返回堆的最后一个。[c++11] make_heap(v.begin(), v.end()); 根据区间内的元素创建出一个最大堆 。 至多 3*N次比较。 push_heap(v.begin(), v.end()); Inserts the element at the position last-1 into the max heap defined by the range [first, last-1). 如果不是最大堆，不会报错，但是无法生成最大堆。 进行log(N)次比较。 pop_heap(v.begin(), v.end()); 移动最大元素到结尾。 如果不是最大堆，会报错。 sort_heap(v.begin(), v.end()); 转换最大堆 [first, last) 为以升序排序的范围。 如果不是最大堆，会报错。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;int main()&#123; std::vector&lt;int&gt; v = &#123; 3, 1, 4, 1, 5, 9 &#125;; std::push_heap(v.begin(), v.end()); std::cout &lt;&lt; "heap:\t"; for (const auto &amp;i : v) &#123; std::cout &lt;&lt; i &lt;&lt; ' '; &#125; std::cout &lt;&lt; '\n'; //根据区间内的元素创建出一个最大堆 std::make_heap(v.begin(), v.end()); // 9 5 4 1 1 3 std::cout &lt;&lt; "heap:\t"; for (const auto &amp;i : v) &#123; std::cout &lt;&lt; i &lt;&lt; ' '; &#125; std::cout &lt;&lt; '\n'; std::pop_heap(v.begin(), v.end()); // 移动最大元素到结尾 std::cout &lt;&lt; "after pop_heap: "; for (auto i : v) std::cout &lt;&lt; i &lt;&lt; ' ';// 5 3 4 1 1 9 std::cout &lt;&lt; '\n'; int largest = v.back(); v.pop_back(); // 实际移出最大元素 std::cout &lt;&lt; "largest element: " &lt;&lt; largest &lt;&lt; '\n';//9 std::cout &lt;&lt; "heap without largest: "; for (auto i : v) std::cout &lt;&lt; i &lt;&lt; ' ';// 5 3 4 1 1 std::cout &lt;&lt; '\n'; //转换最大堆 [first, last) 为以升序排序的范围，必须保证是最大堆，否则报错。 if (std::is_heap(v.begin(), v.end()))//检查范围 [first, last) 中的元素是否为最大堆。[c++11] std::sort_heap(v.begin(), v.end());//1 1 3 4 5 std::cout &lt;&lt; "\nsorted:\t"; for (const auto &amp;i : v) &#123; std::cout &lt;&lt; i &lt;&lt; ' '; &#125; std::cout &lt;&lt; '\n'; std::make_heap(v.begin(), v.end()); // 很可能扰乱堆 v.push_back(2); v.push_back(6); auto heap_end = std::is_heap_until(v.begin(), v.end()); std::cout &lt;&lt; "all of v: "; for (auto i : v) std::cout &lt;&lt; i &lt;&lt; ' '; std::cout &lt;&lt; '\n'; std::cout &lt;&lt; "only heap: "; for (auto i = v.begin(); i != heap_end; ++i) std::cout &lt;&lt; *i &lt;&lt; ' '; std::cout &lt;&lt; '\n'; std::push_heap(v.begin(), v.end()); std::cout &lt;&lt; "push_heap: "; for (auto i : v) std::cout &lt;&lt; i &lt;&lt; ' '; std::cout &lt;&lt; '\n';&#125; 输出： 123456789heap: 9 1 3 1 5 4heap: 9 5 4 1 1 3after pop_heap: 5 3 4 1 1 9largest element: 9heap without largest: 5 3 4 1 1sorted: 1 1 3 4 5all of v: 5 4 3 1 1 2 6only heap: 5 4 3 1 1 2push_heap: 6 4 5 1 1 2 3 using priority_queuemax-heap(default)12345678910class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; priority_queue&lt;int&gt; pq(nums.begin(), nums.end()); for (int i = 0; i &lt; k - 1; i++) &#123; pq.pop();//将堆顶元素删除k-1次。 &#125; return pq.top(); &#125;&#125;; min-heap12345678910111213class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq; for (int num : nums) &#123; pq.push(num); if (pq.size() &gt; k) &#123; pq.pop(); &#125; &#125; return pq.top(); &#125;&#125;; using multiset(rbt)min-heap(default)12345678910111213class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; multiset&lt;int&gt; mset; for (int num : nums) &#123; mset.insert(num); if (mset.size() &gt; k) &#123; mset.erase(mset.begin());//multiset没有pop()，只能用erase(it); &#125; &#125; return *mset.begin();//multiset也没有top()，他是 &#125;&#125;; max-heap12345678910class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; multiset&lt;int, greater&lt;int&gt;&gt; mset(nums.begin(), nums.end()); for (int i = 0; i &lt; k - 1; i++) &#123; mset.erase(mset.begin()); &#125; return *mset.begin(); &#125;&#125;; implements a max-heapIn the above we have presented heap solutions using STL. You may also implement your own heap if you are interested. I suggest you to read the Heapsort chapter of Introduction to Algorithms if you are not familiar with it. The following code implements a max-heap. 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; buildMaxHeap(nums); for (int i = 0; i &lt; k - 1; i++) &#123; swap(nums[0], nums[--heapSize]); maxHeapify(nums, 0); &#125; return nums[0]; &#125;private: int heapSize; int left(int i) &#123; return (i &lt;&lt; 1) + 1; &#125; int right(int i) &#123; return (i &lt;&lt; 1) + 2; &#125; void maxHeapify(vector&lt;int&gt;&amp; nums, int i) &#123; int largest = i, l = left(i), r = right(i); if (l &lt; heapSize &amp;&amp; nums[l] &gt; nums[largest]) &#123; largest = l; &#125; if (r &lt; heapSize &amp;&amp; nums[r] &gt; nums[largest]) &#123; largest = r; &#125; if (largest != i) &#123; swap(nums[i], nums[largest]); maxHeapify(nums, largest);//递归 &#125; &#125; void buildMaxHeap(vector&lt;int&gt;&amp; nums) &#123; heapSize = nums.size(); for (int i = (heapSize &gt;&gt; 1) - 1; i &gt;= 0; i--) &#123; maxHeapify(nums, i); &#125; &#125;&#125;; REF最大堆（创建、删除、插入和堆排序）]]></content>
      <categories>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>RBT</tag>
        <tag>STL</tag>
        <tag>Sort</tag>
        <tag>priority_queue</tag>
        <tag>Algorithms library</tag>
        <tag>Heapsort</tag>
        <tag>multiset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 容器篇 std::priority_queue]]></title>
    <url>%2F2019%2F03%2F12%2FC-%E5%AE%B9%E5%99%A8%E7%AF%87-std-priority-queue%2F</url>
    <content type="text"><![CDATA[priority_queueDefined in header &lt;queue> 12345template&lt; class T, class Container = std::vector&lt;T&gt;, class Compare = std::less&lt;typename Container::value_type&gt;&gt; class priority_queue; A container adaptor : O(1) for lookup of the largest element(by default) ; O(logn) for insertion and extraction. Compare: change the ordering, e.g. using std::greater&lt;T> makes the top the smallest. Similar to managing a heap in some random access container, with the benefit of not being able to accidentally invalidate the heap. Example123456789101112131415161718192021222324252627282930313233#include &lt;functional&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;iostream&gt; template&lt;typename T&gt; void print_queue(T&amp; q) &#123; while(!q.empty()) &#123; std::cout &lt;&lt; q.top() &lt;&lt; " "; q.pop(); &#125; std::cout &lt;&lt; '\n';&#125; int main() &#123; std::priority_queue&lt;int&gt; q; //largest element(by default) for(int n : &#123;1,8,5,6,3,4,0,9,7,2&#125;) q.push(n); print_queue(q);//9 8 7 6 5 4 3 2 1 0 std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt; &gt; q2; //the top is the smallest. for(int n : &#123;1,8,5,6,3,4,0,9,7,2&#125;) q2.push(n); print_queue(q2);//0 1 2 3 4 5 6 7 8 9 // Using lambda to compare elements. auto cmp = [](int left, int right) &#123; return (left ^ 1) &lt; (right ^ 1);&#125;; std::priority_queue&lt;int, std::vector&lt;int&gt;, decltype(cmp)&gt; q3(cmp); for(int n : &#123;1,8,5,6,3,4,0,9,7,2&#125;) q3.push(n); print_queue(q3);//8 9 6 7 4 5 2 3 0 1 &#125; decltype[c++11] 分析表达式并得到它的类型，而不计算表达式的值。 1decltype(f()) sum=x;//sum的类型就是函数f的返回类型 如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内） 1234const int ci=0,&amp;cj=ci;decltype(ci) x=0;//x的类型是const intdecltype(cj) y=x;//y的类型是const int&amp;，y绑定到xdecltype(cj) z;//错误。引用必须初始化。 如果decltype使用的表达式不是变量，则返回该表达式对应的结果的类型（是个左值，可能是引用，所以定义的时候需要初始化）。 123int i=42,*p=&amp;i,&amp;r=i;decltype(r+0) b;//r是一个引用，如果想让返回的类型是r所指的类型，必须得把r作为表达式的一部分，r+0就是一个具体的值，而不是引用。decltype(*p) c;//表达式的内容是解引用操作， decltype((var))的结果永远是引用，decltype(var)的结果只有当var是引用时才是引用。因为在c++中，如果为变量加上括号，编译器就会把他当作作为赋值语句左值的表达式。123int i=31;decltype((i)) b;//错。b是int&amp;，必须初始化。decltype(i) e;//正确。r是int，未初始化的。 to be continued… next time to complete whats the meaning of decltype..]]></content>
      <categories>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>Containers library</tag>
        <tag>Sort</tag>
        <tag>priority_queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 面向对象篇 Struct]]></title>
    <url>%2F2019%2F03%2F12%2FC-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AF%87-Struct%2F</url>
    <content type="text"><![CDATA[结构体成员存储对齐规则其实字节对齐的细节和具体编译器实现相关，但一般而言，满足三个准则: struct内每个成员相对struct首地址的offset，都是该成员大小的整数倍。 struct变量的首地址是内部最大成员的倍数; sizeof(struct)为struct最宽基本类型成员大小的整数倍。 准则 1结构(struct)或联合(union)的数据成员，第一个数据成员放在offset为0的地方，每个数据成员存储的起始位置要从该成员(每个成员本身)大小的整数倍开始(比如int在32位机为４字节,则要从４的整数倍地址开始存储)。 123456struct node&#123; char a;//1 int b//4&#125;;sizeof(node)=8 a存放在0offset的位置。b的存储起始位置为1，为了满足对齐原则，int大小为4，b的存储位置应该为4的整数倍，所以要在a后补齐，所以b的存储起始位置为4。所以node大小为8。 准则2 结构体作为成员如果一个结构里有某些结构体成员,则结构体成员要从a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储.)12345678```cppstruct pa&#123; char a;//1 node b;//b内部最大元素大小是4，所以b的起始位置要是4的整倍数.在a后面补位。&#125;sizeof(pa)=12//4+8=12. 准则3 sizeof(struct)结构体的总大小,也就是sizeof的结果,.必须是其内部最大成员的整数倍（结构体成员以最大成员为代表）.不足的要补齐. 123456struct node&#123; double a;//8 char b;//1&#125;sizeof(node)=16//9-&gt;2*8=16 按1,2原则可计算出结果应为9;但结构体大小应为12345678如果编译器中提供了```#pragma pack(n)```，上述对其模式就不适用了，例如设定变量以n字节对齐方式，则上述成员类型对齐宽度（应当也包括收尾对齐）应该选择```成员类型宽度和n中较小者```；## 例子 Q: ```CPP为什么sizeof操作员返回的结构尺寸大于结构成员的总尺寸？ A: 123456789101112131415161718192021222324252627282930313233struct X&#123; short s; /* 2 bytes */ /* 2 padding bytes 准则1。struct内每个成员相对struct首地址的offset，都是该成员大小的整数倍。*/ int i; /* 4 bytes */ char c; /* 1 byte */ /* 3 padding bytes 准则3：sizeof(struct)为struct最宽基本类型成员大小的整数倍*/&#125;;struct Y&#123; int i; /* 4 bytes */ char c; /* 1 byte */ /* 1 padding byte 准则1。struct内每个成员相对struct首地址的offset，都是该成员大小的整数倍。*/ short s; /* 2 bytes */&#125;;struct Z&#123; int i; /* 4 bytes */ short s; /* 2 bytes */ char c; /* 1 byte */ /* 1 padding byte 准则3：sizeof(struct)为struct最宽基本类型成员大小的整数倍*/&#125;;const int sizeX = sizeof(struct X); /* = 12 */const int sizeY = sizeof(struct Y); /* = 8 */const int sizeZ = sizeof(struct Z); /* = 8 */可以通过对齐对成员进行排序来最小化结构的大小（按基本类型中的大小排序）（Z如上例中的结构）。编译器自动对齐的原因：为了提高程序的性能，数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；然而，对齐的内存访问仅需要一次访问。重要说明：C和C ++标准都声明结构对齐是实现定义的。因此，每个编译器可能选择以不同方式对齐数据，从而导致不同且不兼容的数据布局。因此，在处理将由不同编译器使用的库时，了解编译器如何对齐数据非常重要。某些编译器具有命令行设置和/或特殊#pragma 语句来更改结构对齐设置。]]></content>
      <categories>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>OOP</tag>
        <tag>struct</tag>
        <tag>sizeof</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode215. Kth Largest Element in an Array]]></title>
    <url>%2F2019%2F03%2F12%2FLeetCode215-Kth-Largest-Element-in-an-Array%2F</url>
    <content type="text"><![CDATA[Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Example 1: Input: [3,2,1,5,6,4] and k = 2Output: 5Example 2: Input: [3,2,3,1,2,4,5,5,6] and k = 4Output: 4Note:You may assume k is always valid, 1 ≤ k ≤ array’s length. std::sort(),reverse().O(nlogn)12345678class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; sort(nums.begin(),nums.end()); reverse(nums.begin(),nums.end()); return nums[k-1]; &#125;&#125;; Partition.O(n）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;vector&gt;using namespace std;class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; if(nums.empty()||k&gt;nums.size()) return 0; k=nums.size()-k;//从小到大排列后的k QuickSort_Recur(nums,0,nums.size()-1); return nums[k]; &#125; void QuickSort_Recur(vector&lt;int&gt;&amp; nums, int low, int high) &#123; if(low&lt;high) &#123; int index = Partition(nums,low,high);//找到一个基准，并将所有小于基准的数放在基准左边。 QuickSort_Recur(nums,low,index-1); QuickSort_Recur(nums,index+1,high); &#125; &#125; int Partition(vector&lt;int&gt;&amp; nums,int start,int end) &#123; if(start&lt;0||end&gt;=nums.size()) return 0; int pivot = random(start,end); swap(&amp;nums[pivot],&amp;nums[end]);//把基准移到尾部 int left = start -1;//最左边原地划分一个子集 for(int i =start;i&lt;end;i++) &#123; if(nums[i]&lt;nums[end])//如果小于基准就放入子集中 &#123; left++; if(left!=i) swap(&amp;nums[i],&amp;nums[left]); &#125; &#125; left++; swap(&amp;nums[left],&amp;nums[end]);//将最尾部的基准放在左子集的下一个位置 return left;//返回基准 &#125; int random(int min,int max) &#123; int random =rand()%(max-min+1) +min; return random; &#125; void swap(int *in1,int* in2)&#123; int temp=*in1; *in1=*in2; *in2=temp; &#125;&#125;; Heapsortmax-heap：将N个元素塞入一个最大堆，将堆顶元素删除k-1次。堆顶就是要找的第K大的元素。min-heap：将K个最大元素塞入一个最小堆。堆顶就是要找的第K大的元素。在STL中。priority_queue和multiset可以实现最大堆/最小堆。 using priority_queuemin-heap12345678910111213class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq; for (int num : nums) &#123; pq.push(num); if (pq.size() &gt; k) &#123; pq.pop(); &#125; &#125; return pq.top(); &#125;&#125;; max-heap12345678910class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; priority_queue&lt;int&gt; pq(nums.begin(), nums.end()); for (int i = 0; i &lt; k - 1; i++) &#123; pq.pop(); &#125; return pq.top(); &#125;&#125;; using multiset（rbt)min-heap12345678910111213class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; multiset&lt;int&gt; mset; for (int num : nums) &#123; mset.insert(num); if (mset.size() &gt; k) &#123; mset.erase(mset.begin()); &#125; &#125; return *mset.begin(); &#125;&#125;; max-heap12345678910class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; multiset&lt;int, greater&lt;int&gt;&gt; mset(nums.begin(), nums.end()); for (int i = 0; i &lt; k - 1; i++) &#123; mset.erase(mset.begin()); &#125; return *mset.begin(); &#125;&#125;; STL的nth_element和partial_sort(没掌握)1234567891011121314class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; nth_element(nums.begin(), nums.begin() + k - 1, nums.end(), greater&lt;int&gt;()); return nums[k - 1]; &#125;&#125;;class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; partial_sort(nums.begin(), nums.begin() + k, nums.end(), greater&lt;int&gt;()); return nums[k - 1]; &#125;&#125;; 请注意两个内置函数的第二个参数中的1之差。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>RBT</tag>
        <tag>Sort</tag>
        <tag>priority_queue</tag>
        <tag>Algorithms library</tag>
        <tag>Heapsort</tag>
        <tag>multiset</tag>
        <tag>Partition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 语言篇 Pointer to Function]]></title>
    <url>%2F2019%2F03%2F12%2FC-%E8%AF%AD%E8%A8%80%E7%AF%87-Pointer-to-Function%2F</url>
    <content type="text"><![CDATA[pointer to functionInitialized &amp; Implicit Conversion A [pointer to function] can be initialized with an address of a [non-member function] or a [static member function]. [function-to-pointer implicit conversion] 123void f(int);void (*p1)(int) = &amp;f;void (*p2)(int) = f; // same as &amp;f, [function-to-pointer implicit conversion] [this] invokes the [pointed-to function] Unlike [functions] or [references to functions], [pointers to functions] are [objects] and thus can be stored in [arrays, copied, assigned], etc. A [pointer to function] can be used as the [left-hand operand] of the function call operator, [this] invokes the [pointed-to function]: 1234567891011int f(int n)&#123; std::cout &lt;&lt; n &lt;&lt; '\n'; return n * n;&#125; int main()&#123; int (*p)(int) = f;//(int)-&gt;argument type int x = p(7);//p invokes f&#125; DereferencingDereferencing a function pointer yields the [lvalue identifying the pointed-to function]: 1234567891011int f();int (*p)() = f; // pointer p is pointing to fint (&amp;r)() = *p; // the [lvalue that identifies f] is bound to a [reference]r(); // function f invoked through [lvalue reference](*p)(); // function f invoked through the [function lvalue]p(); // function f invoked directly through the [pointer] Initialized from an overloadA pointer to function may be initialized from an overload set which may include functions, function template specializations, and function templates, if only one overload matches the type of the pointer (see address of an overloaded function for more detail): 1234567template&lt;typename T&gt; T f(T n) &#123; return n; &#125;double f(double n) &#123; return n; &#125; int main()&#123; int (*p)(int) = f; // instantiates and selects f&lt;int&gt;&#125; Equality comparison operators are defined for pointers to functions (they compare equal if pointing to the same function). to be continued…]]></content>
      <categories>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>pointer</tag>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 算法篇 std::sort]]></title>
    <url>%2F2019%2F03%2F11%2FC-%E7%AE%97%E6%B3%95%E7%AF%87-std-sort%2F</url>
    <content type="text"><![CDATA[STL Defined in header &lt;algorithm&gt; template&lt; class RandomIt &gt; void sort( RandomIt first, RandomIt last ); (until C++20) template&lt; class RandomIt &gt; constexpr void sort( RandomIt first, RandomIt last ); (since C++20) template&lt; class ExecutionPolicy, class RandomIt &gt; void sort( ExecutionPolicy&amp;&amp; policy, RandomIt first, RandomIt last ); (since C++17) template&lt; class RandomIt, class Compare &gt; void sort( RandomIt first, RandomIt last, Compare comp ); (until C++20) template&lt; class RandomIt, class Compare &gt; constexpr void sort( RandomIt first, RandomIt last, Compare comp ); (since C++20) template&lt; class ExecutionPolicy, class RandomIt, class Compare &gt; void sort( ExecutionPolicy&amp;&amp; policy, RandomIt first, RandomIt last, Compare comp ); (since C++17) Sorts the elements in the range [first, last) in ascending order. The order of equal elements is not guaranteed to be preserved. 1) Elements are compared using operator&lt;. 3) Elements are compared using the given binary comparison function comp. 2,4) Same as (1,3), but executed according to policy. These overloads do not participate in overload resolution unless std::is_execution_policy_v&lt;std::decay_t&gt; is true Parameters first, last - the range of elements to sort policy - the execution policy to use. See execution policy for details. comp - comparison function object (i.e. an object that satisfies the requirements of Compare ) which returns true if the first argument is less than (i.e. is ordered before) the second. 若第一参数小于（即先序于）第二参数则返回 true。 The signature of the comparison function should be equivalent to the following: 1bool cmp(const Type1 &amp;a, const Type2 &amp;b); While the signature does not need to have const &amp;, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2regardless of value category (thus, Type1 &amp; is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)).虽然签名不必有 const &amp; ，函数也不能修改传递给它的对象，而且必须接受（可为 const 的）类型 Type1 与 Type2 的值，无关乎值类别（从而不允许 Type1 &amp; ，亦不允许 Type1 ，除非 Type1 的移动等价于复制(C++11 起)）。 The types Type1 and Type2 must be such that an object of type RandomIt can be dereferenced and then implicitly converted to both of them. 类型 Type1 与 Type2 必须使得 RandomIt 类型的对象能在解引用后隐式转换到这两个类型。 Complexity O(N·log(N)), where N = std::distance(first, last) comparisons on average. (until C++11) O(N·log(N)), where N = std::distance(first, last) comparisons. (since C++11) Example123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;array&gt;#include &lt;iostream&gt; int main()&#123; std::array&lt;int, 10&gt; s = &#123;5, 7, 4, 2, 8, 6, 1, 9, 0, 3&#125;; // sort using the default operator&lt; std::sort(s.begin(), s.end()); for (auto a : s) &#123; std::cout &lt;&lt; a &lt;&lt; " "; &#125; std::cout &lt;&lt; '\n'; // sort using a standard library compare function object std::sort(s.begin(), s.end(), std::greater&lt;int&gt;()); for (auto a : s) &#123; std::cout &lt;&lt; a &lt;&lt; " "; &#125; std::cout &lt;&lt; '\n'; // sort using a custom function object struct &#123; bool operator()(int a, int b) const &#123; return a &lt; b; &#125; &#125; customLess; std::sort(s.begin(), s.end(), customLess); for (auto a : s) &#123; std::cout &lt;&lt; a &lt;&lt; " "; &#125; std::cout &lt;&lt; '\n'; // sort using a lambda expression std::sort(s.begin(), s.end(), [](int a, int b) &#123; return a &gt; b; &#125;); for (auto a : s) &#123; std::cout &lt;&lt; a &lt;&lt; " "; &#125; std::cout &lt;&lt; '\n';&#125; Output: 12340 1 2 3 4 5 6 7 8 9 9 8 7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7 8 9 9 8 7 6 5 4 3 2 1 0 how to implement ? Quicksort Also known as (partition-exchange sort). Average : O(nlogn), Worst : O(n^2)，但一般O(n^2)不常见。 Faster than other O(nlogn) algorithms，因为Quicksort的inner loop在大部分的架构上很有效率被实现。 Algorithm divide and conquer algorithm: 把一个序列分为两个子序列，再递归地解决这些子问题，最后这些子问题地组合为原问题的解。 The steps are: Pick a pivot Partitioning Recursively PartitionEasy-version(S:Ω(n))Pseudocode:123456789101112function quicksort(q) var list less, pivotList, greater if length(q) ≤ 1 &#123; return q &#125; else &#123; select a pivot value pivot from q for each x in q except the pivot element if x &lt; pivot then add x to less if x ≥ pivot then add x to greater add pivot to pivotList return concatenate(quicksort(less), pivotList, quicksort(greater)) &#125; 需要Ω(n)的额外存储空间，跟Mergesort一样不好。额外需要的存储器空间配置，在实际上的实现，也会极度影响速度和缓存的性能。 In-place-version(S:O(log n))有一个比较复杂使用原地（in-place）分区算法的版本，且在好的基准选择上，平均可以达到O(log n)空间的使用复杂度。 Pseudocode:12345678910function partition(a, left, right, pivotIndex) pivotValue := a[pivotIndex] swap(a[pivotIndex], a[right]) // 把pivot移到結尾 storeIndex := left for i from left to right-1 if a[i] &lt;＝ pivotValue swap(a[storeIndex], a[i]) storeIndex := storeIndex + 1 swap(a[right], a[storeIndex]) // 把pivot移到它最後的地方 return storeIndex 这是原地分区算法，它分区了标示为”左边（left）”和”右边（right）”的序列部分，借由移动小于a[pivotIndex]的所有元素到子序列的开头，留下所有大于或等于的元素接在他们后面。在这个过程它也为基准元素找寻最后摆放的位置，也就是它回传的值。它暂时地把基准元素移到子序列的结尾，而不会被前述方式影响到。由于算法只使用交换，因此最后的数列与原先的数列拥有一样的元素。要注意的是，一个元素在到达它的最后位置前，可能会被交换很多次。一旦我们有了这个分区算法，要写快速排列本身就很容易： Pseudocode:123456procedure quicksort(a, left, right) if right &gt; left select a pivot value a[pivotIndex] pivotNewIndex := partition(a, left, right, pivotIndex) quicksort(a, left, pivotNewIndex-1) quicksort(a, pivotNewIndex+1, right) ImplementationOne-way scanningarr = [3,7,8,5,2,1,9,5,4] 从左到右（除了最后的基准元素），循环移动小于基准元素 5 的所有元素到数组开头，留下大于等于基准元素的元素接在后面。在这个过程它也为基准元素找寻最后摆放的位置。 In C++:12345678910111213141516171819202122232425262728293031323334353637383940414243444546int random(int min,int max)&#123; int random =rand()%(max-min+1) +min; return random;&#125;void swap(int *in1,int* in2)&#123; int temp=*in1; *in1=*in2; *in2=temp;&#125;int Partition(vector&lt;int&gt;&amp; nums,int start,int end)&#123; if(start&lt;0||end&gt;=nums.size()) return 0; int pivot = random(start,end); swap(&amp;nums[pivot],&amp;nums[end]);//把基准移到尾部 int left = start -1;//最左边原地划分一个子集 for(int i =start;i&lt;end;i++) &#123; if(nums[i]&lt;nums[end])//如果小于基准就放入子集中 &#123; left++; if(left!=i) swap(&amp;nums[i],&amp;nums[left]); &#125; &#125; left++; swap(&amp;nums[left],&amp;nums[end]);//将最尾部的基准放在左子集的下一个位置 return left;//返回基准&#125;void QuickSort_Recur(vector&lt;int&gt;&amp; nums, int low, int high)&#123; if(low&lt;high) &#123; int index = Partition(nums,low,high);//找到一个基准，并将所有小于基准的数放在基准左边。 QuickSort_Recur(nums,low,index-1); QuickSort_Recur(nums,index+1,high); &#125;&#125; Two-way scanningvar items = [4, 2, 6, 5, 3, 9]; In the previous example, the array becomes [4, 2, 3, 5, 6, 9] after one partition and the index returned is 4 (the last spot of the left pointer). After that, the left side of the overall array (items 0 through 3) is partitioned, as in the following figure. In C++:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#define Max(a, b) ( (a &gt; b) ? a : b )#define Min(a, b) ( (a &lt; b) ? a : b )#define RANDOM_INIT() srand(time(NULL))#define RANDOM(L, R) (L + rand() % ((R) - (L) + 1)) // gen a random integer in [L, R]/*** swap 2-element, orignal value */template&lt;typename T&gt; static inline void swap(T &amp;x, T &amp;y) &#123; T _t(x); x = y; y = _t; &#125; /*** the quick-sort partition routine*/template&lt;typename T&gt; static int partition_(T list[],int begin, int end) &#123; int pivot_idx = RANDOM(begin,end); T pivot = list[pivot_idx]; swap(list[begin], list[pivot_idx]); int i = begin + 1;//low int j = end;//high while(i &lt;= j) &#123; while((i &lt;= end) &amp;&amp; (list[i] &lt;= pivot)) i++; while((j &gt;= begin) &amp;&amp; (list[j] &gt; pivot)) j--; if(i &lt; j) swap(list[i],list[j]); &#125; swap(list[begin],list[j]); return j; // final pivot position &#125;/*** quick sort an array of range [begin, end]*/template&lt;typename T&gt; static void quicksort(T list[],int begin,int end) &#123; if( begin &lt; end) &#123; int pivot_idx = partition_&lt;T&gt;(list, begin, end); quicksort(list, begin, pivot_idx-1); quicksort(list, pivot_idx+1, end); &#125; &#125; Optimizations BST : 快速排序是二叉查找树（二叉搜索树）的一个空间最优化版本。不是循序地把数据项插入到一个明确的树中，而是由快速排序组织这些数据项到一个由递归调用所隐含的树中。这两个算法完全地产生相同的比较次数，但是顺序不同。对于排序算法的稳定性指标，原地分割版本的快速排序算法是不稳定的。其他变种是可以通过牺牲性能和空间来维护稳定性的。 Heapsort : Worst:O(nlog n)的优势，堆排通常比快排慢，但是快排也有最差情况发生O(n^2)。如果事先知道可以用堆排，就直接使用堆排。堆排序也拥有重要的特点，仅使用固定额外的空间（堆排序是原地排序），而即使是最佳的快速排序变化版本也需要 O(log n)的空间。然而，堆排序需要有效率的随机存取才能变成可行。 Mergesort : Worst:O(nlog n)的优势。不像快排或堆排，归排是一个稳定排序，且可以轻易地被采用在linked list和存储在慢速访问媒体上(像是磁盘存储或网络连接存储的非常巨大数列)。尽管快排可以被重新改写使用在链串列上，但是它通常会因为无法随机存取而导致差的基准选择。归排的主要缺点，是在最佳情况下需要O(n)额外的空间。 Reference Quicksort From Wikipedia 对partition的优化 快速排序]]></content>
      <categories>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>Sort</tag>
        <tag>Algorithms library</tag>
        <tag>Partition</tag>
        <tag>Quicksort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode169. Majority Element]]></title>
    <url>%2F2019%2F03%2F10%2FLeetcode169-Majority-Element%2F</url>
    <content type="text"><![CDATA[数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 Quicksort , O(nlogn) , 改变数组快排std::sort.从小到大的数组。O(nlogn).找到有序数组的中位数。计算他的个数。如果大于数组长度的一半就是要找的数字，否则返回0 这种做法会导致数组改变。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;array&gt;using namespace std;namespace yy&#123; int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; if (numbers.empty()) return 0; sort(numbers.begin(), numbers.end()); int mid = numbers[numbers.size() / 2]; int count = 0; for (int a = 0; a&lt;numbers.size(); a++) &#123; if (numbers[a] == mid) count++; &#125; if (count&gt;numbers.size()/2) return mid; return 0; &#125; &#125;int main()&#123; string str; getline(cin, str); istringstream input(str); vector&lt;int&gt; v; char a[100]; // 注意：下列循环在从 getline() 返回的流上的 // std::ios_base::operator bool() 返回 false 时终止 while(input.getline(&amp;a[0], 100, ',') ) &#123; v.push_back(atoi(a)); &#125; cout&lt;&lt;yy::MoreThanHalfNum_Solution(v); return 0;&#125; 计数法 ，O(n) ，不改变数组O(n)的做法。这个数字出现的次数一定比其它所有数字出现的次数多。设两个变量，result存放当前数字，times存放这个数字出现的次数。如果出现次数为0，就设置为下个数字，并且更新times为1；如果下个数字不等于result，次数减一；如果下个数字等于result，times加一。如果这个数字是出现次数超过了一半的，那么最后一次设置的result一定是要找的数字。 最后再检查result出现的次数是不是超过了数组一半。 12345678910111213141516171819202122232425262728293031namespace yy2 &#123; int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; if (numbers.empty()) return 0; int result=numbers[0]; int times=1; for (int i = 0; i &lt; numbers.size(); i++) &#123; if (times == 0)//说明上一个不是要找的出现最多元素（至少times要为1），设置为下一个 &#123; result = numbers[i]; times = 1; &#125; else if (result == numbers[i]) &#123; times++; &#125; else times--; &#125;//最后一个设置为result的要么是出现最多的，要么不是，所以要验证。 int count = 0; for (int i=0; i &lt; numbers.size(); i++) &#123; if (numbers[i] == result) count++; &#125; return count &gt; numbers.size() / 2 ? result : 0; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Quicksort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 语言篇 Range-For：Observing and Modifying [c++11]]]></title>
    <url>%2F2019%2F03%2F10%2FC-%E8%AF%AD%E8%A8%80%E7%AF%87-Range-For-c-11%2F</url>
    <content type="text"><![CDATA[Range-For[c++11] What is the correct way of using C++11’s range-based for?What syntax should be used? for (auto elem : container), or for (auto&amp; elem : container) or for (const auto&amp; elem : container)? Or some other? 答案直接在Generic code 部分。下面是解释： There’re some difference between observing the elements in the continer vs. modifying them in place. Observingcheap-to-copy :by value适用简单类型的元素，比如 int,double 1for (auto elem : container) for (auto x : v) 简单类型observing “int” in “vector”. 123vector&lt;int&gt; v = &#123;1, 3, 5, 7, 9&#125;;for (auto x : v) cout &lt;&lt; x &lt;&lt; ' '; output: 11 3 5 7 9 general case : by const referencefor (auto x : v) 复杂类型复杂类型的by value(效率低，会调用拷贝构造。) observing “customclass_type” in “vector”. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// A sample test class, with custom copy semantics.class X&#123;public: X() : m_data(0) &#123;&#125; X(int data) : m_data(data) &#123;&#125; ~X() &#123;&#125; X(const X&amp; other) : m_data(other.m_data) &#123; cout &lt;&lt; "X copy ctor.\n"; &#125; X&amp; operator=(const X&amp; other) &#123; m_data = other.m_data; cout &lt;&lt; "X copy assign.\n"; return *this; &#125; int Get() const &#123; return m_data; &#125;private: int m_data;&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; os, const X&amp; x)&#123; os &lt;&lt; x.Get(); return os;&#125;vector&lt;X&gt; v = &#123;1, 3, 5, 7, 9&#125;;cout &lt;&lt; "\nElements:\n";for (auto x : v)&#123; cout &lt;&lt; x &lt;&lt; ' ';&#125; output: 在vector初始化时，拷贝构造函数 被调用了。 1234567Elements:X copy ctor.1 X copy ctor.3 X copy ctor.5 X copy ctor.7 X copy ctor.9 在range-based for loop iterations的时候，采用的是by value的方法，初始化容器中每个元素时，copy constructor 被调用了。这样做很低效，因为我们只想观察容器中的元素,而不是想拷贝一个临时对象。（e.g. if these elements are instances of std::string, heap memory allocations can be done, with expensive trips to the memory manager, etc.） for (const auto&amp; x : v)所以最好的观测方法是常量引用传递 const auto &amp; 123456vector&lt;X&gt; v = &#123;1, 3, 5, 7, 9&#125;;cout &lt;&lt; "\nElements:\n";for (const auto&amp; x : v)&#123; cout &lt;&lt; x &lt;&lt; ' ';&#125; output:没有 拷贝构造函数 调用。更加高效。12Elements:1 3 5 7 9 Modifying如果要修改容器中的元素， for (auto elem : container) 或者 for (const auto&amp; elem : container) 的写法是错误的。 for (auto elem : container)修改的是拷贝局部临时变量的值，不是原始数据123456vector&lt;int&gt; v = &#123;1, 3, 5, 7, 9&#125;;for (auto x : v) // &lt;-- capture by value (copy) x *= 10; // &lt;-- a local temporary copy ("x") is modified, // *not* the original vector element.for (auto x : v) cout &lt;&lt; x &lt;&lt; ' '; output11 3 5 7 9 for (const auto&amp; elem : container)修改常量引用会导致编译不通过123TestRangeFor.cpp:138:11: error: assignment of read-only reference 'x' x *= 10; ^ for (auto&amp; x : v)正确方法是非常量引用 123456789vector&lt;string&gt; v = &#123;"Bob", "Jeff", "Connie"&#125;;// Modify elements in place: use "auto &amp;"for (auto&amp; x : v) x = "Hi " + x + "!";// Output elements (*observing* --&gt; use "const auto&amp;")for (const auto&amp; x : v) cout &lt;&lt; x &lt;&lt; ' '; output 1Hi Bob! Hi Jeff! Hi Connie! Case of Proxy Iterator需求：想通过非常量引用修改容器中bool的状态。 for (auto&amp; x : v)123vector&lt;bool&gt; v = &#123;true, false, false, true&#125;;for (auto&amp; x : v) x = !x; 编译不通过 12345TestRangeFor.cpp:168:20: error: invalid initialization of non-const reference of type 'std::_Bit_reference&amp;' from an rvalue of type 'std::_Bit_iterator::reference &#123;aka std::_Bit_reference&#125;' for (auto&amp; x : v) ^ 为bool特化的std::vector模板，是由把bool打包优化空间后实现的，每个boolean值占1bit,8个boolean才占1byte。因为不能返回一个单独的bit的reference，所以vector使用了一个proxy iterator设计模式。proxy iterator在解引用的时候，不产生普通的bool&amp;，而是返回(by value)一个临时对象，这个对象是一个可以表达bool的proxy class。 REF: The problem is that std::vector template is specialized for bool, with an implementation that packs the bools to optimize space (each boolean value is stored in one bit, eight “boolean” bits in a byte). Because of that (since it’s not possible to return a reference to a single bit), vector uses a so called “proxy iterator” pattern. A “proxy iterator” is an iterator that, when dereferenced, does not yield an ordinary bool &amp;, but instead returns (by value) a temporary object, which is a proxy class convertible to bool. (See also this question and related answers here on StackOverflow.) for (auto&amp;&amp; x : v)12345678vector&lt;bool&gt; v = &#123;true, false, false, true&#125;;// Invert boolean statusfor (auto&amp;&amp; x : v) // &lt;-- note use of "auto&amp;&amp;" for proxy iterators x = !x;// Print new element valuescout &lt;&lt; boolalpha; for (const auto&amp; x : v)// 遵从observing的const auto&amp; cout &lt;&lt; x &lt;&lt; ' '; output 1false true true false proxy iterators也遵从observing的for (const auto&amp; elem : container) for (auto&amp;&amp; elem : container)也适用ordinary (non-proxy) iterators,比如vector&lt;int>或者vector&lt;string>。 Summary If the objects are cheap to copy (like ints, doubles, etc.) OR NEED to make a local copy. 1for (auto elem : container) // capture by value For observing the complex elements (not need to copy) 1for (const auto&amp; elem : container) // capture by const reference For modifying the elements in place 1for (auto&amp; elem : container) // capture by (non-const) reference If the container uses “proxy iterators” (like std::vector&lt;bool>) 1for (auto&amp;&amp; elem : container) // capture by &amp;&amp; Generic code For observing the elements 1for (const auto&amp; elem : container) // capture by const reference For modifying the elements in place 1for (auto&amp;&amp; elem : container) // capture by &amp;&amp;]]></content>
      <categories>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>const</tag>
        <tag>reference</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2019%2F03%2F08%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Inner Sort所有数据已经读入内存，在内存中进行排序的算法。排序过程不需要对磁盘进行读写。辅助空间也直接存于内存之中。 Comparison Sorts Insertion Sorts Insertion Sort 每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。 不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千，那么插入排序还是一个不错的选择。 时间：Ω(n)。 Θ(n^2)。 O(n^2)。 空间：O(1)。 Shell Sort (improved InsertionSort) 时间：Ω(nlogn)。 Θ(nlogn^2)。 O(nlogn^2)。 空间：O(1)。 Exchange Sorts Bubble Sort 时间：Ω(n)。 Θ(n^2)。 O(n^2)。 空间：O(1)。 Quick Sort(Divide and Conquer) 快排是平均状态下速度最快的一种排序算法。随机选定⼀个元素作为轴值，利⽤该轴值将数组分为左右两部分，左边元素都⽐轴值⼩，右边元素都⽐轴值⼤，但它们不是完全排序的。在此基础上，分别对左右两部分分别递归调⽤quick sort，使得左右部分完全排序。 时间：Ω(nlogn) 。Θ(nlogn) 。O(n^2) 。 空间：O(log(n)) 不稳定 ​ Selection Sorts Selection Sort 每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。 选择排序是不稳定的排序方法。 时间：Ω(n^2)。 Θ(n^2)。 O(n^2)。 空间：O(1)。 Heap Sort Heap,将输入array变成最大/小值堆。 堆的弹出操作：将堆顶元素与堆末元素交换，堆的⼤⼩减⼀，向下移动新的堆顶以维护堆的性质。相当于每次将剩余的最⼤元素移动到数组的最右边，重复这样的操作最终就能获得由⼩到⼤排序的数组。 时间：Ω(nlogn) 。Θ(nlogn)。 O(nlogn)。 初次建堆的时间复杂度O(n)，删除堆顶元素并维护堆的性质需要O(logn)，这样的操作⼀共进⾏n次，故最终时间复杂度O(nlogn) 空间：O(1)。 Tree Sort 时间：Ω(nlogn)。 Θ(nlogn)。 O(n^2)。 空间：O(n)。 Timsort(mergeSort_insetionSort) Merge Sort(Divide and Conquer) 不依赖于随机读写，因此具有很强的普适性，适⽤于list。 将线性数据结构（如array, vector或list ）分为两个部分，对两部分分别进⾏排序，排序完成后，再将各⾃排序好的两个部分合并还原成⼀个有序数组。 时间：Ω(nlogn) 。Θ(nlogn)。 O(nlogn)。 空间：O(n)。 Non-Comparison Sorts Bucket Sort 不需要数据之间的两两比较，但需要事先知道数组的一些具体情况。 将数据根据其大小，放入合适的桶容器中，再依次从桶中取出，形成有序序列。 桶排序适用于知道待排序数组大小范围的情况。 时间：Ω(n+k)。 Θ(n+k)。 O(n^2)。 空间：O(n)。 Radix Sort 不需要数据之间的两两比较，但需要事先知道数组的一些具体情况。 时间：Ω(nk)。 Θ(nk)。 O(nk) 。 空间：O(n+k)。 Counting Sort 时间：Ω(n+k)。 Θ(n+k)。 O(n+k) 。 空间：O(k)。 Outer Sort内存中无法保存全部数据，需要磁盘访问，每次读入部分数据到内存进行排序。外排序算法的核⼼思路在于把⽂件分块读到内存，在内存中对每块⽂件依次进⾏排序，最后合并排序后的各块数据，依次按顺序写回⽂件。相⽐于内排序，外排序需要进⾏多次磁盘读写，因此执⾏效率往往低于内排序，时间主要花费于磁盘读写上。 Quick Selection利用快排的思想，将数组依照⼀个轴值分割成两个部分，左边元素都⽐轴值⼩，右边元素都⽐轴值⼤。由于轴值下标已知，则可以判断所求元素落在数组的哪⼀部分，并在那⼀部分继续进⾏上述操作，直⾄找到该元素。 平均O(n)时间内从⼀个⽆序数组中返回第k⼤的元素。 与快排不同，由于快速选择算法只在乎所求元素所在的那⼀部分，故效率可以从O(nlogn)进⼀步提升⾄O(n)。 Core Mind 假设⽂件需要分成k块读⼊，需要从⼩到⼤进⾏排序： 1) 依次读⼊每个⽂件块，在内存中对当前⽂件块进⾏排序(应⽤恰当的内排序算法)。此时，每块⽂件相当于⼀个由⼩到⼤排列的有序队列 2) 在内存中建⽴⼀个最⼩值堆，读⼊每块⽂件的队列头 3) 弹出堆顶元素，如果元素来⾃第i块，则从第i块⽂件中补充⼀个元素到最⼩值堆。弹出的元素暂存⾄临时数组 4) 当临时数组存满时，将数组写⾄磁盘，并清空数组内容。 5) 重复过程3)， 4)，直⾄所有⽂件块读取完毕 HeapMethod Add O(logN) Remove O(logN） Min/Max O(1) Build heap O(n) Heap sort O(nlogn) Implementation left child : i*2 right chilf: i*2+1 STL std::priority_queue Example Merge K Sorted List K-th Largest Closest to Origin Binary SortOrdered linear containerRecursion start + 1 &lt; end left + (right - left) / 2 A[mid] == , &lt; , &gt; A[start/end] == target Programming Pearls A generic binary search template Scalability &amp; Memory LimitsDivide &amp; ConquerHash functionHash table©All rights reserved by lightmare.cn]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Sort</tag>
        <tag>Heapsort</tag>
        <tag>Quicksort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 面向对象篇 Static members]]></title>
    <url>%2F2019%2F03%2F08%2FC-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AF%87-Static-members%2F</url>
    <content type="text"><![CDATA[In class definition：static Inside a class definition, the keyword static [declares] members that are not bound to class instances. Outside a class definition, it has a different meaning: see storage duration. Syntax [ declaration ]12static data_member (1) //脱离了对象这个概念，比如利率。static member_function (2) //没有this指针，只能处理static 数据。 Explanation Static members of a class are [not associated] with the [objects of the class]: they are independent variables with static [or thread (since C++11) ]storage duration or regular functions. The static keyword is only used with the [declaration] of a static member, inside the class definition, Not with the [definition] of that static member: 12class X &#123; static int n; &#125;; // declaration (uses 'static')int X::n = 1; // definition (does not use 'static') The declaration inside the class body is not a definition and may declare the member to be of incomplete type (other than void), including the type in which the member is declared: 123456789101112struct Foo;struct S&#123; static int a[]; // declaration, incomplete type static Foo x; // declaration, incomplete type static S s; // declaration, incomplete type (inside its own definition)&#125;; int S::a[10]; // definition, complete typestruct Foo &#123;&#125;;Foo S::x; // definition, complete typeS S::s; // definition, complete type However, if the [declaration] uses constexpr [or inline (since C++17)] specifier, the member must be declared to have complete type.(since C++11) To refer to a static member m of class T 通过类名调用。T::m 通过静态对象调用。[E.m] or [E-&gt;m], where E is an expression that evaluates to [T] or [T*] respectively. 1234567891011121314151617181920class Account&#123; public: static double m_rate;//declaration 静态数据变量 static void set_rate(const double&amp; x)//declaration 静态成员函数 &#123; m_rate = x; &#125;&#125;; double Account::m_rate = 8.0;// definitionint main()&#123; Account::set_rate(5.0);//通过类名调用 Account a; a.set_rate(7.0);//通过对象调用 &#125; Static members obey the class member access rules (private, protected, public). Static member functions Static member functions are not associated with any object. When called, they have [no this pointer]. Static member functions[ cannot be virtual, const, or volatile]. The address of a static member function may be stored in a regular pointer to function, but not in a pointer to member function. non-static member functions：有一个不可以写出来的隐藏参数指针this，代表被调用对象的地址。 1234567891011class complex&#123; public: double real() const&#123;return this-&gt;re;&#125;//被调用对象的地址 private: double re,im;&#125;complex c1,c2,c3;cout&lt;&lt;c1.real();cout&lt;&lt;complex::real(&amp;c1);//this指针 Static data members Static data members are not associated with any object. They exist even if no objects of the class have been defined. There is only one instance of the static data member in the entire program with static storage duration, unless the keyword thread_local is used, in which case there is one such object per thread with thread storage duration (since C++11). Static data members cannot be mutable.(mutable: permits modification of the class member declared mutable even if the containing object is declared const.) Static data members of a class in namespace scope have external linkage if the class itself has external linkage (i.e. is not a member of unnamed namespace). Local classes (classes defined inside functions) and unnamed classes, including member classes of unnamed classes, cannot have static data members. Constant static members（没掌握If a static data member of integral or enumeration type is declared const (and not volatile), it can be initialized with an initializer in which every expression is a constant expression, right inside the class definition: 1234567struct X&#123; const static int n = 1; const static int m&#123;2&#125;; // since C++11 const static int k;&#125;;const int X::k = 3; c++ 11If a static data member of LiteralType is declared constexpr, it must be initialized with an initializer in which every expression is a constant expression, right inside the class definition: 12345struct X &#123; constexpr static int arr[] = &#123; 1, 2, 3 &#125;; // OK constexpr static std::complex&lt;double&gt; n = &#123;1,2&#125;; // OK constexpr static int k; // Error: constexpr static requires an initializer&#125;; If a const non-inline (since C++17) static data member or a constexpr static data member (since C++11) is odr-used, a definition at namespace scope is still required, but it cannot have an initializer. This definition is deprecated forconstexpr data members (since C++17). 1234567struct X &#123; static const int n = 1; static constexpr int m = 4;&#125;;const int *p = &amp;X::n, *q = &amp;X::m; // X::n and X::m are odr-usedconst int X::n; // … so a definition is necessaryconstexpr int X::m; // … (except for X::m in C++17) to be continued… need to review…]]></content>
      <categories>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>OOP</tag>
        <tag>static</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 语言篇 Inline]]></title>
    <url>%2F2019%2F03%2F07%2FC-%E8%AF%AD%E8%A8%80%E7%AF%87-Inline%2F</url>
    <content type="text"><![CDATA[Inline1.C/C++为了解决频繁调用小函数消耗栈空间的问题，引入内联函数。栈空间就是存放局部数据的内存空间。大量调用函数会造成栈空间不足而程序出错，inline避免了调用函数对栈内存重复开辟所带来的消耗。 123456789101112131415161718192021222324include &lt;string&gt;using std::string;include &lt;iostream&gt;using std::cout; using std::endl;//inline version: find the shorter of two stringsinline const string &amp;shorterString(const string &amp;s1, const string &amp;s2)&#123; return s1.size() &lt;= s2.size() ? s1 : s2;&#125;int main()&#123; string s1("successes"), s2("failure"); cout &lt;&lt; shorterString(s1, s2) &lt;&lt; endl; // call the size member of the string returned by shorterString cout &lt;&lt; shorterString(s1, s2).size() &lt;&lt; endl; // equivalent code as generated by the call to inline version // of shorterString cout &lt;&lt; (s1.size() &lt; s2.size() ? s1 : s2) &lt;&lt; endl; return 0;&#125; 2.inline使用限制：只能是小函数，不能包含复杂的结构控制语句，不能是递归函数。如果inline函数体内代码多或者出现循环，执行代码的时间比函数调用的开销大，那么内联的效率很低。另外，每次调用inline函数都要复制代码，使程序总代码量增大，消耗内存。 3.inline只是对编译器的建议，最后是否内联，看编译器的意思，如果不复杂就会在调用点展开，真正内联。并不是声明了内联就会内联。 4.建议inline函数的定义放在头文件中。因为在不同的单元都会调用内联函数，所以放在头文件中最合适。声明和定义要一致，最好定义和声明是一样的，如果不一样，由编译器决定。内联函数最好放在文件头。 1234567891011121314151617181920212223// 头文件ifndef EXAMPLE_Hdefine EXAMPLE_H// 包含于多个源文件的函数必须为 inlineinline int sum(int a, int b) &#123; return a + b;&#125;endif// 源文件 #2include "example.h"int a()&#123; return sum(1, 2);&#125;// 源文件 #1include "example.h"int b()&#123; return sum(3, 4);&#125; 5.类中、结构体、联合中定义的函数，不管是成员函数还是非成员的友元函数，都为隐式的inline函数，即缺省都是内联的。如果未在类内给出定义，又想内联该函数，在类外要加inline。 直接在类声明中定义成员函数，虽然书写方便，但是不是很好的编程风格。 1234class A&#123; public:void Foo(int x, int y) &#123; &#125; // 自动地成为内联函数&#125; 应该改成： 12345678// 头文件class A&#123; public: void Foo(int x, int y);&#125;// 定义文件inline void A::Foo(int x, int y)&#123;&#125; 6.inline 必须和函数定义体放在一起才能起作用，跟声明放在一起没有作用。所以inline是一种用于实现的关键字，而不是用于声明的关键字。声明和定义不可以混为一谈，用户没有必要知道函数是否需要内联。 7.类的构造函数和析构函数会隐藏一些行为，比如执行了基类或者成员对象的构造函数或析构函数。不要将构造/析构函数的定义体放在声明中，编译器会根据函数的定义体，自动取消不值得的内联，进一步说明了inline不应该在函数的声明中。]]></content>
      <categories>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>inline</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习C++，道阻且长。]]></title>
    <url>%2F2019%2F03%2F03%2FC%2B%2B%E7%AC%94%E8%AE%B0%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[尽量自己写笔记。主要参考《cpp primer》、cppreference.com和博客。 C++基础语言 inline cv限定符 | keyword: const , mutable 类外的static pointer to function | keyword: Initialized &amp; Implicit Conversion, Dereferencing, the lvalue identifying the pointed-to function,overload [c++11]range-for中的遍历和修改 | keyword: proxy iterators, by value, const by reference constexpr | 指定变量或函数的值能出现在常量表达式中[c++11] 面向对象程序设计 OOP Static members Union | keyword: [largest data] member, implementation-defined, Member allocating, Conctors and Dectors of members, Member lifetime, Anonymous unions, Union-like classes Struct | 1.struct内每个成员相对struct首地址的offset，都是该成员大小的整数倍；2.struct变量的首地址是内部最大成员的倍数;3.sizeof(struct)为struct最宽基本类型成员大小的整数倍。 标准库具名要求 Named requirements keyword: FunctionObject, Predicate, BinaryPredicate, Compare | 容器库Container adaptors std::priority_queue | next time to complete whats the meaning of decltype..算法库 Sorting operations 排序算法的总结 std::sort |keyword: quicksort/in-place partition/one-way/two-way/O(n) 不需要额外空间 std::nth_element | to be conitued… Heap operations std::sort_heap | 用stl的优先队列和红黑树multiset实现。一个implements a max-heap的例子。 Numeric operations iota[c++11] 工具库 仿函数 | to be continued.. lambda表达式[c++11] IO库 IO库 to be continued…]]></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode51. N-Queens]]></title>
    <url>%2F2019%2F03%2F03%2FLeetCode51-N-Queens%2F</url>
    <content type="text"><![CDATA[The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens’ placement, where &#39;Q&#39; and &#39;.&#39; both indicate a queen and an empty space respectively. Example: 12345678910111213Input: 4Output: [ [".Q..", // Solution 1 "...Q", "Q...", "..Q."], ["..Q.", // Solution 2 "Q...", "...Q", ".Q.."]]Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above. 回溯法将一行string看做一个排列。初始都设为”.“。然后从col=0基于判断开始排列。判断函数是（1.col不重复。2.45°不重复。3.135°不重复。）满足这三个条件就设为”Q”。开始递归。递归的变量是row++。递归条件是row==n。结束递归之后。要回溯，保证前面的col的排列不变，都是”.” 细节验证的时候，不用验证row上的Q只有一个。因为递归的参数是row+1。已经保证了。 N皇后：注意循环是指排列的col变动，从0开始；递归是指下一个string，row的变动。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; vector&lt;vector&lt;string&gt;&gt; ret; vector&lt;string&gt; myqueen(n,string(n,'.')); Helper(ret,myqueen,n,0); return ret; &#125; void Helper(vector&lt;vector&lt;string&gt;&gt;&amp;ret,vector&lt;string&gt; &amp;myqueen,int n,int row)&#123; if(row==n) &#123; ret.push_back(myqueen); return; &#125; for(int col=0;col&lt;n;col++)//排序的是col &#123; if(!IsValid(myqueen,n,row,col))//基于条件对string进行排序。col是变量 continue; myqueen[row][col]='Q'; Helper(ret,myqueen,n,row+1);//往myqueen的下一个string,所以是row+1 myqueen[row][col]='.'; &#125; &#125; bool IsValid(vector&lt;string&gt; myqueen,int n,int row,int col)&#123; //row // for(int c = col; c &gt;=0; c--) // &#123; // if(myqueen[row][c]=='Q') // return false; // &#125; //因为已经Helper(row+1),所以一行中只有一个Q是固定了的。 //col for(int r=row;r&gt;=0;r--) &#123; if(myqueen[r][col]=='Q') return false; &#125; //45° for(int i=row-1,j=col-1;i&gt;=0&amp;&amp;j&gt;=0;i--,j--) &#123; if(myqueen[i][j]=='Q') return false; &#125; //135° for(int i=row-1,j=col+1;i&gt;=0&amp;&amp;j&lt;n;i--,j++) &#123; if(myqueen[i][j]=='Q') return false; &#125; return true; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>String</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 面向对象篇 OOP概述]]></title>
    <url>%2F2019%2F02%2F25%2FC-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AF%87-OOP%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[概述 继承1234567891011struct Base &#123; int a, b, c;&#125;;// 每个 Derived 类型对象包含 Base 为子对象struct Derived : Base &#123; int b;&#125;;// 每个 Derived2 类型对象包含 Derived 与 Base 为子对象struct Derived2 : Derived &#123; int c;&#125;; 从内存的角度：派生类继承了基类的成员变量（data)。 从多态的角度：可以重写基类的成员函数。函数的继承是继承父类的调用权。 基类基类的成员函数定义基类必须已经定义，才能派生。 non-virtual fun 非虚函数：不希望派生类重写。 virtual fun 虚函数 ：希望派生类重写。 pure virtual fun 纯虚函数 ： 派生类必须重写。 虚析构函数虽然析构函数是不继承的，若基类声明器其析构函数为 virtual ，则派生的析构函数始终覆写它。 这使得可以通过指向基类的指针 delete 动态分配的多态类型对象。 1234567891011121314151617class Base &#123; public: virtual ~Base() &#123; /* 释放 Base 的资源 */ &#125;&#125;; class Derived : public Base &#123; ~Derived() &#123; /* 释放 Derived 的资源 */ &#125;&#125;; int main()&#123; Base* b = new Derived; delete b; // 进行到 Base::~Base() 的虚函数调用 // 因为它为虚，故它调用 Derived::~Derived() ， // 能释放派生类的资源，然后遵循通常析构顺序 // 调用 Base::~Base()&#125; 【重要！】任何基类的析构函数必须为公开且虚public virtual，或protected受保护且非虚 。若类为多态（声明或继承至少一个虚函数），且其析构函数非虚，会导致资源泄漏。因为派生类的资源未释放。 派生类 派生类必须用 ：指定父类。 用逗号分开。基类前面可以加三种访问说明符之一。 若省略访问说明符 ，则它对以类关键 struct 声明的类默认为 public ，对以类关键 class 声明的类为 private 。 列于 base-clause 的类是直接基类，其基类是间接基类。 同一类不能指定于直接基类多于一次，但同一类可以既是直接又是间接基类。 每个直接和间接基类都作为基类子对象，以实现定义的偏移存在于派生类的对象表示中。 因为空基类优化，空基类通常不会增加派生类对象的大小。 类不能派生自己。 派生类声明中。不能包含基类列表。 派生类可以隐式转换为基类。 空基类优化（本节不理解允许空的基类子对象大小为零。 为保证同一类型的不同对象地址始终有别，要求任何对象或成员子对象的大小至少为 1 ，即使该类型是空类类型（即无非静态数据成员的 class 或 struct ）。 然而，基类子对象不受这种制约，而且可以完全从对象布局中被优化掉： 12345678910111213141516#include &lt;cassert&gt; struct Base &#123;&#125;; // 空类 struct Derived1 : Base &#123; int i;&#125;; int main()&#123; // 任何空类类型的对象大小至少为 1 assert(sizeof(Base) &gt; 0); // 应用空基优化 assert(sizeof(Derived1) == sizeof(int));&#125; 若空基类之一亦为首个非静态数据成员的类型或其类型的基类，则禁用空基优化，因为要求同类型二个基类子对象在最终派生类的对象表示中拥有不同地址。 这种情况的典例是 std::reverse_iterator 的朴素实现（派生自空基类 std::iterator ），它保有底层迭代器（亦派生自 std::iterator ）为其首个非静态数据成员。 12345678910111213141516171819202122232425262728#include &lt;cassert&gt; struct Base &#123;&#125;; // 空类 struct Derived1 : Base &#123; int i;&#125;; struct Derived2 : Base &#123; Base c; // Base ，占用 1 字节，后随为 i 的填充 int i;&#125;; struct Derived3 : Base &#123; Derived1 c; // 从 Base 派生，占用 sizeof(int) 字节 int i;&#125;; int main()&#123; // 不应用空基优化 // 基类占用 1 字节，Base 成员占用 1 字节，后随2个填充字节以满足 int 对齐要求 assert(sizeof(Derived2) == 2*sizeof(int)); // 不应用空基类优化， // 基类占用至少 1 字节加填充以满足首个成员的对齐要求（其对齐要求同 int ） assert(sizeof(Derived3) == 3*sizeof(int));&#125; 【C++11】：对于标准布局类型 (StandardLayoutType) 要求有空基类优化，以维持指向标准布局对象的指针，用 reinterpret_cast 转换后，还指向其首成员，这是标准布局类型“无拥有非静态数据成员的基类，且无与其首个非静态数据成员同类型的基类”的原因。 虚基类【注意】对于每个指定为 virtual 的相异基类，最终派生类对象仅含有该类型的一个基类子对象，即使该类在继承层级中出现多次（只要它每次都以 virtual 继承）。 下面的AA对象只有2个B基类子对象，XY共有一个虚B基类，Z有一个非虚B基类。 123456789101112131415struct B &#123; int n; &#125;;class X : public virtual B &#123;&#125;;//相异基类class Y : virtual public B &#123;&#125;;//相异基类class Z : public B &#123;&#125;;// 每个 AA 类型对象拥有一个 X ，一个 Y ，一个 Z 和二个 B ：// 其一是 Z 的基类，另一者为 X 与 Y 所共享struct AA : X, Y, Z &#123; void f() &#123; X::n = 1; // 修改虚 B 基类子对象的成员 Y::n = 2; // 修改同一虚 B 基类子对象的成员 Z::n = 3; // 修改非虚 B 基类子对象的成员 std::cout &lt;&lt; X::n &lt;&lt; Y::n &lt;&lt; Z::n &lt;&lt; '\n'; // 打印 223 &#125;&#125;; iostream继承层级有虚基类的例子之一是标准库的 iostream 的继承层级： std::istream 与 std::ostream 从 std::ios 使用虚继承派生。 std::iostream 继承 std::istream 和 std::ostream ， 故每个 std::iostream 实例含一个 std::ostream 子对象、一个 std::istream 子对象和仅一个 std::ios 子对象（继而有一个 std::ios_base ）。 （这里不理解） 所有 虚基类子对象 在 任何 非虚基类子对象 前 初始化，故 只有 最终派生类于其成员初始化器列表调用虚基类的构造函数： 1234567891011121314151617181920struct B &#123; int n; B(int x) : n(x) &#123;&#125;&#125;;struct X : virtual B &#123; X() : B(1) &#123;&#125; &#125;;struct Y : virtual B &#123; Y() : B(2) &#123;&#125; &#125;;struct AA : X, Y&#123; AA() : B(3),X(),Y() &#123;&#125; //逗号分隔基类列表。前面可以有访问说明。&#125;; // AA 的默认构造函数调用 X 和 Y 的默认构造函数// 但这些构造函数不调用 B 的构造函数，因为 B 是虚基类AA a; // a.n == 3// X 的默认构造函数调用 B 的构造函数X x; // x.n == 1 涉及虚继承时，类成员的非限定名称查找有特殊规则（有时被引用为支配规则），见 unqualified_lookup#成员函数定义。 继承方式 公开继承 public公开继承模拟面向对象编程的子类型关系：派生类对象是（ IS-A ）基类子对象。期待派生类对象的引用和指针，可为使用期待到其任何基类的引用和指针的代码所用（见 LSP ），或者为了 DbC ，派生类应该维护其公开基类的类不变量，不应强化任何其所覆写的成员函数的前置条件，或弱化任何其后置条件。 受保护继承 protected受保护继承可用于“受控制的多态”：在派生类的成员中，还有在所有进一步派生类的成员中，派生类是（ IS-A ）基类：到派生类的引用和指针可用于期待到基类的引用和指针处。 私有继承 private私有继承常用于基于策略的设计，因为策略常是空基类，而使用基类可以启用静多态并活用空基类优化. 私有继承亦可用于实现合成关系（基类子对象是派生类对象的实现细节）。成员使用提供更好的封装，而且通常受到偏好，除非派生类要求访问基类的受保护成员（包含构造函数）、需要覆写基类的虚成员、需要基类构造先于或析构后于某其他基类子对象，需要共享虚基类或需要控制虚基类的构造。实现合成的成员使用亦不可应用于从参数包多重继承的情况，或在编译时通过模板元编程确定基类身份的情况。 同受保护继承，私有继承亦可用于受控制的多态：在派生类的成员内（但不在进一步派生类内），派生类是（ IS-A ）基类。 123456789101112131415161718192021template&lt;typename Transport&gt;class service : Transport // 从 Transport 策略私有继承&#123;public: void transmit() &#123; this-&gt;send(...); // 发送传输所提供的任何内容 &#125;&#125;;// TCP 传输策略class tcp &#123;public: void send(...);&#125;;// UDP 传输策略class udp &#123;public: void send(...);&#125;; service&lt;tcp&gt; service(host, port); service.transmit(...); // 发送完毕 TCP 成员名称查找（不理解）类成员非限定及限定名称查找的规则详细列于名称查找。 C++11新增派生类内部必须对所有重定义的虚函数进行声明，可以在函数前加上virtual关键字，也可以不加。 只有虚函数才能被覆盖。签名要匹配。 为了方便编译器找出错误。C++通过override和final显式说明派生类的虚函数，这两个说明符在语句的最后。 override在成员函数声明或定义中， override 可以显式地指出该函数为虚函数，并覆写来自基类的虚函数。 12345678910111213struct A&#123; virtual void foo(); void bar();&#125;; struct B : A&#123; void foo() const override; // 错误： B::foo 不覆写 A::foo // （签名不匹配） void foo() override; // OK ： B::foo 覆写 A::foo void bar() override; // 错误： A::bar 非虚&#125;; final在虚函数声明或定义中使用时， final 确保函数为虚，且不可被派生类覆写。 final 亦可用于联合体定义，此情况下它无效（除了 std::is_final 上的结果），因为不能派生联合体。final 是在用于成员函数声明或类头部时有特殊含义的标识符。其他语境中它非保留而且可用于命名对象或函数。 12345678910111213141516171819struct Base&#123; virtual void foo();&#125;; struct A : Base&#123; void foo() final; // A::foo 被覆写且是最终覆写 void bar() final; // 错误：非虚函数不能被覆写或是 final&#125;; struct B final : A // struct B 为 final&#123; void foo() override; // 错误： foo 不能被覆写，因为它在 A 中是 final&#125;; struct C : B // 错误： B 为 final&#123;&#125;; 动态绑定(非常重要）使用基类的引用或指针，调用一个虚函数，虚函数运行时，形参的版本由实参对象的类型决定。 C++ OOP的关键：基类和派生类之间的类型转换。 对象模型：虚表和虚指针 函数也占内存，也有地址。虚函数才有虚指针，虚函数表（里面都是指向函数的指针。 c调用： 静态绑定 call+地址。c++调用：动态绑定。指向C的指针p想调用虚函数v1（动态绑定）通过指针找到vptr虚指针，找到vtbl虚函数表，得到要调用的函数地址。 p-&gt;vptr[n]是c语言的描述，n是虚函数在vtbl中的第几个位置。编译器在编译的时候看vfun是第几个出现的，就确定了n的值。 类的内存：父类数据+自己数据+1个或0个虚指针。 容器里装的一定是一个指向父类的指针。list&lt;A*&gt;，因为没法确定形状的大小所以是指针，而且必须得是父类。 只有虚函数才能被override（c++)。不用像c那样去判断类型。因为父类可能加新的子类。 ##动态绑定的三个条件 通过指针或引用调用。 指针必须向上转型。由子类转向父类。 调用的是虚函数。 static type和dynamic type区别 静态类型在编译时就被确定了。它是【变量声明时的类型】 或【表达式生成的类型】。 动态类型在运行时才知道。它是【变量或表达式代表的内存中的对象的类型】。 关于this this是个指针。也可以说this指的那个object。 main(){derivedclass object;object.func();}相当于调用baseclass::func(&amp;object);&amp;object就是this，通常不写。 类型转换只有在指针和引用之间才有类型转换。在对象之间没有类型转换。 虚成员、虚函数定义 基类希望该成员在派生类中重新定义，除了构造函数和静态成员，类中任何成员都可以被virtual声明为虚成员。 该函数在派生类中隐式的也是虚函数。 调用（重要）若使用到基类的指针或引用处理派生类，则对被覆写虚函数的调用，将会调用定义于派生类的行为。 若使用有限定名称查找（作用域解决运算符 :: ），调用作用域内部的非虚函数。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;struct Base &#123; virtual void f() &#123; std::cout &lt;&lt; "base\n"; &#125;&#125;;struct Derived : Base &#123; void f() override &#123; // 'override' 可选 std::cout &lt;&lt; "derived\n"; &#125;&#125;;int main()&#123; Base b; Derived d; // 通过引用调用虚函数 Base&amp; br = b; // br 的类型是 Base&amp; Base&amp; dr = d; // dr 的类型也是 Base&amp; br.f(); // 打印 "base" dr.f(); // 打印 "derived" // 通过指针调用虚函数 Base* bp = &amp;b; // bp 的类型是 Base* Base* dp = &amp;d; // dp 的类型也是 Base* bp-&gt;f(); // 打印 "base" dp-&gt;f(); // 打印 "derived" // 非虚函数调用 br.Base::f(); // 打印 "base" dr.Base::f(); // 打印 "base"&#125; 覆写（重要）若某成员函数 vf 在类 Base 中声明为 virtual ，且某个直接或间接从 Base 派生的类 Derived 拥有下列几点与之相同的成员函数声明 名称 参数列表（但非返回类型） cv 限定符 引用限定符 则类 Derived 中的此函数亦为虚（无论是否于其声明使用关键词 virtual ）并覆写 Base::vf （无论是否于其声明使用词 override）。 要覆写的 Base::vf 不需要可见（可声明为 private ，或用私有继承继承）。 123456789101112131415class B &#123; virtual void do_f(); // 私有成员 public: void f() &#123; do_f(); &#125; // 公开继承&#125;;struct D : public B &#123; void do_f() override; // 覆写 B::do_f&#125;; int main()&#123; D d; B* bp = &amp;d; bp-&gt;f(); // 内部调用 D::do_f();&#125; 对于每个虚函数，存在最终覆写者，它在虚函数调用进行时执行。基类 Base 虚成员函数 vf 是最终覆写者，除非派生类声明或继承（通过多重继承）另一覆写 vf 的函数。 123456789101112struct A &#123; virtual void f(); &#125;; // A::f 为 virtualstruct B : A &#123; void f(); &#125;; // B::f 覆写 A::f in Bstruct C : virtual B &#123; void f(); &#125;; // C::f 覆写 A::f in Cstruct D : virtual B &#123;&#125;; // D 不引入覆写者， B::f 在 D 中为最终struct E : C, D &#123; // E 不引入覆写者， C::f 在 E 中为最终 using A::f; // 非函数声明，仅令 A::f 能为查找所见&#125;;int main() &#123; E e; e.f(); // 虚调用调用 C::f ， e 中的最终覆写者 e.E::f(); // 非虚调用调用 A::f ，它在 E 中可见&#125; 虚函数只能有一个最终覆写者： 12345678910111213141516171819struct A &#123; virtual void f();&#125;;struct VB1 : virtual A &#123; void f(); // 覆写 A::f&#125;;struct VB2 : virtual A &#123; void f(); // 覆写 A::f&#125;;// struct Error : VB1, VB2 &#123;// // 错误： A::f 在 Error 中拥有二个最终覆写者// &#125;;struct Okay : VB1, VB2 &#123; void f(); // OK ：这是 A::f 的最终覆写者&#125;;struct VB1a : virtual A &#123;&#125;; // 不声明覆写者struct Da : VB1a, VB2 &#123; // Da 中， A::f 的最终覆写者是 VB2::f&#125;; 拥有同名和相异参数列表的函数不覆写同名的基类函数，但隐藏它：在非限定名称查找检验派生类的作用域时，查找找到该声明，且不检验基类。 1234567891011121314151617181920212223struct B &#123; virtual void f();&#125;;struct D : B &#123; void f(int); // D::f 隐藏 B::f （错误的参数列表）&#125;;struct D2 : D &#123; void f(); // D2::f 覆写 B::f （它不可见是不要紧的）&#125;; int main()&#123; B b; B&amp; b_as_b = b; D d; B&amp; d_as_b = d; D&amp; d_as_d = d; D2 d2; B&amp; d2_as_b = d2; D&amp; d2_as_d = d2; b_as_b.f(); // 调用 B::f() d_as_b.f(); // 调用 B::f() d2_as_b.f(); // 调用 D2::f() d_as_d.f(); // 错误： D 中的查找只找到 f(int) d2_as_d.f(); // 错误： D 中的查找只找到 f(int)&#125; 非成员函数和静态成员函数不能为虚。 函数模板不能为虚 virtual 。这只应用于自身是模板的函数——类模板的常规成员函数能声明为虚。 在编译时替换虚函数的默认实参。 协变返回类型若函数 Derived::f 覆写 Base::f ，则其返回类型必须相同或为协变。若满足所有下列要求，则二个类型为协变： 二个类型均为到类的指针或引用（左值或右值）。不允许多级指针或引用。 Base::f() 的返回类型中被引用/指向的类，必须是 Derived::f() 的返回类型中被引用/指向的类的无歧义且可直接或间接访问的基类。 Derived::f() 的返回类型必须有相对于 Base::f() 的返回类型的相等或较少的 cv 限定。 Derived::f 的返回类型中的类必须是 Derived 自身，或必须是于 Derived::f 声明点的完整类型。 进行虚函数调用时，最终覆写者的返回类型被隐式转换成本该调用的被覆写函数的返回类型： 1234567891011121314151617181920212223242526272829303132333435363738class B &#123;&#125;; struct Base &#123; virtual void vf1(); virtual void vf2(); virtual void vf3(); virtual B* vf4(); virtual B* vf5();&#125;; class D : private B &#123; friend struct Derived; // Derived 中， B 是 D 的可访问基类&#125;; class A; // 前置声明类是不完整类型 struct Derived : public Base &#123; void vf1(); // 虚，覆写 Base::vf1() void vf2(int); // 非虚，隐藏 Base::vf2()// char vf3(); // 错误：覆写 Base::vf3 ，但有相异而非协变返回类型 D* vf4(); // 覆写 Base::vf4() 并用有协变返回类型// A* vf5(); // 错误： A 是不完整类型&#125;; int main()&#123; Derived d; Base&amp; br = d; Derived&amp; dr = d; br.vf1(); // 调用 Derived::vf1() br.vf2(); // 调用 Base::vf2()// dr.vf2(); // 错误： vf2(int) 隐藏 vf2() B* p = br.vf4(); // 调用 Derived::vf4() 并转换结果为 B* D* q = dr.vf4(); // 调用 Derived::vf4() 并不转换结果为 B* &#125; 在构造与析构期间 派生类构造函数。首先初始化基类的部分。再按照声明的顺序依次初始化派生类的成员。 每个类控制它自己的成员初始化过程。（关键;要想与类的对象交互。必须使用该类的接口。） 当直接或间接从构造函数或从析构函数调用虚函数（包含在类的非静态成员函数的构造或析构期间，例如在初始化器列表中），且应用调用的对象是正在构造或析构中的对象，则所调用的函数是构造函数或析构函数的类中的最终覆写者，而非进一步派生类中的覆写者。 换言之，在构造和析构期间，进一步派生类不存在。 构建有多分支的复杂类时，在属于一个分支的构造函数内，多态被限制到该类与其基类：若它获得到其子层级外的基类子对象的指针，且试图进行虚函数调用（例如通过显式成员访问），则行为未定义： 12345678910111213141516171819202122232425262728293031323334353637struct V &#123; virtual void f(); virtual void g();&#125;; struct A : virtual V &#123; virtual void f(); // A::f 是 V::f 在 A 中的最终覆写者&#125;;struct B : virtual V &#123; virtual void g(); // B::g 是 V::g 在 B 中的最终覆写者 B(V*, A*);&#125;;struct D : A, B &#123; virtual void f(); // D::f 是 V::f 在 D 中的最终覆写者 virtual void g(); // D::g 是 V::g 在 D 中的最终覆写者 // 注意： A 初始化先于 B D() : B((A*)this, this) &#123; &#125;&#125;; // B 的构造函数，从 D 的构造函数调用 B::B(V* v, A* a)&#123; f(); // 对 V::f 的虚调用（尽管 D 拥有最终覆写者， D 也不存在） g(); // 对 B::g 的虚调用，在 B 中是最终覆写者 v-&gt;g(); // v 的类型 V 是 B 的基类，虚调用如前调用 B::g a-&gt;f(); // a 的类型 A 不是 B 的基类，它属于层级中的不同分支。 // 尝试通过不同分支的虚调用导致未定义行为， // 即使此情况下 A 已完全构造 // （它在 B 前构造，因为它在 D 的基类列表中出现先于 B ） // 实践中，对 A::f 的虚调用会试图使用 B 的虚成员函数表， // 因为它在 B 的构造中活跃&#125; 抽象类 与 纯虚类定义不能被实例化，但能用作基类的抽象类型。 纯虚 (pure virtual) 函数纯虚 (pure virtual) 函数是声明器拥有下列语法的虚函数： 此处序列 **= 0** 被称作 pure-specifier ，且立即出现于 declarator 后或于可选的 virt-specifier （ override 或 final ）后。 pure-specifier 不能出现于成员函数定义中。 123456789struct Base &#123; virtual int g(); virtual ~Base() &#123;&#125; &#125;;struct A : Base&#123; // OK ：声明三个成员虚函数，其二为纯 virtual int f() = 0, g() override = 0, h(); // OK ：析构函数亦能为纯 ~A() = 0; // 错误：纯指定符在函数定义上 virtual int b()=0 &#123;&#125;&#125;; abstract class 是定义或继承了至少一个最终覆写为 pure virtual 的函数的类。 抽象类用于表示通用概念（例如 Shape 、 Animal ），它可用作具体类（例如 Circle 、 Dog ）的基类。 不能创建抽象类的实例。抽象类型不能用作参数类型、函数返回类型或显式转换的类型。可以声明到抽象类的指针或引用。 123456789101112131415161718192021struct Abstract &#123; virtual void f() = 0; // 纯虚&#125;; // "Abstract" 为抽象 struct Concrete : Abstract &#123; void f() override &#123;&#125; // 非纯虚 virtual void g(); // 非纯虚&#125;; // "Concrete" 为非抽象 struct Abstract2 : Concrete &#123; void g() override = 0; // 纯虚覆写&#125;; // "Abstract2" 为抽象 int main()&#123; // Abstract a; // 错误：抽象类 Concrete b; // OK Abstract&amp; a = b; // OK ：到抽象基类的引用 a.f(); // 到 Concrete::f() 的虚派发 // Abstract2 a2; // 错误：抽象类（ g() 的最终覆写为纯）&#125; 可以提供纯虚函数的定义（而且若析构函数为纯虚则必须提供）：导出类的成员函数可以自由地用有限定函数 id 调用虚基类的纯虚函数。此定义必须在类体外（函数声明的语法不允许纯虚指定符 **= 0** 和函数体一起出现）。 从抽象类的构造函数或析构函数进行纯虚函数的虚调用是未定义行为（无论纯虚函数是否拥有定义）。 1234567891011121314151617181920212223struct Abstract &#123; virtual void f() = 0; // 纯虚 virtual void g() &#123;&#125; // 非纯虚 ~Abstract() &#123; g(); // OK ：调用 Abstract::g() // f(); // 未定义行为！ Abstract::f(); // OK ：非虚调用 &#125;&#125;; // 纯虚函数的定义void Abstract::f() &#123; std::cout &lt;&lt; "A::f()\n"; &#125; struct Concrete : Abstract &#123; void f() override &#123; Abstract::f(); // OK ：调用纯虚函数 &#125; void g() override &#123;&#125; ~Concrete() &#123; g(); // OK ：调用 Concrete::g() f(); // OK ：调用 Concrete::f() &#125;&#125;;]]></content>
      <categories>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ STL篇 IO库]]></title>
    <url>%2F2019%2F02%2F24%2FC-STL%E7%AF%87-IO%E5%BA%93%2F</url>
    <content type="text"><![CDATA[面向对象的标准库 多种IO标准库工具 istream，提供输入操作 ostream，提供输出操作 cin：读入标准输入的istream对象.全局对象extern std::istream cin;定义于头文件 &lt;iostream&gt; cout：写到标准输出的ostream对象 cerr：输出标准错误的ostream对象。常用语程序错误信息 >&gt;，用于从istream对象中读入输入.从左到右 &lt;&lt;，用于把输出写到ostream对象中 getline，功能是从istream对象读取一个单词，然后写入string对象中 IO类之间的关系 IO对象不可复制或赋值流对象不能存储在vector或其他容器中。 形参或返回类型也不能为流类型，如果需要，则必须传递或返回指向该对象的指针或引用，而且不能是const引用，因为读写一个IO对象会改变其状态。 IO库的条件状态流的状态由bad,fail,eof,good操作揭示。 标志 iostate:机器相关的类型，表达条件状态。 badbit:系统级的故障 failbit:可恢复的错误,比如 把字符输入到数值变量中。 eofbit:遇到文件结束符，fail也置位 goodbit:流未处于错误状态，保证为0. 函数（s表示流 s.bad(): 若badbit置位，返回true s.fail(): 若failbit置位，返回true s.eof(): 若eofbit置位，返回true s.good(): 若goodbit置位，返回true s.clear():流的所有条件状态位复位，将流的状态设为有效，void s.clear(flag):指定位复位，void s.setstate(flag)：指定位 置位，void s.rdstate(): 返回当前流的条件状态，s.iostate 《cpp primer》p280 ：只有当一个流处于无错状态时，才能从他读写数据。在使用流之前，应该检查它的状态，通常用while循环来检查。&gt;&gt;表达式返回的是流的状态。 使用good()和fail()是检查流总体状态的正确方法。将流当作条件的代码等价：!fail(); 1234if(cin) //ok to use cin, it is in a valid statewhile(cin &gt;&gt; word) //ok:read operation successful… 文件IO标准库头文件\&lt;fstream> ifstream :从文件中读数据 ofstream ：从文件中写数据 fstream ：读写文件 IO运算符 &lt;&lt; &gt;&gt;也可以读写文件。 getline(cin,line) c风格IO1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;cstdlib&gt; int main()&#123; FILE* fp = std::fopen("test.txt", "r"); if(!fp) &#123; std::perror("File opening failed"); return EXIT_FAILURE; &#125; int c; // 注意：是 int 而非 char ，要求处理 EOF while ((c = std::fgetc(fp)) != EOF) &#123; // 标准 C I/O 文件读取循环 std::putchar(c); &#125; if (std::ferror(fp)) std::puts("I/O error when reading"); else if (std::feof(fp)) std::puts("End of file reached successfully"); std::fclose(fp);&#125; string流 特有函数：公开成员函数 std::basic_stringstream::str std::basic_string&lt;CharT,Traits,Allocator&gt; str() const;返回stream保存的string拷贝。 void str(const std::basic_string&lt;CharT,Traits,Allocator&gt;&amp; new_str);将string拷贝到流对象中。亦可使用streamobj(string)。 12345678910111213141516171819202122#include &lt;sstream&gt;#include &lt;iostream&gt;int main()&#123; int n; std::istringstream in; // 亦可使用 in("1 2") in.str("1 2"); in &gt;&gt; n; std::cout &lt;&lt; "after reading the first int from \"1 2\", the int is " &lt;&lt; n &lt;&lt; ", str() = \"" &lt;&lt; in.str() &lt;&lt; "\"\n"; std::ostringstream out("1 2"); out &lt;&lt; 3; std::cout &lt;&lt; "after writing the int '3' to output stream \"1 2\"" &lt;&lt; ", str() = \"" &lt;&lt; out.str() &lt;&lt; "\"\n"; std::ostringstream ate("1 2", std::ios_base::ate); ate &lt;&lt; 3; std::cout &lt;&lt; "after writing the int '3' to append stream \"1 2\"" &lt;&lt; ", str() = \"" &lt;&lt; ate.str() &lt;&lt; "\"\n";&#125; 123after reading the first int from &quot;1 2&quot;, the int is 1, str() = &quot;1 2&quot;after writing the int &apos;3&apos; to output stream &quot;1 2&quot;, str() = &quot;3 2&quot;after writing the int &apos;3&apos; to append stream &quot;1 2&quot;, str() = &quot;1 23&quot; 读取输入流的个人信息 123456789101112131415161718struct PersonInfo&#123; /* data */ string name; vector&lt;string&gt; phones;&#125;;string line,word;vector&lt;PersonInfo&gt; people;while(getline(cin,line))&#123; PersonInfo info; istringstream record(line);//line拷贝到record中 record &gt;&gt;info.name; while(record&gt;&gt;word) info.phones.push_back(word); people.push_back(info); /* code */&#125; to be continued…]]></content>
      <categories>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>Input/output library</tag>
        <tag>stringstream</tag>
        <tag>getline</tag>
        <tag>fstream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Solution]]></title>
    <url>%2F2019%2F01%2F21%2Fleetcode%2F</url>
    <content type="text"><![CDATA[题号 解答 [1] 两数之和 1. umap.find(target - nums[i])2. umap.count(target-nums[i]) 👍 [46] 全排列 1. 递归. 分层布局。1.交换第一个数字。2.第一个数固定。后面的排列。3.交换归位。 2. 递归。回溯。填空格法。访问数组标记。 [47] 全排列ii set。去重。递归。交换。 [51] N皇后 回溯。排序。基于条件对string进行排序。H [52] N皇后ii 回溯。计数。跟51题一样。 [53] 最大子序和 1. 2*O(n/2)+O(1)=O(n)。分治法。max(divide,merge)。2. O(n)。Kadane’s algorithm。DP。分为子问题。 [77] 组合 1. 公式法：C(K,N)=C(K-1,N-1)+C(K,N-1)。2. 回溯法。递归+循环。M [94] 二叉树的中序遍历 1. 中序遍历。递归。E2. 中序遍历。1个栈。M。👍3. 中序遍历。O1,非递归+不用栈。线索二叉树。H。 [104] 二叉树的最大深度 dfs.递归。E [105] 从前序与中序遍历序列构造二叉树 递归。二分查找。mid.start.end. pos=distance(.begin,find( , , )) [111] 二叉树的最小深度 dfs.递归。E [138] 复制带随机指针的链表 链表/复制原始(copy,link,next)/复制随机(copy,next)/分离。M [141] 环形链表 快慢指针。fast&amp;&amp;fast-&gt;next一起判空。有环必走不到空，指针相遇就有环。 [142] 环形链表 II 1. 快慢指针，计数2. 三个指针！环状检测算法！ [144] 二叉树的前序遍历 1. 递归2. 迭代+栈👍 [145] 二叉树的后序遍历 1. 递归2. 迭代+1个栈👍3. 迭代+2个栈 [169] 求众数 1. 快排。找中位数。O(nlogn)2. 不修改数组的方法O(n) 👍 [172] 阶乘后的零 1. 数学。递归。2. 数学。迭代。 [179] 最大数 字符串排序,sort.lambda.string [215] 数组中的第K个最大元素 1. O(nlogn)。快排sort()。reverse()。会修改数组。2. O(n)。快排in-place partition/one way。会修改数组。3. O(nlogk)。priorityqueue-default-maxheap。基于堆。所有元素放入pq，弹出k-1次堆顶，返回pq.top()。不需要修改数组，适用于处理海量数据。4. O(nlogk)。multiset-default-minheap。基于rbt,设置一个大小为k的最小堆。最后弹出*set.begin()。不需要修改数组，适用于处理海量数据。.cpp) [233] 数字1的个数 数学。T:O(logn),S:O(1)1. 公式法：n/(10d)d + min(d,max(0,n\%(10d)-d+1))2.划分法。满二进一位（满载），如果量级的最后一位是1，要加上余数+1 [263] 丑数 数学。迭代。 [264] 丑数ii 动态规划.3个指针 [295] 数据流的中位数 1. 增删O(logn),查O(1).maxheap，两个stl::pq,一个放前一半大的数，一个放后一半大的负数。2. AVL。maxheap和minheap。优先队列。 [297] 二叉树的序列化与反序列化 1. bfs/queue/stringstream2. dfs递归/stringstream in(str)/obj.str()返回值 [387] 字符串中的第一个唯一字符 无序关联式容器，哈希表，计数。unordered_map&gt; [400] 第N个数字 迭代。数学。tostring(int)。(string)char。stoi(const string&amp;) [426] 把二叉搜索树转化为有序双向链表 分治法。递归。指针引用。中序遍历。M [463] 岛屿的周长 1. 岛屿边界处：在数组最左边，或者左边格子没有岛屿2. 先假设算4个边，判断左边和上边是否有岛屿 👍 [700] 二叉搜索树的查找 1. 递归。BST。E2. 迭代。BST。E。 [701] 二叉搜索树的插入 1. 递归。BST。2. 迭代。BST。break。 [705] 设计哈希集合 hashset。二维数组。value=0或者1.代表集合中是否存在。E。 [706] 设计哈希映射 hashmap。key-value。映射。初值为-1。E。 [724] 寻找数组的中心索引 1. 计算不含nums[i]的leftsum，如果leftsum== total - leftsum -nums[i]，返回i2. left=0,right=total;right-sum[i],if(==),return i;left+nums[i];return -1 [747] 至少是其他数字两倍的最大数 第一遍找到最大并记录索引。第二遍如果又发现不符合条件的返-1。否则返index [804] 国际摩尔斯密码 unordered_set。hash。E。 [876] 链表的中间结点 快慢指针。链表。]]></content>
      <categories>
        <category>Interview</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ubuntu 16.04 连接 wifi]]></title>
    <url>%2F2018%2F08%2F19%2Fubuntu-16-04-%E8%BF%9E%E6%8E%A5-wifi%2F</url>
    <content type="text"><![CDATA[本机配置我的电脑是win10+ubuntu16.04双系统。在ubuntu下无法连接wifi，一直用usb连接的手机流量，不太方便。现在来用安装无线驱动，顺便翻个墙。 https://blog.csdn.net/linzhineng44/article/details/78778143 查看网卡12yue@akayue:~$ lspci | grep Network03:00.0 Network controller: Intel Corporation Device 24fb (rev 10) 无线网卡123yue@akayue:~$ lspci | grep -i net02:00.1 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8111/8168/8411 PCI Express Gigabit Ethernet Controller (rev 12)03:00.0 Network controller: Intel Corporation Device 24fb (rev 10) 查看安装的内核版本（不限以下三种，为了以后使用方便，记录以下）123456yue@akayue:~$ dpkg -l | grep linux-imageii linux-image-4.4.0-133-generic 4.4.0-133.159 amd64 Linux kernel image for version 4.4.0 on 64 bit x86 SMPii linux-image-4.4.0-21-generic 4.4.0-21.37 amd64 Linux kernel image for version 4.4.0 on 64 bit x86 SMPii linux-image-extra-4.4.0-133-generic 4.4.0-133.159 amd64 Linux kernel extra modules for version 4.4.0 on 64 bit x86 SMPii linux-image-extra-4.4.0-21-generic 4.4.0-21.37 amd64 Linux kernel extra modules for version 4.4.0 on 64 bit x86 SMPii linux-image-generic 4.4.0.133.139 amd64 Generic Linux kernel image ref 步骤查看自己的无线网卡的型号 我的是intel dual band wireless ac 3168 网卡驱动下载链接 注意驱动的要求 可以看到，需要的linux内核要求是4.6以上，14.04的ubuntu还是3.几的kernel，16.04的也不过4.4kernel，所以需要升级linux内核 通过下面的命令来查看内核 12yue@akayue:~$ uname -r4.4.0-133-generic 升级linux内核Ubuntu 16.04 Linux系统内核升级方法 选择合适和内核进行升级 安装内核文件sudo dpkg -i *.deb 安装完成以后，重新启动系统，验证内核的版本 安装驱动下好的驱动 查看readme文件，可以看到我们需要进行内核配置 12345$ cd /usr/src/$ ls$cd linux-4.18.3-.. Device Drivers -&gt;Generic Driver Options -&gt;Userspace firmware loading support Linux 内核配置机制（make menuconfig、Kconfig、makefile）讲解 配置内核（make menuconfig）详述 $make menuconfig bugmake: *** No rule to make target ‘menuconfig’. Stop.` 解决办法sudo apt-get install ncurses-dev 当然在配置内核最好还要查看.config里面的CONFIG_FW_LOADER是否为Y 配置好内核后 1cp iwlwifi-3168-22.ucode /lib/firmware 重启]]></content>
      <categories>
        <category>Configuration</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Effective C++》 条款04：Stack与Heap / 内存管理]]></title>
    <url>%2F2018%2F08%2F04%2F%E3%80%8AEffective-C-%E3%80%8B-%E6%9D%A1%E6%AC%BE04%EF%BC%9AStack%E4%B8%8EHeap-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[阅读effective c++ 04 （30页） 提到的static对象和堆与栈对象。“不同编译单元内定义的non-local static对象”。 Stack与Heap / 内存管理stackstack是在某个作用域内的一块内存空间。当调用函数时，函数本身会形成一个栈来保存函数的参数和返回地址。函数体内声明的所有变量，都来自stack的内存。 heap / system heap堆是操作系统提供的全局global内存空间。程序动态分配dynamic allocated时，从堆里面取一些区块blocks。 stack和heap的内存例子 / 类外的static声明1234567891011class Complex &#123; … &#125;;...&#123;Complex c1(1,2);//stack/non-static localstatic Complex c2(1,2);//static local Complex* p = new Complex(3);...delete p; &#125;Complex c3(1,2);//global/static stack / 构造函数型： 局部对象 c1 的内存来自stack，生命周期在scope结束时结束，所以又称auto object，因为会被自动清理。 heap / new型 动态分配： 动态分配的临时对象Complex(3) ，占用空间来自heap。指针p指向这个临时对象，p的生命在它被delete的时候结束。如果当作用域结束，p指的堆对象依然存在，但是p的生命结束了，作用域外再也没有p，无法delete p，会导致内存泄漏leak。 static 对象：在内存中。程序结束，自动销毁 local static object。 c2 。在函数第一次调用时构造初始化。在程序结束之后自动析构。 non-local static object global object。c3。main调用之前被构造初始化。在程序结束之后自动析构。 定义于namespace作用域的对象。main调用之前被构造初始化。在程序结束之后自动析构。 类外的static声明两个编译单元中的non-local static object相互引用注意：在同一个文件或不同编译单元（不同文件）中，如果存在多个non-local static object，它们都是在主函数调用之前被构造的，但是它们之间的构造顺序时不定的。即对编译器来说，静态成员对象之间的初始化顺序和析构顺序是一个未定义的行为。 因此，不能用某个non-local static object去初始化non-local static object，无论这两个non-local static object在不在同一个编译单元中。 1234567891011121314151617181920212223242526272829303132class FileSystem&#123;public: …std::size_t numDisks() const;&#125;;extern FileSystem tfs;//另一编译单元class Directory&#123;public:Directory(params);&#125;;Directory::Directory(params)&#123;std::size_t disks = tfs.numDisks();//使用另一个编译单元的静态变量&#125;Directory tempDir (params); 由于编译器没有定义non-local static object之间的构造顺序，所以有可能类tfs还没有被构造，所以程序可能会报错。 解决方法用local static对象替换non-local static对象。 C++保证，函数内的local static 对象会在该函数被调用期间，首次遇上该对象定义式时被初始化。 123456789101112131415161718192021222324252627282930313233class FileSystem &#123;…&#125;;FileSystem&amp; tfs()&#123;static FileSystem fs;return fs;&#125;//另一编译单元class Directory &#123;…&#125;;Directory::Directory (params)&#123;std::size_t disks = tfs().numDisks();//执行函数tfs时，对象fs肯定会被构造。&#125;;Directory&amp; tempDir()&#123;static Directory td;return td;&#125;]]></content>
      <categories>
        <category>《Effective C++》</category>
      </categories>
      <tags>
        <tag>static</tag>
        <tag>Stack</tag>
        <tag>Heap</tag>
        <tag>Memory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux]]></title>
    <url>%2F2018%2F03%2F26%2FLinux%2F</url>
    <content type="text"><![CDATA[Coming soon…]]></content>
  </entry>
</search>
