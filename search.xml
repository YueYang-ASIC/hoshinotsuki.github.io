<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[æˆ‘åœ¨JitHubä¸Šçš„æ’çœ¼æ±‡æ€»]]></title>
    <url>%2F2019%2F03%2F23%2F%E6%88%91%E5%9C%A8JitHub%E4%B8%8A%E7%9A%84%E6%8F%92%E7%9C%BC%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[ðŸ’Ž build-your-own-x - åˆ¶ä½œä½ çš„ ?å†™è½®å­æ€»æ˜¯ä¸€ä»¶æ„‰å¿«çš„äº‹æƒ…ï¼Œåšå®Œä¹‹åŽç»å¯¹ä¼šæ„Ÿåˆ°å¾ˆå¤šçš„æˆå°±æ„Ÿï¼ è¿™ä¸ªé¡¹ç›®æ”¶é›†äº†å¾ˆå¤šæ–¹é¢çš„å¾ˆå¤šæ•™ç¨‹ï¼Œæ¯”è¾ƒæœ‰è¶£çš„æœ‰ï¼šæœç´¢å¼•æ“Žã€ARã€Botã€å‰ç«¯åº“ã€æ•°æ®åº“ã€ç¥žç»ç½‘ç»œã€æ“ä½œç³»ç»Ÿè¿˜æœ‰ç¨‹åºè®¾è®¡è¯­è¨€ç­‰ç­‰ï¼Œå¤Ÿä½ çŽ©äº†ï¼ ä¸è¿‡è¿™äº›å†…å®¹éƒ½æ˜¯å…¨è‹±æ–‡çš„ï¼Œå¯¹è‹±æ–‡è¦æ±‚è¾ƒé«˜~ å¿«åŽ»åˆ¶ä½œä½ çš„è½®å­å§ï¼ GitHub é¡¹ç›®åœ°å€ðŸ”— github.com Creating Your Own Containers Write your own Operating System Implementing a Key-Value Store è¾“äº†ä¸€å¤§ä¸²å‘½ä»¤å›žè½¦åŽæ‰å‘çŽ°å‘½ä»¤æ‰“é”™å­—æ¯äº†æ€Žä¹ˆåŠžï¼Ÿè¾“å…¥f*ckå¸®ä½ è½»æ¾æžå®šðŸ˜ˆï¸GitHubé¡¹ç›® TheFuckï¼šgithub.com]]></content>
      <categories>
        <category>Projects</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B tree,B+ tree,B* tree,RBT,AVL]]></title>
    <url>%2F2019%2F03%2F23%2FB-tree-B-tree-B-tree-RBT-AVL%2F</url>
    <content type="text"><![CDATA[whats B tree? self balancing search tree. each node can hold multiple keys. all leaf nodes are the same distance from the root. an extension of self-balancing binary search trees. allow each node to hold multiple keys and have multiple children. designed to take advantage of systems that can read and write in large blocks, and are commonly used in databases and file systems. B-Treeï¼ŒRBT or AVL tree? When using a RB tree, B- tree or an AVL tree? What are the key points before deciding on the choice? explain with a scenario . Answer B-tree é€‚åˆå­˜æµ·é‡æ•°æ® When youâ€™re managing more than thousands of items and youâ€™re paging them from a disk or some slow storage medium. Can have variable number of children which allow it to hold many records but still maintain a short height tree. A good general-purpose ordered container data structure, even in main memory. Even when virtual memory isnâ€™t an issue, cache-friendlinessç¼“å­˜å‹å¥½ often is. B+ trees are particularly good for sequential access - the same asymptoticæ¸è¿‘ performance as a linked list, but with cache-friendliness close to a simple array. All this and O(log n) search, insert and delete. B+ trees do have problems, though - such as the items moving around within nodes when you do inserts/deletes, invalidating pointers to those items. this means you get fairly easy O(n) merging of trees - convert both trees to lists, merge them, then convert back to a tree. RB tree é€‚åˆå¢žåˆ  when youâ€™re doing fairly frequent inserts, deletes and retrievalsæ£€ç´¢ on the tree. Has less strict rules around rebalancing which make insertions/deletions quicker than AVL tree. RB trees also have better performance O(1) on the rebalance which makes them more suitable for persistent datastructures with roll-back and roll-forward. AVL tree é€‚åˆæ£€ç´¢ when your inserts and deletes are infrequent relative to your retrievals. More strictly balanced so lookups are faster than RB tree. B-Tree vs Hash Table In MySQL, an index type is a b-tree, and access an element in a b-tree is in logarithmic amortized time O(log(n)). On the other hand, accessing an element in a hash table is in O(1). Why is a hash table not used instead of a b-tree in order to access data inside a database? Answer You can only access elements by their primary key in a hashtable. This is faster than with a tree algorithm (O(1) instead of log(n)), but you cannot select ranges (everything in between xand y). Tree algorithms support this in Log(n) whereas hash indexes can result in a full table scan O(n). Also the constant overhead of hash indexes is usually bigger (which is no factor in theta notation, but it still exists). Also tree algorithms are usually easier to maintain, grow with data, scale, etc. Hash indexes work with pre-defined hash sizes, so you end up with some â€œbucketsâ€ where the objects are stored in. These objects are looped over again to really find the right one inside this partition. Todays hash tables algorithms usually scale, but scaling can be inefficient. There are indeed scalable hashing algorithms. they evolved(è¿›åŒ–) from scalable replication where re-hashing is not easy. Its called RUSH - Replication Under Scalable Hashing, and those algorithms are thus called RUSH algorithms. However there may be a point where your index exceeds a tolerable size compared to your hash sizes and your entire index needs to be re-built. Usually this is not a problem, but for huge-huge-huge databases, this can take days. The trade off for tree algorithms is small and they are suitable for almost every use case and thus are default. B trees and B+ trees? In a b- tree you can store both keys and data in the internal and leaf nodes In a b+ tree you have to store the data in the leaf nodes only. Is there any advantage of doing the above in a b+ tree? Why not use b-trees instead of b+ trees everywhere, as intuitively they seem much faster? I mean, why do you need to replicate the key(data) in a b+ tree? Answear Advantages of B+ trees: B+ trees donâ€™t have data associated with interiorå†…éƒ¨ nodes, more keys can fit on a page of memory. Therefore, it will require fewer cache misses in order to access data that is on a leaf node. The leaf nodes of B+ trees are linked, so doing a full scan of all objects in a tree requires just one linear pass through all the leaf nodes. A B tree would require a traversal of every level in the tree. This full-tree traversal will likely involve more cache misses than the linear traversal of B+ leaves. Advantage of B trees: Because B trees contain data with each key, frequently accessed nodes can lie closer to the root, and therefore can be accessed more quickly. Whatâ€™s a B*Tree? Did they just mean binary search tree? Answer No. A node in a B*Tree can have many keys (which point to many children). They operate by comparing keys in order to select a child node, much like a binary tree. But, the intent is that each node is stored on disk, and can be read into memory at once. Thus, the number of disk accesses required would match the depth of the tree. Note that the * indicates the nodes are at least 2/3 full. Reference When to choose RB tree, B-Tree or AVL tree? B-Tree vs Hash Table Differences between B trees and B+ trees Whatâ€™s a B*Tree? to be continuedâ€¦ Further Reading Painting Nodes Black With Red-Black Trees Busying Oneself With B-Trees]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>B tree</tag>
        <tag>B+ tree</tag>
        <tag>B* tree</tag>
        <tag>RBT</tag>
        <tag>AVL</tag>
        <tag>mysql</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode387. First Unique Character in a String]]></title>
    <url>%2F2019%2F03%2F23%2FLeetcode387-First-Unique-Character-in-a-String%2F</url>
    <content type="text"><![CDATA[Given a string, find the first non-repeating character in it and return itâ€™s index. If it doesnâ€™t exist, return -1. Examples: 12345s = &quot;leetcode&quot;return 0.s = &quot;loveleetcode&quot;,return 2. Note: You may assume the string contain only lowercase letters. æ€è·¯]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode263. Ugly Number]]></title>
    <url>%2F2019%2F03%2F23%2FLeetCode263-Ugly-Number%2F</url>
    <content type="text"><![CDATA[ç¬¬ä¸€é¢˜Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. Example 1: 123Input: 6Output: trueExplanation: 6 = 2 Ã— 3 Example 2: 123Input: 8Output: trueExplanation: 8 = 2 Ã— 2 Ã— 2 Example 3: 123Input: 14Output: false Explanation: 14 is not ugly since it includes another prime factor 7. Note: 1 is typically treated as an ugly number. Input is within the 32-bit signed integer range: [âˆ’2^31, 2^31 âˆ’ 1]. æŠŠåªåŒ…å«è´¨å› å­2ã€3å’Œ5çš„æ•°ç§°ä½œä¸‘æ•°ï¼ˆUgly Numberï¼‰ã€‚ä¾‹å¦‚6ã€8éƒ½æ˜¯ä¸‘æ•°ï¼Œä½†14ä¸æ˜¯ï¼Œå› ä¸ºå®ƒåŒ…å«è´¨å› å­7ã€‚ ä¹ æƒ¯ä¸Šæˆ‘ä»¬æŠŠ1å½“åšæ˜¯ç¬¬ä¸€ä¸ªä¸‘æ•°ã€‚ æ€è·¯ ä¸‘æ•°å°±æ˜¯å› å­ä¸èƒ½åŒ…å«é™¤äº†2ï¼Œ3ï¼Œ5ä»¥å¤–çš„æ•°ï¼Œ1ä¹Ÿæ˜¯ä¸‘æ•°ã€‚ ä»Ž2å¼€å§‹ï¼Œå°†né™¤ä»¥2ï¼Œä¸€ç›´é™¤åˆ°ä¸åŒ…å«2è¿™ä¸ªå› å­ä¸ºæ­¢ï¼›ç„¶åŽå¼€å§‹æ•´é™¤3ï¼›å¼€å§‹æ•´é™¤5;æœ€åŽå°†2ï¼Œ3ï¼Œ5ä¸‰ä¸ªå› å­é™¤å°½ï¼Œä¸‘æ•°å¿…ä¸º1ï¼Œåˆ¤æ–­æ˜¯å¦ä¸º1å³å¯ã€‚ å¯ä»¥ç›´æŽ¥å†™æˆfor(int i=2;i&lt;=5;i++)ï¼Œé‡Œé¢åŒ…å«4ï¼Œå› ä¸º4å¯ä»¥æ‹†æˆ2*2,ä¸å½±å“ä¸‘æ•°çš„å®šä¹‰ã€‚ C++ code1234567891011class Solution &#123;public: bool isUgly(int num) &#123; for(int i=2;i&lt;=5&amp;&amp;num;i++) &#123; while(num%i==0) num/=i; &#125; return num==1; &#125;&#125;; ç¬¬äºŒé¢˜æ‰¾åˆ°ç¬¬nä¸ªä¸‘æ•° Write a program to find the n-th ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. Example: 123Input: n = 10Output: 12Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers. Note: 1 is typically treated as an ugly number. n does not exceed 1690. æ€è·¯ The naive approach is to call isUgly for every number until you reach the nth one. Most numbers are not ugly. Try to focus your effort on generating only the ugly ones. An ugly number must be multiplied by either 2, 3, or 5 from a smaller ugly number. The key is how to maintain the order of the ugly numbers. Try a similar approach of merging from three sorted lists: L1, L2, and L3. Assume you have Uk, the kth ugly number. Then Uk+1 must be Min(L1 2, L2 3, L3 * 5). ç»†èŠ‚ uglynumå®¹å™¨ä¸­çš„æ¯ä¸€ä¸ªæ•°éƒ½è¦ç»è¿‡2ï¼Œ3ï¼Œ5çš„æ´—ç¤¼ï¼Œå–åˆ°æŽ¥å—æ´—ç¤¼çš„æ•°ä¸­æœ€å°çš„ä¸€ä¸ªä½œä¸ºå‹‡è€…å¹¶æ”¾å…¥ä¸‘æ•°å®¹å™¨ä¸­ã€‚å¦‚æžœè¢«é€‰ä¸­çš„å‹‡è€…æ˜¯ç»è¿‡2æ´—ç¤¼çš„ï¼Œé‚£ä¹ˆå°±è®©2å–æ´—ç¤¼å®¹å™¨ä¸­çš„ä¸‹ä¸€ä¸ªæ•°ï¼Œæ‰€ä»¥2çš„æŒ‡é’ˆ++ ä¸ºä»€ä¹ˆä¸ç”¨if elseåˆ¤æ–­å‘¢ï¼Œå› ä¸ºåœ¨é€‰ä¸­æœ€å°çš„æ•°ä¸­ï¼Œæ˜¯æœ€å°å…¬å€æ•°ï¼Œæ‰€ä»¥æœ‰å¯èƒ½å› å­åŒ…å«2ï¼Œ3ï¼Œ5ï¼Œæ‰€ä»¥åªè¦åˆ¤æ–­æ˜¯ä¸æ˜¯å½“å‰æŒ‡é’ˆæ‰€æŒ‡æ•°çš„å€æ•°å°±å¥½ï¼Œå¦‚æžœæ˜¯çš„è¯ï¼Œå°±è¦æ´—ç¤¼ä¸‘æ•°å®¹å™¨ä¸­çš„ä¸‹ä¸€ä¸ªæ•°ã€‚ C++ code123456789101112131415161718class Solution &#123;public: int GetUglyNumber_Solution(int index) &#123; if(index&lt;=6)return index; vector&lt;int&gt; a; a.push_back(1); int t2=0,t3=0,t5=0; while(a.size()&lt;index)//è¿™é‡Œä¸èƒ½ç”¨ç­‰å· &#123; a.push_back(min(min(a[t2]*2,a[t3]*3),a[t5]*5));//æ­¤æ—¶é¢„æ¼”ï¼ŒæŒ‡é’ˆè¿˜æ²¡æœ‰åŠ¨ //åˆ¤æ–­æ–°åŠ å…¥çš„ä¸‘æ•°æ˜¯ä¸æ˜¯å½“å‰æ¯ä¸ªå› å­æŒ‡é’ˆçš„å€æ•°ï¼Œå¦‚æžœæ˜¯çš„è¯ï¼Œå°±å¾€å‰ç§»åŠ¨ä¸€æ ¼ï¼Œè¯´æ˜Žå·²ç»å¯¹æ—§ä¸‘æ•°åšäº†ä¹˜ä»¥å› å­çš„å¤„ç†äº† if(a.back()==a[t2]*2) t2++; if(a.back()==a[t3]*3) t3++; if(a.back()==a[t5]*5) t5++;//è¿™é‡Œåƒä¸‡ä¸èƒ½ç”¨if elseå•Šï¼ï¼ &#125; return a.back(); &#125;&#125;; æ€»ç»“ å…³é”®ç‚¹æ˜¯ç»´æŠ¤å¥½ä¸‘æ•°çš„é¡ºåºï¼Œèžåˆä¸‰ä¸ªæœ‰åºåºåˆ—çš„æœ€å°å€¼ï¼Œè¿™ä¸ªæœ€å°å€¼åŠ å…¥åˆ°ä¸‘æ•°æ•°ç»„ä¸­ï¼Œä¹Ÿæ˜¯æœ‰åºçš„ã€‚ å› ä¸ºä¸‘æ•°æ•°ç»„æ˜¯ä¸€ä¸ªæœ‰åºçš„çš„æ•°ç»„ï¼Œæƒ³åˆ°ç”¨DPæ¥è§£å†³ï¼ŒDPçš„ç²¾é«“å°±æ˜¯æŠŠå¤§é—®é¢˜åˆ†è§£æˆå°é—®é¢˜ï¼Œè€Œä¸”è¦ä¿å­˜å°é—®é¢˜çš„è§£ã€‚æ€Žä¹ˆä¿å­˜å‘¢ï¼Œå¯ä»¥å¼€ä¸‰ä¸ªæ•°ç»„ï¼Œä½†æ˜¯ç”¨æŒ‡é’ˆä¼šæ›´æ–¹ä¾¿ã€‚æœ¬é¢˜ç”¨ä¸‰ä¸ªæŒ‡é’ˆï¼Œä»¥ä¸‹æ ‡çš„å½¢å¼ï¼Œa[t2],a[t3],a[t5],æ¥åˆ†åˆ«æŒ‡å‘ä¸‘æ•°å®¹å™¨ä¸­è¦ä¹˜ä»¥2ï¼Œ3ï¼Œ5çš„æ•°ã€‚ æœ€æ–°çš„ä¸‘æ•°å°±æ˜¯åœ¨è¿™ä¸‰ä¸ªæŒ‡é’ˆæ‰€æŒ‡çš„æ•°ä¸Šå†åˆ†åˆ«ä¹˜ä»¥2ï¼Œ3ï¼Œ5åŽï¼Œå…¶ä¸­çš„æœ€å°ä¸€ä¸ªã€‚æ–°çš„ä¸‘æ•°ä¸­å¯èƒ½ä¹Ÿè¿˜æœ‰åˆ«çš„ä¸¤ä¸ªå› å­ï¼Œæ‰€ä»¥è¦åˆ¤æ–­æ˜¯å¦æ˜¯å…¶ä»–å› å­çš„å€æ•°ï¼Œç„¶åŽç§»åŠ¨ç›¸å…³çš„æŒ‡é’ˆï¼Œæ³¨æ„æ¯ä¸ªå› å­éƒ½è¦åˆ¤æ–­ã€‚]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>pointer</tag>
        <tag>Dynamic Programming</tag>
        <tag>Math</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ STLç¯‡ ä»¿å‡½æ•°]]></title>
    <url>%2F2019%2F03%2F23%2FC-STL%E7%AF%87-%E4%BB%BF%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[å¼•å…¥ å…­å¤§éƒ¨ä»¶ä¹‹ä¸€ã€‚åªä¸ºç®—æ³•æœåŠ¡ï¼Œæ¯”å¦‚æŽ’åºï¼Œç´¯åŠ ç­‰ç®—æ³•ï¼Œå¦‚æžœéœ€è¦è‡ªå®šä¹‰å‡†åˆ™ï¼Œå°±éœ€è¦è‡ªå·±å†™ä»¿å‡½æ•°é™„åŠ åˆ°STLä¸­åŽ»ã€‚ å¿…é¡»é‡è½½()ï¼Œæ¨¡ä»¿å‡½æ•°ã€‚ ä¸‰å¤§åˆ†ç±»ï¼šç®—æœ¯ç±» Arithmetic;é€»è¾‘è¿ç®—ç±» Logical;ç›¸å¯¹å…³ç³»ç±» Relational 123456789101112//ç®—æœ¯ç±» Arithmetictemplate&lt;class T&gt; struct plus:public binary_function&lt;T,T,T&gt;&#123; T operator()(const T&amp;x,const T&amp;y) const &#123;return x+y;&#125; &#125;;template&lt;class T&gt; struct minus:public binary_function&lt;T,T,T&gt;&#123; T operator()(const T&amp;x,const T&amp;y) const &#123;return x-y;&#125; &#125;; 123456//é€»è¾‘è¿ç®—ç±» Logicaltemplate&lt;class T&gt; struct logical_and:public binary_function&lt;T,T,bool&gt;&#123; bool operator()(const T&amp;x,const T&amp;y) const &#123;return x&amp;&amp;y;&#125; &#125;; 123456789101112131415//ç›¸å¯¹å…³ç³»ç±» Relationaltemplate&lt;class T&gt; struct equal_to:public binary_function&lt;T,T,bool&gt;&#123; bool operator()(const T&amp;x,const T&amp;y) const &#123;return x==y;&#125; &#125;;template&lt;class T&gt; struct less:public binary_function&lt;T,T,bool&gt;&#123; bool operator()(const T&amp;x,const T&amp;y) const &#123;return x&lt;y;&#125; &#125;;template&lt;typename Iterator,typename Cmp&gt;Algorithm(Iterator itr1,Iterator itr2,Cmp comp)&#123;...&#125; to be continuedâ€¦]]></content>
      <categories>
        <category>ã€ŠC++ Primerã€‹</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>Function Object</tag>
        <tag>functors</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ å‡½æ•°ç¯‡ lambdaè¡¨è¾¾å¼]]></title>
    <url>%2F2019%2F03%2F23%2FC-%E5%87%BD%E6%95%B0%E7%AF%87-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[ä»¥ä¸‹ä¸ºä»Žwikiã€ä¾¯æ·è€å¸ˆçš„æ·±å…¥STLã€stackoverflowä¸­researchçš„èµ„æ–™ã€‚ wikic++11æä¾›äº†åŒ¿åå‡½æ•°çš„æ”¯æŒï¼Œå«åšlambdaè¡¨è¾¾å¼ï¼Œå½¢å¼å¦‚ä¸‹ï¼š 1[capture](parameters) mutable exception attribute -&gt; return_type &#123;body&#125; å¿…é¡»ç”¨[]æ‹¬èµ·æ¥çš„captureåˆ—è¡¨æ¥å¼€å§‹ä¸€ä¸ªlambdaè¡¨è¾¾å¼çš„å®šä¹‰ã€‚ lambdaå‡½æ•°çš„å½¢å‚è¡¨æ¯”æ™®é€šå‡½æ•°çš„å½¢å‚è¡¨å¤šäº†ä¸‰æ¡é™åˆ¶ï¼š å‚æ•°ä¸èƒ½æœ‰ç¼ºçœå€¼ ä¸èƒ½æœ‰å¯å˜é•¿å‚æ•°åˆ—è¡¨ ä¸èƒ½æœ‰æ— åå‚æ•° å¦‚æžœæ²¡æœ‰å½¢å‚ï¼Œä¸”æ²¡æœ‰mutableã€exceptionã€attributeå£°æ˜Žï¼Œå‚æ•°çš„åœ†æ‹¬å·å¯ä»¥çœç•¥ã€‚å¦‚æžœæœ‰å£°æ˜Žï¼Œå³ä½¿å‚æ•°ä¸ºç©ºï¼Œä¹Ÿä¸èƒ½çœç•¥ã€‚ å¦‚æžœå‡½æ•°ä½“å°±åªæœ‰ä¸€ä¸ªreturnè¯­å¥ï¼Œæˆ–è€…è¿”å›žå€¼ä¸ºvoidï¼Œé‚£ä¹ˆè¿”å›žå€¼ç±»åž‹å£°æ˜Žå¯ä»¥çœç•¥ï¼š 1[capture](para)&#123;body&#125; Example1234[](int x,int y)&#123;return x+y;&#125;//returnä¸­éšå¼èŽ·å¾—è¿”å›žå€¼ç±»åž‹ï¼Œè¿”å›žå€¼ç±»åž‹æ˜¯decltype(x+y)ã€‚[](int&amp; x)&#123;++x;&#125;//æ²¡æœ‰returnè¯­å¥ï¼Œè¿”å›žå€¼ä¸ºvoid[]()&#123;++global_x;&#125;[]&#123;++global_x;&#125;//æ²¡æœ‰å‚æ•°ï¼Œå¯ä»¥çœç•¥() é—­åŒ… lambdaå‡½æ•°å¯ä»¥æ•èŽ·lambdaå‡½æ•°å¤–çš„å…·æœ‰automatic storage durationçš„å˜é‡ï¼Œå³å‡½æ•°çš„å±€éƒ¨å˜é‡ä¸Žå‡½æ•°å½¢å‚å˜é‡ã€‚å‡½æ•°ä½“ä¸Žè¿™äº›å˜é‡çš„é›†åˆåˆèµ·æ¥ç§°åšé—­åŒ…)ã€‚ è¿™äº›å¤–éƒ¨å˜é‡åœ¨å£°æ˜Žlambdaè¡¨è¾¾å¼æ—¶åˆ—åœ¨åœ¨æ–¹æ‹¬å·[]ä¸­ã€‚ç©ºçš„æ–¹æ‹¬å·è¡¨ç¤ºæ²¡æœ‰å¤–ç•Œå˜é‡è¢«captureæˆ–è€…æŒ‰ç…§é»˜è®¤æ–¹å¼æ•èŽ·å¤–ç•Œå˜é‡ã€‚è¿™äº›å˜é‡è¢«ä¼ å€¼æ•èŽ·æˆ–è€…å¼•ç”¨æ•èŽ·ã€‚ å¯¹äºŽä¼ å€¼æ•èŽ·çš„å˜é‡ï¼Œé»˜è®¤ä¸ºåªè¯»ï¼ˆè¿™æ˜¯ç”±äºŽlambdaè¡¨è¾¾å¼ç”Ÿæˆçš„ä¸ºä¸€ä¸ªå‡½æ•°å¯¹è±¡ï¼Œå®ƒçš„operator()æˆå‘˜ç¼ºçœæœ‰constå±žæ€§ï¼‰ã€‚ä¿®æ”¹è¿™äº›ä¼ å€¼æ•èŽ·å˜é‡å°†å¯¼è‡´ç¼–è¯‘æŠ¥é”™ã€‚ ä½†åœ¨lambdaè¡¨è¾¾å¼çš„å‚æ•°è¡¨çš„åœ†æ‹¬å·åŽé¢ä½¿ç”¨mutableå…³é”®å­—ï¼Œå°±å…è®¸lambdaå‡½æ•°ä½“å†…çš„è¯­å¥ä¿®æ”¹ä¼ å€¼æ•èŽ·å˜é‡ï¼Œè¿™äº›ä¿®æ”¹ä¸Žlambdaè¡¨è¾¾å¼ï¼ˆå®žé™…ä¸Šæ˜¯ç”¨å‡½æ•°å¯¹è±¡å®žçŽ°ï¼‰æœ‰ç›¸åŒçš„ç”Ÿå‘½æœŸï¼Œä½†ä¸å½±å“è¢«ä¼ å€¼æ•èŽ·çš„å¤–éƒ¨å˜é‡çš„å€¼ã€‚ lambdaå‡½æ•°å¯ä»¥ç›´æŽ¥ä½¿ç”¨å…·æœ‰staticå­˜å‚¨æœŸçš„å˜é‡ã€‚å¦‚æžœåœ¨lambdaå‡½æ•°çš„æ•èŽ·åˆ—è¡¨ä¸­ç»™å‡ºäº†staticå­˜å‚¨æœŸçš„å˜é‡ï¼Œç¼–è¯‘æ—¶ä¼šç»™å‡ºè­¦å‘Šï¼Œä»ç„¶æŒ‰ç…§lambdaå‡½æ•°ç›´æŽ¥ä½¿ç”¨è¿™äº›å¤–éƒ¨å˜é‡æ¥å¤„ç†ã€‚å› æ­¤å…·æœ‰staticå­˜å‚¨æœŸçš„å˜é‡å³ä½¿è¢«å£°æ˜Žä¸ºä¼ å€¼æ•èŽ·ï¼Œä¿®æ”¹è¯¥å˜é‡å®žé™…ä¸Šç›´æŽ¥ä¿®æ”¹äº†è¿™äº›å¤–éƒ¨å˜é‡ã€‚ ç¼–è¯‘å™¨ç”Ÿæˆlambdaå‡½æ•°å¯¹åº”çš„å‡½æ•°å¯¹è±¡æ—¶ï¼Œä¸ä¼šç”¨å‡½æ•°å¯¹è±¡çš„æ•°æ®æˆå‘˜æ¥ä¿æŒè¢«â€œæ•èŽ·â€çš„staticå­˜å‚¨æœŸçš„å˜é‡ã€‚ 123456[]//æ²¡æœ‰å®šä¹‰ä»»ä½•å˜é‡ï¼Œä½†æ˜¯å¿…é¡»åˆ—å‡ºç©ºçš„æ–¹æ‹¬å·ã€‚lambdaè¡¨è¾¾å¼ä¸­å°è¯•ä½¿ç”¨ä»»ä½•å¤–éƒ¨å˜é‡éƒ½ä¼šå¯¼è‡´ç¼–è¯‘é”™è¯¯ã€‚[x,&amp;y] //xæŒ‰å€¼ä¼ é€’ï¼ŒyæŒ‰å¼•ç”¨ä¼ é€’[&amp;]//ä»»ä½•è¢«ä½¿ç”¨çš„å¤–éƒ¨å˜é‡éƒ½æŒ‰å¼•ç”¨ä¼ é€’[=]//ä»»ä½•è¢«ä½¿ç”¨çš„å¤–éƒ¨å˜é‡éƒ½æŒ‰å€¼ä¼ é€’[&amp;,x]//xæŒ‰å€¼ä¼ å…¥ï¼Œå…¶å®ƒå˜é‡æŒ‰å¼•ç”¨ä¼ å…¥[=,&amp;z]//zæŒ‰å¼•ç”¨ä¼ å…¥ï¼Œå…¶å®ƒå˜é‡æŒ‰å€¼ä¼ å…¥ Example1234vector&lt;int&gt; some_list&#123;1,2,3,4,5&#125;;int total=0;for_each(begin(some_list),end(some_list), [&amp;total](int x)&#123;total+=x;&#125;); thisæŒ‡é’ˆåœ¨ç±»çš„éžé™æ€æˆå‘˜å‡½æ•°ä¸­å®šä¹‰çš„lambdaè¡¨è¾¾å¼å¯ä»¥æ˜¾å¼æˆ–éšå¼æ•æ‰thisæŒ‡é’ˆï¼Œä»Žè€Œå¯ä»¥å¼•ç”¨æ‰€åœ¨ç±»å¯¹è±¡çš„æ•°æ®æˆå‘˜ä¸Žå‡½æ•°æˆå‘˜ã€‚ lambdaå‡½æ•°çš„å‡½æ•°ä½“ä¸­ï¼Œå¯ä»¥è®¿é—®ä¸‹è¿°å˜é‡ï¼š å‡½æ•°å‚æ•° å±€éƒ¨å£°æ˜Žçš„å˜é‡ ç±»æ•°æ®æˆå‘˜ï¼šè¦æ±‚lambdaè¡¨è¾¾å¼å£°æ˜Žåœ¨ç±»æˆå‘˜å‡½æ•°ä¸­ï¼Œå¯¹è±¡çš„thisæŒ‡é’ˆå¿…éœ€æ˜¾å¼æ•èŽ·å£°æ˜Žã€‚ å…·æœ‰é™æ€å­˜å‚¨æœŸçš„å˜é‡ï¼ˆå¦‚å…¨å±€å˜é‡ï¼‰ è¢«æ•èŽ·çš„å¤–éƒ¨å˜é‡ æ˜¾å¼æ•èŽ·çš„å˜é‡ éšå¼æ•èŽ·çš„å˜é‡ï¼Œä½¿ç”¨é»˜è®¤æ•èŽ·æ¨¡å¼ï¼ˆä¼ å€¼æˆ–å¼•ç”¨ï¼‰æ¥è®¿é—®ã€‚ æ¨¡æ¿ç±»åž‹lambdaå‡½æ•°çš„æ•°æ®ç±»åž‹æ˜¯å‡½æ•°å¯¹è±¡ï¼Œä¿å­˜æ—¶å¿…é¡»ç”¨std::functionæ¨¡æ¿ç±»åž‹æˆ–autoå…³é”®å­—ã€‚ 123456789101112131415161718192021222324252627282930#include &lt;vector&gt;#include &lt;functional&gt;#include &lt;iostream&gt;using namespace std;double eval(std::function &lt;double(double)&gt; f, double x = 2.0)&#123; return f(x);&#125;int main()&#123; std::function&lt;double(double)&gt; f0 = [](double x) &#123;return 1; &#125;; auto f1 = [](double x) &#123;return x; &#125;; decltype(f0) fa[3] = &#123; f0,f1,[](double x) &#123;return x*x; &#125; &#125;; std::vector&lt;decltype(f0)&gt; fv = &#123; f0,f1 &#125;; fv.push_back([](double x) &#123;return x*x; &#125;);//fv.size()=3 for (int i = 0; i&lt;fv.size(); i++) std::cout &lt;&lt; fv[i](2.0) &lt;&lt; std::endl;//1,2,4 for (int i = 0; i&lt;3; i++) std::cout &lt;&lt; fa[i](2.0) &lt;&lt; std::endl;//1,2,4 for (auto &amp;f : fv) std::cout &lt;&lt; f(2.0) &lt;&lt; std::endl;//1,2,4 for (auto &amp;f : fa) std::cout &lt;&lt; f(2.0) &lt;&lt; std::endl;//1,2,4 std::cout &lt;&lt; eval(f0) &lt;&lt; std::endl;//1 std::cout &lt;&lt; eval(f1) &lt;&lt; std::endl;//2 std::cout &lt;&lt; eval([](double x) &#123;return x*x; &#125;) &lt;&lt; std::endl;//4 return 0;&#125; C++11 ä¾¯æ· C++ 11 introdued lamndas,allowing the definition of inline functionality,which can be used as a parameter or a local object. Lambdas change the way the C++ standard library is used. ä»¿å‡½æ•°ã€‚å…¶å®žæ˜¯ä¸€ä¸ªå¯¹è±¡ç±»åž‹ã€‚ç”¨()å¯ä»¥ç›´æŽ¥è°ƒç”¨ï¼Œä¸€ä¸ªä»¿å‡½æ•°å¯¹è±¡ã€‚ A lambda is a definition of functionality that can be defined inside statements and expressions. You can use a lambda as an inline function. The minimal lambda funcion hsa no paramemter and simply does something: Lambdas The type of a lambda is an anonymous function object(or functor) that is unique for each lambda expression. To declare objects of that type,you need templates or auto. If you need type ,you can use decltype(),which is ,required to pass a lambda as hash function or ordering or sorting criterion to associative or unordered containers. 1234567auto cmp=[](const Person&amp;p1,const Person&amp;p2)&#123; return p1.lastname()&lt;p2.lastname()|| (p1.lastname()==p2.lastname()&amp;&amp; p1.firstname()&lt;p2.firstname());&#125;;...std::set&lt;Person,decltype(cmp)&gt; coll(cmp); You need the type of the lambda for the declaration of the set, decltype must be used,which yields the type of a lambda object,such as cmp. Note that you also have to pass the lambda object to the constructor of coll;otherwise,coll would call the default constructor for the sorting criterion(å‡†åˆ™) passed,and by rule lambdas have no default constructor and no assignment operator.(lambdaæ²¡æœ‰é»˜è®¤æž„é€ å‡½æ•°ï¼Œä¹Ÿæ²¡æœ‰èµ‹å€¼æ“ä½œã€‚) So,for a sorting criterion,a class defining the function objects might still be more intuitive.ï¼ˆå¦‚æžœç”¨lambdaå†™æŽ’åºå‡†åˆ™ï¼Œç”±äºŽæ²¡æœ‰é»˜è®¤æž„é€ å‡½æ•°ï¼Œæ‰€ä»¥ä½¿ç”¨çš„æ—¶å€™å®¹æ˜“å‡ºé”™ã€‚ 12345678910111213141516171819template&lt;class Key, class Compare=less&lt;Key&gt;, class Alloc=alloc&gt;class set&#123;public://typedefs:...typedef Compare key_compare;typedef Compare value_compare;private:typedef rb_tree&lt;key_type,value_type, identity&lt;value_type&gt;, key_compare,Alloc&gt;rep_type;rep_type t;//red-black tree representing setpublic:...set():t(Compare())&#123;&#125;//è°ƒç”¨é»˜è®¤æž„é€ å‡½æ•°explicit set(const Compare&amp; comp):t(const)&#123;&#125;&#125; Function objects are a very powerful way to customize the behavior of STL algorithms,and can encapsulate both code and data (unlike plain functions). But Function objects are inconvenient to define because of the need to entire classes. Moreover,they are not defined in the place in yout source code where you are trying to use them, and the non-locality makes them more difficult to use. Libraries have attempted to mitigate(å‡è½») some of the problems of verbosity(å†—é•¿) and non-locality ,but dont offer much help because the syntax becomes complicated and the compiler errors are not very friendly. Using function objects from libraries is also less efficient since the function objects defined as data members are not in-lined. Lambda expressions address these problems. The following code snippet shows a lambda expression used in a program to integers between variables x and y from a vector of integers. 123456789vector&lt;int&gt; vi&#123;5,28,50,83,70,590,245,59,24&#125;;int x = 30;int y = 100;vi.erase(remove_if(vi.begin(),vi.end(), [x,y](int n)&#123;return x&lt;n&amp;&amp;n&lt;y;&#125;), vi.end());//æŠŠ(30,100)å†…çš„æ•°å­—æ‹¿æŽ‰for(auto i:vi) cout&lt;&lt;i&lt;&lt;'';//5 28 590 245 24cout&lt;&lt;endl; 12345678910111213class LambdaFunctor&#123;public: LambdaFunctor(int a,int b):m_a(a),m_b(b)&#123;&#125; bool operator()(int n) const&#123; return m_a&lt;n&amp;&amp;n&lt;m_b; &#125;private: int m_a; int m_b; &#125;;v.erase(remove_if(v.begin(),v.end(), LambdaFunctor(x,y)), v.end()); stackoverflowref:stackoverflow Q: 123What is a lambda expression in C++11? When would I use one? What class of problem do they solve that wasn't possible prior to their introduction?A few examples, and use cases would be useful. A: The problem C++ includes useful generic functions like std::for_each and std::transform, which can be very handy. Unfortunately they can also be quite cumbersome to use, particularly if the functor you would like to apply is unique to the particular function. 123456789101112131415#include &lt;algorithm&gt;#include &lt;vector&gt;namespace &#123; struct f &#123; void operator()(int) &#123; // do something &#125; &#125;;&#125;void func(std::vector&lt;int&gt;&amp; v) &#123; f f; std::for_each(v.begin(), v.end(), f);&#125; If you only use f once and in that specific place it seems overkill to be writing a whole class just to do something trivial and one off. In C++03 you might be tempted to write something like the following, to keep the functor local: 12345678void func2(std::vector&lt;int&gt;&amp; v) &#123; struct &#123; void operator()(int) &#123; // do something &#125; &#125; f; std::for_each(v.begin(), v.end(), f);&#125; however this is not allowed, f cannot be passed to a template function in C++03. The new solutionC++11 introduces lambdas allow you to write an inline, anonymous functor to replace the struct f. For small simple examples this can be cleaner to read (it keeps everything in one place) and potentially simpler to maintain, for example in the simplest form: 123void func3(std::vector&lt;int&gt;&amp; v) &#123; std::for_each(v.begin(), v.end(), [](int) &#123; /* do something here*/ &#125;);&#125; Lambda functions are just syntacticï¼ˆå¥æ³•ï¼‰ sugar for anonymous functors. Return typesIn simple cases the return type of the lambda is deduced(æŽ¨å¯¼) for you, e.g.: 12345void func4(std::vector&lt;double&gt;&amp; v) &#123; std::transform(v.begin(), v.end(), v.begin(), [](double d) &#123; return d &lt; 0.00001 ? 0 : d; &#125; );&#125; however when you start to write more complex lambdas you will quickly encounter cases where the return type cannot be deduced by the compiler, e.g.: 12345678910void func4(std::vector&lt;double&gt;&amp; v) &#123; std::transform(v.begin(), v.end(), v.begin(), [](double d) &#123; if (d &lt; 0.0001) &#123; return 0; &#125; else &#123; return d; &#125; &#125;);&#125; -&gt;ï¼šexplicitly specify a return typeTo resolve this you are allowed to explicitly specify a return type for a lambda function, using -&gt; T: 12345678910void func4(std::vector&lt;double&gt;&amp; v) &#123; std::transform(v.begin(), v.end(), v.begin(), [](double d) -&gt; double &#123; if (d &lt; 0.0001) &#123; return 0; &#125; else &#123; return d; &#125; &#125;);&#125; â€œCapturingâ€ variablesSo far weâ€™ve not used anything other than what was passed to the lambda within it, but we can also use other variables, within the lambda. If you want to access other variables you can use the capture clause (the [] of the expression), which has so far been unused in these examples, e.g.: 12345678910void func5(std::vector&lt;double&gt;&amp; v, const double&amp; epsilon) &#123; std::transform(v.begin(), v.end(), v.begin(), [epsilon](double d) -&gt; double &#123; if (d &lt; epsilon) &#123; return 0; &#125; else &#123; return d; &#125; &#125;);&#125; You can capture by both reference and value, which you can specify using &amp; and =respectivelyã€‚ï¼ˆè§é—­åŒ…ï¼‰ The generated operator() is const by default, with the implication(æ„ä¹‰) that captures will be const when you access them by default. This has the effect that each call with the same input would produce the same result, however you can mark the lambda as mutable to request that the operator() that is produced is not const.]]></content>
      <categories>
        <category>ã€ŠC++ Primerã€‹</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>Function Object</tag>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[è®°ä¸€æ¬¡æ¸¸æˆæ²™é¾™åˆ†äº«ä¼š]]></title>
    <url>%2F2019%2F03%2F22%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%B8%B8%E6%88%8F%E6%B2%99%E9%BE%99%E5%88%86%E4%BA%AB%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[Messiahå¼•æ“Žå›žå¿†å½• Sparse Voxel Octree Cone Tracing C++ Hot Reload è¿­ä»£/é‡åšçš„é€‰æ‹© å¤©ä¸‹å¼•æ“Žï¼š æ’ä»¶å±‚ï¼šPhysX/fMod/Behavior/umbra/BEAST æ¸¸æˆå±‚ï¼šAI/å¯»è·¯/è½¦è¾†/åœºæ™¯ç®¡ç†/æ¸²æŸ“ç®¡çº¿/æ¸²æŸ“å¼•æ“Ž/å…‰ç…§/æè´¨/å¤©æ°” æ¡†æž¶å±‚ï¼šä¸»å¾ªçŽ¯-&gt;Thread pool-&gt;IO /å†…å­˜ç®¡ç†/ç½‘ç»œé€šä¿¡/è„šæœ¬ç³»ç»Ÿ ç³»ç»Ÿå±‚ï¼šWindows(è·¨å¹³å°æŠ½è±¡ï¼Œä¸»æ‰‹æ¸¸å¸‚åœºï¼‰/Direct Xï¼ˆè·¨APIæŠ½è±¡ï¼‰ 90%çš„æ‰‹æœºéƒ½æ˜¯å››æ ¸ä»¥ä¸Šï¼Œåœºæ™¯æ›´æ–°-&gt;æ¸²æŸ“å¼•æ“Ž-&gt;å›¾å½¢API Main Thread:Tick-&gt;Render-&gt;Present Game Thread:Tick-&gt;Render Render Thread:Prensent-&gt;Commit to Device-&gt;Present çƒ˜ç„™ï¼šé¢„è®¡ç®—å…‰ç…§ï¼Œå¤§éƒ¨åˆ†3Dæ‰‹æ¸¸é€‰æ‹©çƒ˜ç„™ã€‚CloudGI:å®Œå…¨è·‘åœ¨GPUä¸Šçš„çƒ˜åŸ¹å¼•æ“Žã€‚ æ¸¸æˆæˆé•¿ä¹‹è·¯ CSç†è®ºï¼šç®—æ³•/æ•°æ®ç»“æž„/è®¾è®¡æ¨¡å¼ã€‚å›¾å½¢å­¦ã€‚ç‰©ç†ä»¿çœŸã€‚åˆ†å¸ƒå¼è®¡ç®—ã€‚é«˜æ€§èƒ½ç½‘ç»œã€‚äººå·¥æ™ºèƒ½ã€‚ è„šæœ¬pythonã€‚S/Cå…¨æœç§’çƒ­æ›´ã€‚æ·±åº¦æ”¹é€ Pythonè™šæ‹Ÿæœºã€‚ C/C++:æžå…¶é«˜æ•ˆçš„è¯­è¨€ï¼Œå¯¹æ•ˆçŽ‡æœ‰æžè‡´è¦æ±‚çš„æ ¸å¿ƒæ¨¡å—ã€‚C++17ã€‚å¤šçº¿ç¨‹ä»»åŠ¡ç³»ç»Ÿã€‚3Dæ¸²æŸ“å™¨ã€‚ç½‘ç»œåº•åº“ã€‚æ•°å­¦åº“ã€‚ æœ‰é™çŠ¶æ€æœºFSMï¼šä»¥æ•°æ®é©±åŠ¨ä»£ç ï¼Œè€Œä¸æ˜¯ä»£ç å°±æ˜¯æ•°æ®ã€‚ å¥½çš„ä»£ç å‡ºæ¥æ­¥éœ€è¦å†™ç¬¬äºŒæ¬¡ï¼ˆDRYåŽŸåˆ™ï¼‰ï¼Œè¿™å°±æ˜¯ç¨‹åºå‘˜ä¹‹é—´çš„å·®åˆ«äº†ï¼Œè¿™é‡Œé¢æ°´å¤ªæ·±äº†ï¼ŒæŠ€æœ¯æ ˆçš„èƒŒåŽæ˜¯æ·±åŽšæ‰Žå®žçš„ç†è®ºç®—æ³•æ•°æ®ç»“æž„åŸºç¡€åœ¨åšæ”¯æ’‘ã€‚ åº”è¯¥æˆä¸ºä¸€ä¸ªå‘æ˜Žæµæ°´çº¿çš„ç¨‹åºå‘˜ï¼Œè€Œä¸æ˜¯åœ¨æµæ°´çº¿ä¸Šä½œä¸šçš„ç¨‹åºå‘˜ã€‚ ç”¨ä»£ç åŽ»æå‡ç”Ÿäº§æ•ˆçŽ‡ï¼Œè€Œä¸æ˜¯æˆä¸ºç”Ÿäº§æ•ˆçŽ‡çš„ç“¶é¢ˆã€‚ è¡Œä¸ºæ ‘ï¼ˆBehavior Tree)ï¼šå››ä¸ªç»“ç‚¹+1ä¸ªè§„åˆ™ã€‚ è§’è‰²ç§»åŠ¨åŒæ­¥ï¼šå¯¹å®žæ—¶æ€§æœ‰æžè‡´è¦æ±‚ï¼Œtcpåè®®æ— æ³•æ»¡è½½æžè‡´çš„ä½Žå»¶è¿Ÿéœ€æ±‚ï¼ˆå®ƒçš„æ‹¥å¡žæŽ§åˆ¶ï¼Œå®Œå…¨å¯é çš„ç‰¹æ€§ï¼‰ï¼Œæ‰€ä»¥ç”¨udpçš„ä½Žå»¶è¿Ÿåè®®ï¼ˆæ›´ä¼˜çš„ä¸¢åŒ…é‡ä¼ ç®—æ³•ï¼Œåº”ç­”æ¨¡åž‹ï¼Œæ”¯æŒåŠå¯é åŒ…ã€‚ï¼‰400mså»¶è¿Ÿï¼Œ40%ä¸¢åŒ…æžé™å·¥å†µä¸‹ä¾ç„¶èƒ½å·¥ä½œã€‚ èˆªä½æŽ¨æµ‹ç®—æ³•ï¼ˆDead Reckoning)ã€‚ ä¸€äº›ç¢Žç¢Žå¿µäººç±»åœ¨ç”Ÿæ´»ä¸­è¦å—åˆ°ç²¾ç¥žä¸Žç‰©è´¨çš„åŒé‡æŸç¼šï¼Œåœ¨è¿™äº›æŸç¼šä¸­å°±å¤±åŽ»äº†ç†æƒ³å’Œè‡ªç”±ã€‚äºŽæ˜¯äººä»¬ç”¨å‰©ä½™çš„ç²¾ç¥žåˆ›é€ ä¸€ä¸ªè‡ªç”±çš„ä¸–ç•Œï¼Œå®ƒå°±æ˜¯æ¸¸æˆã€‚ è·Ÿç‰›å¥¶è€å¸ˆä¸€æ ·ï¼Œæ¸¸æˆå·²ç„¶æ˜¯ä¸€ç§ç²¾ç¥žä¸Šçš„å¯„æ‰˜ã€‚å°½ç®¡çŽ°åœ¨çŽ©æ¸¸æˆçš„æ—¶é—´å·²ç»åŽ‹æ¦¨åˆ°æ²¡æœ‰äº†ï¼Œæ˜¯å› ä¸ºæƒ³æˆä¸ºä¸€ä¸ªmakerï¼Œè€Œä¸æ˜¯æ™®é€šçš„playerï¼Œæ‰€ä»¥ä¼šå¥½å¥½è¡¥æŠ€æœ¯æ ˆï¼è™½ç„¶æˆ‘çŽ°åœ¨æ°´å¹³å¾ˆèœï¼Œä½†æ˜¯åšäº†ä¸€ä¸ªä»Žå°åˆ°å¤§ä»¥æ¥ï¼Œä¸ºæ•°ä¸å¤šçš„è‡ªå·±é€‰æ‹©çš„å†³å®šï¼ˆä¸Šä¸€ä¸ªæ˜¯è½¬ç³»è€ƒè½¯ä»¶å·¥ç¨‹ï¼Œæˆ‘çœŸçš„éžå¸¸åŠªåŠ›åŽ»å®žçŽ°äº†ï¼‰ã€‚ è™½ç„¶èµ°çš„å¾ˆæ…¢ï¼Œä½†æ˜¯å¦‚æžœæ˜¯ä¸ºäº†çƒ­çˆ±ï¼Œæ–¹å‘å°±æ˜¯å¯¹çš„ã€‚å°±åƒæˆ‘å–œæ¬¢å†™ä»£ç ï¼Œå–œæ¬¢çŽ©æ¸¸æˆï¼Œå–œæ¬¢è®¡ç®—æœºï¼Œå–œæ¬¢ACGï¼Œå–œæ¬¢ä¸œæ–¹ï¼Œå–œæ¬¢LOLâ€¦â€¦å°½ç®¡æ²¡æœ‰äººå¯ä»¥æ°¸è¿œé™ªæˆ‘ä¸€èµ·åˆ†äº«è¿™äº›å¿«ä¹ï¼Œå¯æˆ‘è¿˜æ˜¯å–œæ¬¢ä»–ä»¬ï¼Œå› ä¸ºä»–ä»¬ç»™æˆ‘å¸¦æ¥äº†æ„ŸåŠ¨ï¼Œè¿™äº›æ˜¯æˆ‘ç²¾ç¥žä¸–ç•Œä¸­çš„å®è—å•Šï¼Œæˆ‘æ„¿æ„ä¸ºä»–ä»¬ä»˜å‡ºæ—¶é—´ã€é‡‘é’±ã€ç²¾åŠ›ã€‚ ä¹‹å‰æµªè´¹äº†ä¸å°‘æ—¶é—´åœ¨æ— èŠçš„äº‹æƒ…ä¸Šï¼Œå¯¼è‡´çŽ°åœ¨æŠ€æœ¯æ ˆå¤ªæµ…äº†ï¼Œä¹Ÿè®¸ç­‰æˆ‘æŠ€æœ¯åˆ°äº†ä¸€å®šçš„æ°´å¹³ï¼Œè‡ªç„¶å¯ä»¥é‡åˆ°å’Œæˆ‘è®¨è®ºè¿™äº›æŠ€æœ¯çš„å¤§ä½¬äº†å‘¢ï¼Œé‚£ç§çµæ„Ÿç¢°æ’žå‡ºçš„ç«èŠ±çœŸæ˜¯è®©äººå‘å¾€å•Šï¼]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æˆ‘çš„offerä¹‹è·¯]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%88%91%E7%9A%84offer%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[è…¾è®¯æå‰æ‰¹ åŽç«¯C++2019/3/22 â€‹ æ‰Žå¿ƒäº†ï¼Œç¬¬ä¸€æ¬¡é¢è¯•å°±æ˜¯é¢çš„è…¾è®¯çˆ¸çˆ¸ã€‚çº¦çš„æ˜¯è§†é¢‘é¢è¯•ï¼Œæˆ‘è¿˜ç‰¹æ„ç”»äº†ä¸ªå¦†ï¼Œç»“æžœæ˜¯ç”µè¯é¢è¯•ORZã€‚ æ‰“æ‹›å‘¼ çœ‹ä½ æœ€è¿‘åœ¨åˆ·é¢˜ï¼Ÿï¼ˆä»–æœ‰æˆ‘å¾®ä¿¡ï¼‰æ˜¯çš„ã€‚é‚£æˆ‘çœ‹ä½ çš„ç¬”è¯•åˆ†æ•°ä¸æ€Žä¹ˆé«˜å‘¢ã€‚emmm,æˆ‘å½“æ—¶æŒ‰é”™äº†ï¼Œä»¥ä¸ºåŽé¢æœ‰é€‰æ‹©é¢˜ã€‚é¢è¯•å®˜ï¼šåˆ«ç´§å¼ ï¼Œæˆ‘å°±è°ƒä¾ƒä½ ä¸€ä¸‹ã€‚ï¼ˆæˆ‘çœŸçš„è¶…ç´§å¼ ã€‚ è‡ªæˆ‘ä»‹ç»ï¼šæœ¬ç§‘ä¸“ä¸šã€‚ç ”ç©¶æ–¹å‘ã€‚åšçš„é¡¹ç›®ã€‚ é—®é¢˜ å•å‘é“¾è¡¨é€†è½¬ï¼šæˆ‘çªç„¶è„‘å­çŸ­è·¯ï¼Œç›´æŽ¥é—®æç¤ºã€‚ä¹‹åŽæˆ‘è¯´ç”¨ä¸‰ä¸ªæŒ‡é’ˆä»Žå¤´å¼€å§‹éåŽ†â€¦â€¦æ‰“æ–­ï¼šç®€å•æè¿°ã€‚æˆ‘è„‘å­ä¸€å›¢æµ†ç³Šï¼šæ²¡æœ‰è¯´æ¸…æ¥šã€‚â€œä½ è¯´çš„ä¹Ÿå·®ä¸å¤šæ˜¯é‚£ä¸ªæ„æ€ã€‚â€æˆ‘åŽæ¥å‘çŽ°æˆ‘è¿žå‡½æ•°å…¥å£æ£€æŸ¥çš„é²æ£’æ€§æµ‹è¯•éƒ½æ²¡æœ‰è®²ã€‚ æ•°æ®åº“ï¼ŒBæ ‘ï¼ŒBæ ‘ç´¢å¼•ï¼šä¸ä¼š(åŽæ¥æ•´ç†äº†ä¸€ç¯‡ç¬”è®°ï¼šB tree,B+ tree,B* tree,RBT,AVL) 2Gå†…å­˜æ€Žä¹ˆå®žçŽ°ï¼šhashè¡¨ã€‚â€œhashè¡¨ï¼Ÿï¼Ÿï¼Ÿâ€â€ä¸æ¸…æ¥šï¼Œå¤§æ•°é—®é¢˜æ²¡çœ‹ï¼Œbitmapï¼Ÿâ€â€œâ€¦â€¦ä¸‹ä¸€é¢˜â€ TCPä¸‰æ¬¡æ¡æ‰‹å››æ¬¡æŒ¥æ‰‹ï¼šä¸ä¼šã€‚ å¿«æŽ’ï¼šéšæœºå–ä¸€ä¸ªæ•°ï¼Œä»Žå¤´åˆ°å°¾éåŽ†æ•°ç»„ï¼Œå°çš„æ”¾åœ¨è¿™ä¸ªæ•°å·¦è¾¹ï¼Œå¤§çš„æ”¾åœ¨å³è¾¹ã€‚â€œæ—¶é—´å¤æ‚åº¦ï¼Ÿâ€ï¼šnlognã€‚ä¸ºä»€ä¹ˆï¼šå› ä¸ºæ˜¯ç”¨äºŒåˆ†æ³•çš„æ€æƒ³ï¼Œæ‰€ä»¥æ˜¯å¯¹æ•°ã€‚ç¨³å®šå—ï¼šä¸ç¨³å®šï¼Œæœ€å·®n^2ã€‚ä¸ºä»€ä¹ˆä¼šn^2ï¼šå› ä¸ºéšæœºå–å¾—æ•°å¯èƒ½æ²¡æœ‰å–å¥½ã€‚ Linuxè¿›ç¨‹æŸ¥çœ‹ï¼šä¸ä¼šã€‚ è™šå‡½æ•°ï¼šå¤šæ€çš„å®žçŽ°ï¼ŒåŸºç±»çš„è™šå‡½æ•°éœ€è¦åœ¨æ´¾ç”Ÿç±»ä¸­å®žçŽ°ï¼ŒåŠ¨æ€ç»‘å®šçš„æ—¶å€™ï¼Œç³»ç»Ÿä¼šæ ¹æ®è™šè¡¨æ‰¾åˆ°è°ƒç”¨å¯¹è±¡æ‰€æŒ‡çš„è™šæŒ‡é’ˆï¼Œç„¶åŽåœ¨ç¨‹åºè¿è¡Œçš„æ—¶å€™ï¼ŒåŽ»è°ƒç”¨é‡å†™çš„è™šå‡½æ•°ã€‚ï¼ˆè‡ªæˆ‘æ„Ÿè§‰å¾ˆå•°å—¦ Gæ˜¯Fçš„åŸºç±»ï¼ŒFæ˜¯Cçš„åŸºç±»ï¼ŒCè¿˜å¯ä»¥æœ‰ç»§æ‰¿ä¹ˆï¼šå¯ä»¥ï¼Œåªè¦æ²¡æœ‰å£°æ˜Žfinalå°±å¯ä»¥ï¼ŒC++11çš„ä¸¤ä¸ªå…³é”®å­—finalç¦æ­¢é‡å†™,overrideæ˜¾ç¤ºå£°æ˜Žæ˜¯è™šå‡½æ•°ã€‚ Cç»§æ‰¿äºŽFï¼Œå¹¶ä¸”å‘ä¸Šè½¬åž‹ï¼Œè°ƒç”¨çš„é‡å†™æ–¹æ³•æ˜¯å“ªä¸ªå¯¹è±¡çš„ï¼šCçš„ï¼Œç³»ç»Ÿä¼šæ‰¾åˆ°è™šæŒ‡é’ˆï¼Œç„¶åŽæ ¹æ®Cå¯¹è±¡çš„thisæŒ‡é’ˆï¼Œæ”¾å…¥åˆ°è°ƒç”¨æ–¹æ³•çš„å‚æ•°ä¸­ã€‚ å †çš„å®žçŽ°ï¼šSTLé‡Œé¢æœ‰ä¸€ä¸ªä¼˜å…ˆé˜Ÿåˆ—å’Œmultiset.ä¼˜å…ˆé˜Ÿåˆ—æ˜¯æœ€ï¼Ÿå †å®žçŽ°çš„ã€‚multisetæ˜¯rbtå®žçŽ°çš„æœ€ï¼Ÿå †ã€‚ï¼ˆæˆ‘å¿˜äº†ï¼Œå¤ä¹ è¿‡ä½†æ˜¯æ²¡æŽŒæ¡å¥½ã€‚ï¼‰ç®€å•çš„è¯´è¯´å»ºæœ€å°å †ï¼šè·Ÿå †é¡¶æ¯”è¾ƒï¼Œå¦‚æžœæ¯”å †é¡¶å¤§å°±æ”¾å³å­æ ‘ï¼Œç„¶åŽå†å’Œå³å­æ ‘æ¯”è¾ƒã€‚å¦‚æžœæ¯”å †é¡¶å°ï¼Œå°±äº¤æ¢ä½ç½®ï¼Œç„¶åŽå †é¡¶æ”¾å·¦å­æ ‘ã€‚ï¼ˆæˆ‘æ²¡æœ‰æŽŒæ¡å¥½ã€‚çœ‹è¿‡ä¸€ç‚¹ å†…å­˜æ³„æ¼ï¼šæŒ‡é’ˆæ²¡æœ‰åˆå§‹åŒ–ï¼Œå¯èƒ½æŒ‡å‘æŸä¸ªæœªçŸ¥çš„ä½ç½®ï¼Œé‡ŽæŒ‡é’ˆã€‚æˆ–è€…ä¸€ä¸ªå˜é‡åœ¨ç¦»å¼€ä½œç”¨åŸŸä¹‹å‰æ²¡æœ‰é‡Šæ”¾æŽ‰ä»–çš„èµ„æºï¼ŒåŽé¢æ— æ³•èŽ·å–è¿™ä¸ªå˜é‡ï¼Œå°±ä¸èƒ½é‡Šæ”¾äº†ï¼Œä¼šé€ æˆå†…å­˜æ³„æ¼ã€‚è¿™å°±æ˜¯åŸºç±»çš„æžæž„å‡½æ•°è¦å®šä¹‰æˆè™šå‡½æ•°çš„åŽŸå› ã€‚ï¼ˆè‡ªæˆ‘æ„Ÿè§‰å¾ˆå•°å—¦ mvcï¼šæ˜¯.Netçš„ä¸€ç§è®¾è®¡æ¨¡å¼ã€‚mvcåˆ†åˆ«ä»£è¡¨ä»€ä¹ˆï¼šmæ˜¯æ¨¡åž‹ã€‚væ˜¯è§†å›¾ã€‚cæ˜¯æŽ§åˆ¶å™¨ã€‚ä½œç”¨ï¼šæ¨¡åž‹æ˜¯å¯¹è±¡ã€‚væ˜¯å‰ç«¯äº¤äº’ã€‚cæ˜¯ä¸šåŠ¡é€»è¾‘è®¿é—®ã€‚ï¼ˆå¤§æ¦‚æ˜¯3-4å¹´å‰åšå¾—ä¸€ä¸ªé¡¹ç›®ï¼Œæˆ‘éƒ½å¿˜äº†mvcæ˜¯ä»€ä¹ˆäº†ã€‚å¾ˆä¹…æ²¡ç¢°äº†ã€‚ åœ¨å…¬å¸åšä»€ä¹ˆï¼šå®¢æˆ·ç«¯æ¡†æž¶æ’ä»¶çš„è®¾è®¡ã€‚ï¼ˆå…¶å®žæ²¡ä»€ä¹ˆå¾ˆå¤§çš„è¿›æ­¥ è®²è®²æ•°å­¦å»ºæ¨¡ç«žèµ›çš„é¡¹ç›®ï¼šå¤šç»´åº¦çš„æ•°æ®åˆ†æžï¼Œç”¨çš„pcaé™ç»´ï¼Œç„¶åŽé¢„æµ‹ã€‚ï¼ˆå•°å—¦ï¼Œè¢«æ‰“æ–­ ç”¨è¿‡javaå—ï¼šæ²¡æœ‰ï¼Œä½†æ˜¯å¯ä»¥å­¦ã€‚â€œæˆ‘ä»¬è¿™ä¸ªåº”ç”¨javaç¼ºäººã€‚ã€‚â€â€œâ€¦â€ æé—®æˆ‘æœ‰ä»€ä¹ˆéœ€è¦æå‡çš„åœ°æ–¹ï¼Ÿ è¯­è¨€ç»„ç»‡æ–¹ä¾¿æ¬ ç¼ºï¼Œæœ€å¥½è¦ç®€çŸ­ç²¾ç¡®åœ°å›žç­”é—®é¢˜ã€‚ï¼ˆæˆ‘æ‰¿è®¤å¹³å¸¸è·Ÿäººç±»äº¤æµæ²Ÿé€šå°‘äº†ï¼Œå¦å¤–çŸ¥è¯†ä½“ç³»ç½‘ç»œä¸å¤Ÿæ‰Žå®žï¼Œè„‘æµ·ä¸­åœ°é€»è¾‘ç»“æž„ä¸æ˜¯å¾ˆæ¸…æ™°ã€‚éœ€è¦æ¯å¤©è‡ªçœï¼Œåšè¿‡çš„é¢˜ç›®è¦å¥½å¥½åœ°reviewï¼ŒæŽŒæ¡ç‰¢å›ºã€‚æ·±å…¥æ¶ˆåŒ–ç†è§£ã€‚ å¦‚æžœæ˜¯åŽå°å¼€å‘ï¼Œå¯¹è®¡ç½‘éœ€è¦äº†è§£ï¼Œtcp/ipè¿™æ–¹é¢è¦çœ‹ä¸€çœ‹ã€‚ï¼ˆæˆ‘åº”è¯¥åŽ»è¡¥è¡¥è¿™ç§åŸºç¡€è¯¾ï¼Œè™½ç„¶ä¸æ˜¯ç§‘ç­å‡ºèº«ï¼Œä½†æ˜¯å¿—æ„¿çš„è¡Œä¸šæ— è®ºæ˜¯æœåŠ¡å™¨è¿˜æ˜¯æ¸¸æˆéƒ½éœ€è¦æ‰Žå®žçš„åŸºæœ¬åŠŸã€‚ ä»€ä¹ˆæ—¶å€™ä¼šæ”¶åˆ°æ¶ˆæ¯ï¼Ÿ å¦‚æžœæœ‰å…¶å®ƒéƒ¨é—¨æžä½ çš„è¯ï¼Œä¼šç»™ä½ å‘é‚®ä»¶çš„ã€‚ æ€»ç»“è¿™å¯èƒ½æ˜¯æˆ‘ç¦»é¹…çˆ¸çˆ¸æœ€è¿‘çš„ä¸€æ¬¡å§ã€‚æˆ‘å¯¹è‡ªå·±çš„åæ€ï¼š ä¸å¤Ÿè‡ªä¿¡ï¼šå¯¼è‡´å¯¹è¯çš„æ—¶å€™å±…ç„¶æœ‰ç‚¹é¢¤æŠ–ï¼Œä¸è‡ªä¿¡çš„åŽŸå› è¿˜æ˜¯å› ä¸ºè‡ªå·±æ²¡æœ‰å‡†å¤‡å®Œå¤‡ï¼Œè¿™æ ·ç»™é¢è¯•å®˜çš„å°è±¡ä¸ä¼šå¤ªå¥½ï¼Œå¯èƒ½ä¼šè§‰å¾—æˆ‘è¿™ä¸ªäººä¸é è°±ï¼Œä¸å¹²ç»ƒã€‚ çŸ¥è¯†ç½‘ç»œæ²¡æœ‰æž„å»ºå¥½ï¼šè¿˜æœ‰å¾ˆå¤šåŸºç¡€æ€§çš„çŸ¥è¯†æˆ‘éƒ½æ²¡æœ‰ç­”ä¸Šæ¥ã€‚å°¤å…¶æ˜¯è®¡ç½‘ï¼Œæ“ä½œç³»ç»Ÿï¼ŒLinuxã€‚éœ€è¦æ¶è¡¥ã€‚è¿˜å¥½c++çš„é—®é¢˜éƒ½æ¯”è¾ƒç†Ÿã€‚æ•°æ®ç»“æž„çš„å›žç­”ä¸æ˜¯å¾ˆå¥½ï¼Œå¯èƒ½åˆ·é¢˜æœ‰ç‚¹ç›²ç›®ï¼Œéœ€è¦å¯¹åˆ·è¿‡çš„é¢˜ç›®æœ‰å¾ˆæ·±çš„ç†è§£ï¼Œç»å¸¸å¤ç›˜ã€‚ æ€åº¦é—®é¢˜ï¼šæˆ‘å¯èƒ½å¼€å§‹å°±è§‰å¾—æ²¡æœ‰å¸Œæœ›ï¼Œæ‰€ä»¥å‡†å¤‡çš„ä¹Ÿä¸æ˜¯å¾ˆå®Œå¤‡ã€‚ä½†æ˜¯è¿™ä¸€æ¬¡é¢è¯•ä¹‹åŽï¼Œæˆ‘çš„ä¿¡å¿µæ›´åšå®šäº†ï¼Œå·²ç»è¿ˆå‡ºäº†ç¬¬ä¸€æ­¥ï¼Œå¼€å§‹è®¤è®¤çœŸçœŸåœ°å¤ç›˜ã€‚è¿™æ¬¡çš„é¢è¯•ç»™æˆ‘äº†ä¸€äº›å¸Œæœ›ï¼Œæˆ‘è§‰å¾—åªè¦åŠªåŠ›ï¼Œæœ‰å‡†å¤‡ï¼Œè¿˜æ˜¯æœ‰æœºä¼šçš„ã€‚ å†™åœ¨åŽé¢â€‹ è¿™å‡ å¤©æœ‰ç‚¹æ²‰è¿·çŽ©åšå®¢çš„æž„å»ºäº†ï¼ŒæŠŠæ˜¥æ‹›è¿™äº‹çœ‹å¾—å¾ˆä½›ç³»ï¼Œæœ¬æ¥åŸºç¡€å¹¶ä¸æ˜¯å¾ˆå¥½çš„æˆ‘è²Œä¼¼ä¹Ÿæ²¡æœ‰æŠŠæ˜¥æ‹›çœ‹å¾—å¾ˆé‡è¦ï¼Œä¸»è¦æŠŠå®åŽ‹åœ¨ç§‹æ‹›äº†ã€‚çŽ°åœ¨çœ‹çœ‹è¿˜æ˜¯åº”è¯¥ç»™è‡ªå·±æ›´å¤šçš„åŽ‹åŠ›ï¼Œå¯¹è‡ªå·±è¦æ±‚é«˜ä¸€ç‚¹ã€‚å¦å¤–æ˜¨å¤©çœ‹äº†çŒªåŽ‚çš„æ¸¸æˆå¼•æ“Žæ²™é¾™åˆ†äº«ï¼Œæˆ‘å¯¹è¿›å…¥æ¸¸æˆè¡Œä¸šå·²ç»è¿«ä¸åŠå¾…+è ¢è ¢æ¬²åŠ¨äº†ã€‚]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Heap</tag>
        <tag>Linux</tag>
        <tag>Operating System</tag>
        <tag>process</tag>
        <tag>TCP/IP</tag>
        <tag>quicksort</tag>
        <tag>Btree</tag>
        <tag>linkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é¢ç»æ”¶å½•]]></title>
    <url>%2F2019%2F03%2F22%2F%E9%9D%A2%E7%BB%8F%E6%94%B6%E5%BD%95%2F</url>
    <content type="text"><![CDATA[ã€ŠC/C++ç¨‹åºå‘˜é¢è¯•å®å…¸ã€‹ æ¢é•‡å®‡ æ¸…åŽå¤§å­¦å‡ºç‰ˆç¤¾ C/C++ C++åŸºç¡€æ•°æ®ç±»åž‹ï¼šæ•´æ•°åž‹ã€æµ®ç‚¹åž‹ã€voidåž‹ã€‚ æ“ä½œç¬¦ä¼˜å…ˆçº§ï¼šä»Žå³è‡³å·¦ç»“åˆçš„æœ‰ä¸‰ä¸ªï¼šå•ç›®è¿ç®—ç¬¦ã€æ¡ä»¶è¿ç®—ç¬¦ã€èµ‹å€¼è¿ç®—ç¬¦ã€‚ å·¦å€¼å’Œå³å€¼ï¼šå·¦å€¼æ˜¯ä¸€ä¸ªåœ°å€ï¼Œå³å€¼æ˜¯ä¸€ä¸ªåœ°å€å­˜æ”¾çš„å†…å®¹ã€‚å³å€¼ä¸èƒ½æ”¾åœ¨èµ‹å€¼è¯­å¥çš„å·¦è¾¹ã€‚å˜é‡æ˜¯å·¦å€¼ï¼Œå¯ä»¥å‡ºçŽ°åœ¨èµ‹å€¼è¯­å¥çš„å·¦è¾¹ã€‚æ•°å­—å­—é¢å€¼æ˜¯å³å€¼ï¼Œä¸èƒ½è¢«èµ‹å€¼ã€‚ å˜é‡åˆå§‹åŒ–ï¼šå¤åˆ¶åˆå§‹åŒ–ã€ç›´æŽ¥åˆå§‹åŒ–ã€‚å¦‚æžœå˜é‡åœ¨å®šä¹‰çš„æ—¶å€™æ²¡æœ‰è¢«åˆå§‹åŒ–ï¼Œä»–çš„å€¼æ˜¯ä¸ç¡®å®šçš„ã€‚ç›´æŽ¥åˆå§‹åŒ–çš„æ‰§è¡Œæ•ˆçŽ‡æ›´é«˜ï¼Œå¤åˆ¶åˆå§‹åŒ–è¦æ“¦é™¤å¯¹è±¡çš„å½“å‰å€¼å¹¶ç”¨æ–°å€¼ä»£æ›¿ã€‚ç³»ç»Ÿæœ‰æ—¶å€™ä¼šé»˜è®¤åˆå§‹åŒ–å˜é‡ã€‚å†…ç½®ç±»åž‹å˜é‡æ˜¯å¦è‡ªåŠ¨åˆå§‹åŒ–å–å†³äºŽå˜é‡å®šä¹‰çš„ä½ç½®ã€‚å‡½æ•°ä½“å¤–å®šä¹‰çš„å˜é‡éƒ½åˆå§‹åŒ–ä¸º0ï¼Œå‡½æ•°ä½“å†…çš„å†…ç½®ç±»åž‹å˜é‡ä¸è‡ªåŠ¨åˆå§‹åŒ–ï¼Œé™¤äº†ä½œä¸ºèµ‹å€¼æ“ä½œç¬¦çš„å·¦æ“ä½œæ•°ï¼Œå¦åˆ™æœªåˆå§‹åŒ–çš„å˜é‡æ²¡æœ‰æ„ä¹‰ã€‚ç±»è‡ªèº«å®šä¹‰äº†æ€Žä¹ˆåˆå§‹åŒ–ï¼Œæž„é€ å‡½æ•°ï¼Œå¦‚æžœç±»ä¸­æ²¡æœ‰å®šä¹‰æŸä¸ªç±»ä¸­å˜é‡çš„åˆå§‹åŒ–ï¼Œä½¿ç”¨é»˜è®¤æž„é€ å‡½æ•°ã€‚ å£°æ˜Žå’Œå®šä¹‰ï¼šextern:å£°æ˜Žå˜é‡åä½†ä¸å®šä¹‰å®ƒã€‚ä¸ä¼šåˆ†é…å­˜å‚¨ç©ºé—´ï¼Œå®ƒè¯´æ˜Žå˜é‡å®šä¹‰åœ¨ç¨‹åºçš„å…¶å®ƒåœ°æ–¹ï¼Œå«æœ‰åˆå§‹åŒ–çš„externå£°æ˜Žè¢«å½“ä½œæ˜¯å®šä¹‰ï¼Œå˜é‡å¯ä»¥å£°æ˜Žå¤šæ¬¡ï¼Œåªèƒ½å®šä¹‰ä¸€æ¬¡ã€‚ 1extern int a; æ“ä½œç³»ç»Ÿ osï¼šç®¡ç†è®¡ç®—æœºçš„ç¡¬ä»¶èµ„æºï¼Œè½¯ä»¶èµ„æºï¼Œæ•°æ®èµ„æºï¼ŒæŽ§åˆ¶ç¨‹åºè¿è¡Œï¼Œæä¾›æ“ä½œæŽ¥å£ï¼Œä¸ºå…¶å®ƒåº”ç”¨è½¯ä»¶æä¾›æ”¯æŒç­‰çš„è½¯ä»¶ç³»ç»Ÿã€‚ æ ¹æ®ä»»åŠ¡çš„å¤„ç†æ–¹å¼ ç®€å•æ‰¹å¤„ç†ç³»ç»Ÿ å¤šé“ç¨‹åºæ‰¹å¤„ç†ç³»ç»Ÿï¼šåˆ©ç”¨äº†å¤„ç†æœºçš„ç©ºé—²æ—¶é—´ã€‚ å¤šé“ç¨‹åºåˆ†æ—¶ç³»ç»Ÿï¼šçŽ°ä»£æ“ä½œç³»ç»Ÿã€‚ä¸€ä¸ªä½œä¸šåªåœ¨ä¸€ä¸ªæ—¶é—´ç‰‡çš„æ—¶é—´å†…ä½¿ç”¨cpuï¼Œæ—¶é—´åˆ°å°±å‰¥å¤ºä½œä¸šçš„cpuä½¿ç”¨æƒï¼Œæ ¹æ®ç®—æ³•å°†cpuåˆ†ç»™å…¶å®ƒä½œä¸šä½¿ç”¨ã€‚Unix,Linuxï¼ŒDOS,Windows,Macç­‰ã€‚ ç½‘ç»œæ“ä½œç³»ç»Ÿï¼šä¸€å°è®¡ç®—æœºé€šè¿‡ä¸€ä¸ªç½‘ç»œæŽ¥å£æŽ§åˆ¶å™¨è¿žæŽ¥ç½‘ç»œï¼Œè¿›è¡Œç½‘ç»œé€šä¿¡åŠŸèƒ½ï¼Œç½‘ç»œèµ„æºçš„ç®¡ç†å’Œä½¿ç”¨çš„æ“ä½œç³»ç»Ÿã€‚ æ“ä½œç³»ç»Ÿçš„æœ€å°è°ƒåº¦å•ä½ï¼šçº¿ç¨‹ã€‚è¿›ç¨‹æ˜¯æ“ä½œç³»ç»Ÿä¸­æ­£åœ¨è¿è¡Œçš„ä¸€ä¸ªåº”ç”¨ç¨‹åºï¼Œçº¿ç¨‹æ˜¯ç³»ç»Ÿåˆ†é…å¤„ç†å™¨æ—¶é—´èµ„æºçš„åŸºæœ¬å•å…ƒã€‚ä¸€ä¸ªè¿›ç¨‹è‡³å°‘åŒ…æ‹¬ä¸€ä¸ªçº¿ç¨‹ï¼Œé€šå¸¸ç§°ä½œä¸»çº¿ç¨‹ã€‚ èµ„æºçš„æœ€å°å•ä½æ˜¯è¿›ç¨‹ã€‚è¿›ç¨‹ç”±è¿›ç¨‹æŽ§åˆ¶å—ã€ç¨‹åºæ®µã€æ•°æ®æ®µä¸‰éƒ¨åˆ†ç»„æˆã€‚ä½¿ç”¨çº¿ç¨‹å¯ä»¥å®žçŽ°åº”ç”¨ç¨‹åºåŒæ—¶åšå‡ ä»¶äº‹äº’ä¸å¹²æ‰°ã€‚çº¿ç¨‹è‡ªå·±ä¸æ‹¥æœ‰ç³»ç»Ÿèµ„æºï¼Œåªæ‹¥æœ‰ä¸€ç‚¹åœ¨è¿è¡Œä¸­å¿…ä¸å¯å°‘çš„èµ„æºã€‚çº¿ç¨‹ä¸ŽåŒå±žä¸€ä¸ªè¿›ç¨‹çš„å…¶å®ƒçº¿ç¨‹å…±äº«è¿›ç¨‹æ‰€æœ‰çš„å…¨éƒ¨èµ„æºï¼Œä¸€ä¸ªçº¿ç¨‹å¯ä»¥åˆ›å»ºå’Œæ’¤é”€å¦ä¸€ä¸ªçº¿ç¨‹ï¼ŒåŒä¸€è¿›ç¨‹ä¸­çš„å¤šä¸ªçº¿ç¨‹ä¹‹é—´å¯ä»¥å¹¶å‘æ‰§è¡Œã€‚å­è¿›ç¨‹å’Œçˆ¶è¿›ç¨‹æœ‰ä¸åŒä»£ç å’Œæ•°æ®ç©ºé—´ï¼Œå¤šä¸ªçº¿ç¨‹å…±äº«è¿›ç¨‹çš„æ•°æ®ç©ºé—´ï¼Œæ¯ä¸ªçº¿ç¨‹ç”±è‡ªå·±çš„æ‰§è¡Œå †æ ˆå’Œç¨‹åºè®¡æ•°å™¨ä¸ºå…¶æ‰§è¡Œä¸Šä¸‹æ–‡ã€‚å¤šçº¿ç¨‹ä¸»è¦ä¸ºäº†åˆ©ç”¨CPUæ—¶é—´ï¼ŒåŒæ—¶åœ¨ä¸€ä¸ªè¿›ç¨‹å†…è¿è¡Œå¤šä¸ªä»»åŠ¡ã€‚ è¿›ç¨‹å’Œçº¿ç¨‹çš„åŒºåˆ«ï¼š ä¸€ä¸ªç¨‹åºè‡³å°‘ç”±ä¸€ä¸ªè¿›ç¨‹ï¼Œä¸€ä¸ªè¿›ç¨‹è‡³å°‘æœ‰ä¸€ä¸ªçº¿ç¨‹ã€‚ è¿›ç¨‹åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­æ‹¥æœ‰ç‹¬ç«‹çš„å†…å­˜å•å…ƒï¼Œå¤šä¸ªçº¿ç¨‹å…±äº«è¿›ç¨‹æ‰€æ‹¥æœ‰çš„å†…å­˜ã€‚ è¿›ç¨‹å¯ä»¥ç‹¬ç«‹è¿è¡Œï¼Œçº¿ç¨‹ä¸èƒ½ç‹¬ç«‹æ‰§è¡Œï¼Œå¿…é¡»ä¾å­˜åœ¨è¿›ç¨‹ä¸­ï¼Œä½¿ç”¨è¯¥è¿›ç¨‹çš„åº”ç”¨ç¨‹åºæä¾›å¤šä¸ªçº¿ç¨‹æ‰§è¡ŒæŽ§åˆ¶ã€‚ ä»»ä½•å®žçŽ°å¤šçº¿ç¨‹åŒæ­¥ï¼šå¤šçº¿ç¨‹æ˜¯ä¸ºäº†ä½¿å¾—çº¿ç¨‹å¹¶è¡Œåœ°å·¥ä½œä»¥å®Œæˆå¤šé¡¹ä»»åŠ¡ï¼Œä»¥æé«˜ç³»ç»Ÿçš„æ•ˆçŽ‡ã€‚ å¥½å¤„ï¼š æŠŠå æ®é•¿æ—¶é—´çš„ç¨‹åºä¸­çš„ä»»åŠ¡ä½œä¸ºä¸€ä¸ªå•ç‹¬çš„çº¿ç¨‹æ”¾åˆ°åŽå°å¤„ç†ã€‚ç”¨æˆ·ç•Œé¢å¯ä»¥ç»§ç»­å“åº”ç”¨æˆ·çš„æ“ä½œã€‚ åŠ å¿«ç¨‹åºçš„å¤„ç†é€Ÿåº¦ã€‚ åœ¨ä¸€äº›ç­‰å¾…çš„ä»»åŠ¡å®žçŽ°ä¸Šï¼Œå¦‚ç”¨æˆ·è¾“å…¥ã€æ–‡ä»¶è¯»å†™ã€ç½‘ç»œæ”¶å‘æ•°æ®ç­‰ï¼Œå¯ä»¥é‡Šæ”¾ä¸€äº›èµ„æºå¦‚å†…å­˜å ç”¨ç­‰ã€‚ å¤šçº¿ç¨‹åŒæ­¥ï¼šæ€æƒ³æ˜¯é¿å…å¤šä¸ªçº¿ç¨‹å¯¹åŒä¸€èµ„æºçš„è®¿é—®ï¼Œè¿™ä¸ªèµ„æºå¯ä»¥æ˜¯ä¸€ä¸ªå¯¹è±¡ã€æˆ–è€…æ˜¯ä¸€ä¸ªæ–¹æ³•ã€æˆ–è€…æ˜¯ä¸€æ®µä»£ç ã€‚ å®žçŽ°æ–¹æ³•ï¼š ä¸´ç•ŒåŒº äº’æ–¥é‡ ä¿¡å·é‡ C/C++é¢è¯•é¢˜å®žæˆ˜ è¿›ç¨‹ä¹‹é—´é€šä¿¡çš„é€”å¾„ï¼š å…±äº«å­˜å‚¨ç³»ç»Ÿ æ¶ˆæ¯ä¼ é€’ç³»ç»Ÿ ç®¡é“ï¼šä»¥æ–‡ä»¶ç³»ç»Ÿä¸ºåŸºç¡€ è¿›ç¨‹æ­»é”çš„åŽŸå› ï¼šæ­»é”æ˜¯ä¸¤ä¸ªæˆ–å¤šä¸ªå¹¶å‘è¿›ç¨‹ä¸­ï¼Œå¦‚æžœæ¯ä¸ªè¿›ç¨‹æŒæœ‰æŸç§èµ„æºè€Œåˆç­‰å¾…åˆ«çš„è¿›ç¨‹é‡Šæ”¾ä»–ä»¬ä¿æŒçš„èµ„æºï¼Œå¦åˆ™ä¸èƒ½å‘å‰æŽ¨è¿›ã€‚ æ ¹æœ¬åŽŸå› æ˜¯ï¼šç³»ç»Ÿèƒ½å¤Ÿæä¾›çš„èµ„æºä¸ªæ•°æ¯”è¦æ±‚è¯¥èµ„æºçš„è¿›ç¨‹æ•°å°‘ï¼Œå…·ä½“å¦‚ä¸‹ï¼š ç³»ç»Ÿèµ„æºä¸è¶³ è¿›ç¨‹æŽ¨è¿›é¡ºåºéžæ³• æ­»é”çš„4ä¸ªå¿…è¦æ¡ä»¶ï¼š äº’æ–¥æ¡ä»¶ï¼šä¸€ä¸ªèµ„æºæ¯æ¬¡åªèƒ½è¢«ä¸€ä¸ªè¿›ç¨‹ä½¿ç”¨ã€‚ è¯·æ±‚å’Œä¿æŒæ¡ä»¶:ä¸€ä¸ªè¿›ç¨‹å› è¯·æ±‚èµ„æºè€Œé˜»å¡žæ—¶ï¼Œå¯¹ä»¥èŽ·å¾—çš„èµ„æºä¿æŒä¸æ”¾ã€‚ ä¸å‰¥å¤ºæ¡ä»¶ï¼šè¿›ç¨‹å·²èŽ·å¾—çš„èµ„æºï¼Œåœ¨æ²¡ä½¿ç”¨å®Œä¹‹å‰ï¼Œä¸èƒ½å¼ºè¡Œå‰¥å¤ºã€‚ å¾ªçŽ¯ç­‰å¾…æ¡ä»¶ï¼šè‹¥å¹²è¿›ç¨‹ä¹‹é—´å½¢æˆä¸€ç§å¤´å°¾ç›¸æŽ¥çš„å¾ªçŽ¯ç­‰å¾…èµ„æºå…³ç³»ã€‚ æ­»é”çš„å¤„ç†ï¼š é¸µé¸Ÿç®—æ³•å¿½ç•¥è¯¥é—®é¢˜ã€‚ æ£€æµ‹æ­»é”å¹¶æ¢å¤ã€‚ ä»”ç»†åœ°å¯¹èµ„æºè¿›è¡ŒåŠ¨æ€åˆ†é…ï¼Œä»¥é¿å…æ­»é”ã€‚ ç ´çŽ¯æ­»é”äº§ç”Ÿçš„4ä¸ªå¿…è¦æ¡ä»¶ä¹‹ä¸€ï¼Œé˜²æ­¢æ­»é”äº§ç”Ÿã€‚ æ“ä½œç³»ç»Ÿä¸­è¿›ç¨‹è°ƒåº¦ç­–ç•¥ï¼š windowså’Œlinuxçš„åŒºåˆ« FCFSå…ˆæ¥å…ˆæœåŠ¡ ä¼˜å…ˆçº§ æ—¶é—´ç‰‡è½®è½¬ å¤šçº§åé¦ˆ ç±»çš„é™æ€æˆå‘˜å’Œéžé™æ€æˆå‘˜çš„åŒºåˆ« ç±»çš„staticæˆå‘˜åœ¨ç±»è¢«å®žä¾‹åŒ–å‰åˆ›å»ºï¼Œç±»çš„é™æ€æˆå‘˜æ¯ä¸ªç±»ä¸­åªæœ‰ä¸€ä¸ªï¼Œé™æ€å‡½æ•°çš„å®žçŽ°é‡Œä¸èƒ½ä½¿ç”¨éžé™æ€æˆå‘˜ã€‚ çº¯è™šå‡½æ•°æ€Žä¹ˆå®šä¹‰ï¼šæ­¤å‡½æ•°æ˜¯ä¸€ä¸ªæŽ¥å£ï¼Œå­ç±»å®šä¹‰æ—¶å¿…é¡»å®žçŽ°è¯¥æŽ¥å£ã€‚ 1virtual void f()=0; æ•°ç»„å’Œé“¾è¡¨åŒºåˆ«ï¼šæ•°ç»„å¤§å°å›ºå®šï¼Œé¡ºåºå­˜å‚¨ã€‚é“¾è¡¨å¤§å°å¯å˜ï¼Œéšæœºå­˜å‚¨ã€‚ ISOä¸ƒå±‚æ¨¡åž‹ï¼šç‰©ç†å±‚ã€ç‰©ç†é“¾è·¯å±‚ã€ç½‘ç»œå±‚ã€è¿è¾“å±‚ã€ä¼šè¯å±‚ã€è¡¨ç¤ºå±‚ã€åº”ç”¨å±‚ã€‚ to be continuedâ€¦]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ è¯­è¨€ç¯‡ constexpr]]></title>
    <url>%2F2019%2F03%2F22%2FC-%E8%AF%AD%E8%A8%80%E7%AF%87-constexpr%2F</url>
    <content type="text"><![CDATA[æŒ‡å®šå˜é‡æˆ–å‡½æ•°çš„å€¼èƒ½å‡ºçŽ°åœ¨å¸¸é‡è¡¨è¾¾å¼ä¸­[c++11] ç»†èŠ‚ C++11 constexpr å‡½æ•°ä½¿ç”¨é€’å½’è€Œéžè¿­ä»£ constexpr å‡½æ•°å¿…é¡»ç”¨æ¡ä»¶è¿ç®—ç¬¦?:æ¥æŠ›å¼‚å¸¸ï¼Œæç¤ºé”™è¯¯ constexprå£°æ˜Žçš„å‡½æ•°ï¼Œå¿…é¡»æŠŠä¸€åˆ‡æ”¾åœ¨å•æ¡ return è¯­å¥ä¸­ã€‚ ä½¿ç”¨volatileçš„æ—¶å€™ï¼Œä¸å…è®¸ä¼˜åŒ–ï¼Œåªèƒ½åœ¨è¿è¡Œæ—¶è®¡ç®—ã€‚ ExampleDefinition of a C++11 constexpr function which computes factorials and a literal type that extends string literals: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;stdexcept&gt; // C++11 constexpr functions use recursion rather than iterationï¼ˆC++11 constexpr å‡½æ•°ä½¿ç”¨é€’å½’è€Œéžè¿­ä»£ï¼‰// (C++14 constexpr functions may use local variables and loops)ï¼ˆC++14 constexpr å‡½æ•°å¯ä½¿ç”¨å±€éƒ¨å˜é‡å’Œå¾ªçŽ¯ï¼‰constexpr int factorial(int n)&#123; return n &lt;= 1 ? 1 : (n * factorial(n - 1));&#125; // literal classclass conststr &#123; const char* p; std::size_t sz;public: template&lt;std::size_t N&gt; constexpr conststr(const char(&amp;a)[N]): p(a), sz(N - 1) &#123;&#125; // constexpr functions signal errors by throwing exceptions // in C++11, they must do so from the conditional operator ?: // constexpr å‡½æ•°é€šè¿‡æŠ›å¼‚å¸¸æ¥æç¤ºé”™è¯¯ // C++11 ä¸­ï¼Œå®ƒä»¬å¿…é¡»ç”¨æ¡ä»¶è¿ç®—ç¬¦?:è¿™ä¹ˆåš constexpr char operator[](std::size_t n) const &#123; return n &lt; sz ? p[n] : throw std::out_of_range(""); &#125; constexpr std::size_t size() const &#123; return sz; &#125;&#125;; // C++11 constexpr functions had to put everything in a single return statement.constexprå£°æ˜Žçš„å‡½æ•°ï¼Œå¿…é¡»æŠŠä¸€åˆ‡æ”¾åœ¨å•æ¡ return è¯­å¥ä¸­ã€‚// (C++14 doesn't have that requirement)constexpr std::size_t countlower(conststr s, std::size_t n = 0, std::size_t c = 0)&#123; return n == s.size() ? c : 'a' &lt;= s[n] &amp;&amp; s[n] &lt;= 'z' ? countlower(s, n + 1, c + 1) : countlower(s, n + 1, c);&#125;//è¿™ä¸ªå‡½æ•°çš„åŠŸèƒ½æ˜¯è®¡ç®—å°å†™å­—æ¯çš„æ•°å­—ã€‚ // output function that requires a compile-time constant, for testingtemplate&lt;int n&gt;struct constN&#123; constN() &#123; std::cout &lt;&lt; n &lt;&lt; '\n'; &#125;&#125;; int main()&#123; std::cout &lt;&lt; "4! = " ; constN&lt;factorial(4)&gt; out1; // computed at compile time //åœ¨ç¼–è¯‘çš„æ—¶å€™å·²ç»è®¡ç®—å¥½äº†constN&lt;24&gt; out1; volatile int k = 8; // disallow optimization using volatile std::cout &lt;&lt; k &lt;&lt; "! = " &lt;&lt; factorial(k) &lt;&lt; '\n'; // computed at run time //ä½¿ç”¨volatileçš„æ—¶å€™ï¼Œä¸å…è®¸ä¼˜åŒ–ï¼Œåªèƒ½åœ¨è¿è¡Œæ—¶è®¡ç®—ã€‚ std::cout &lt;&lt; "the number of lowercase letters in \"Hello, world!\" is "; constN&lt;countlower("Hello, world!")&gt; out2; // implicitly converted to conststr //"Hello, world!"éšå¼è½¬æ¢åˆ°conststr&#125; Output: 1234! = 248! = 40320the number of lowercase letters in "Hello, world!" is 9 to be continuedâ€¦]]></content>
      <categories>
        <category>ã€ŠC++ Primerã€‹</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>constexpr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode179. Largest Number]]></title>
    <url>%2F2019%2F03%2F21%2FLeetCode179-Largest-Number%2F</url>
    <content type="text"><![CDATA[Given a list of non negative integers, arrange them such that they form the largest number. Example 1: 12Input: [10,2]Output: &quot;210&quot; Example 2: 12Input: [3,30,34,5,9]Output: &quot;9534330&quot; Note: The result may be very large, so you need to return a string instead of an integer. æ€è·¯std::sort + lambda 123456789101112131415class Solution &#123;public: string largestNumber(vector&lt;int&gt; &amp;num) &#123; vector&lt;string&gt; arr; for(auto i:num) arr.push_back(to_string(i)); sort(begin(arr), end(arr), [](string &amp;s1, string &amp;s2)&#123; return s1+s2&gt;s2+s1; &#125;); string res; for(auto s:arr) res+=s; while(res[0]=='0' &amp;&amp; res.length()&gt;1) res.erase(0,1); return res; &#125;&#125;; 1.å°†æ‰€æœ‰intè½¬ä¸ºstringï¼Œæ”¾å…¥å®¹å™¨ä¸­ï¼Œto_string(int)ã€‚ 2.ç”¨stlå°†å®¹å™¨ä¸­çš„stringæŒ‰ç…§è‡ªå®šä¹‰çš„æ–¹æ³•æŽ’åºã€‚è¿™æ˜¯ä¸€ä¸ªå¾ˆå·§çš„è§£æ³•ã€‚ 12std::sort(begin(arr),end(arr), [](string &amp;s1,string &amp;s2)&#123;return s1+s2&gt;s2+s1;&#125;) è¿™æ˜¯ä¸€ä¸ªlambdaè¡¨è¾¾å¼ã€‚å®ƒä½¿å¾—æŽ’åºåŽçš„ç»“æžœè®©å‰é¢éåŽ†è¿‡çš„stringè¿žæŽ¥èµ·æ¥æ°¸è¿œæ˜¯æœ€å¤§çš„ã€‚ ç”¨&gt;å¯ä»¥æ¯”è¾ƒstringçš„å¤§å°ã€‚ä¸¤ä¸ªå­—ç¬¦ä¸²è‡ªå·¦å‘å³é€ä¸ªå­—ç¬¦ç›¸æ¯”ï¼ˆæŒ‰ASCIIå€¼å¤§å°ç›¸æ¯”è¾ƒï¼‰ï¼Œç›´åˆ°å‡ºçŽ°ä¸åŒçš„å­—ç¬¦æˆ–é‡â€™\0â€™ä¸ºæ­¢ã€‚ å½“ä¸¤ä¸ªæ•°çš„ä½æ•°ä¸€æ ·ï¼Œåˆ™ç›´æŽ¥å¯ä»¥åº”ç”¨å­—ç¬¦ä¸²çš„æ¯”è¾ƒã€‚å¦‚ 1"1346" &gt; "1111" == true ä¾‹å­ï¼š 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string str1("235"); string str2("121"); bool result; result = str1 &gt; str2; cout&lt;&lt;result&lt;&lt;endl; // 1 str1 = "1111"; result = str1 &gt; str2; cout&lt;&lt;result&lt;&lt;endl; // 0 str1 = "111"; result = str1 &gt; str2; cout&lt;&lt;result&lt;&lt;endl; // 0 return 0;&#125; 3.å°†å®¹å™¨ä¸­æŽ’åºå¥½çš„stringåŠ èµ·æ¥ã€‚è¿™é‡Œæœ‰ä¸€ä¸ªç»†èŠ‚ï¼Œå¦‚æžœç¬¬ä¸€ä¸ªæ•°æ˜¯0æˆ–è€…stringçš„é•¿åº¦ä¸ä¸ºé›¶ï¼Œå°±å°†0åŽ»æŽ‰ã€‚ 12while(res[0]=='0' &amp;&amp; res.length()&gt;1) res.erase(0,1); å¤ä¹ ä¸€ä¸‹std::vector::erase iterator erase( iterator pos );(C++11 å‰) iterator erase( const_iterator pos );(C++11 èµ·) iterator erase( iterator first, iterator last );(C++11 å‰) iterator erase( const_iterator first, const_iterator last );(C++11 èµ·) 1) ç§»é™¤ä½äºŽ pos çš„å…ƒç´ ã€‚2) ç§»é™¤èŒƒå›´ [first; last) ä¸­çš„å…ƒç´ ã€‚ C++ code123456789101112131415161718192021222324class Solution &#123;public: string largestNumber(vector&lt;int&gt;&amp; nums) &#123; std::vector&lt;string&gt; a; for(auto const &amp; item:nums) &#123; a.push_back(to_string(item)); &#125; sort(a.begin(),a.end(),[](string &amp; a,string &amp;b)&#123;return a+b&gt;b+a;&#125;); string ret; for(auto const &amp; item:a) &#123; ret+=item; &#125; if(ret[0]=='0') return "0"; else return ret; &#125;&#125;; æ”¹è¿›ï¼šç»“æžœçš„ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸º0ï¼Œç›´æŽ¥è¿”å›žâ€0â€. 12if(ret[0]=='0') return "0"; ç»†èŠ‚ï¼šret[0]æ˜¯ä¸€ä¸ªchar,è€Œéžstringï¼Œæ‰€ä»¥ç”¨â€™â€™ï¼Œå¦åˆ™æŠ¥é”™ã€‚ æ€»ç»“1.æœ¬é¢˜è€ƒçš„æ˜¯å­—ç¬¦ä¸²æŽ’åºçš„å†…å®¹ï¼Œè¦ç”¨åˆ°sort+lambdaè¡¨è¾¾å¼ã€‚å…¶ä¸­lambdaè¡¨è¾¾å¼çš„å†™æ³•æ˜¯é‡ç‚¹ã€‚ 2.è¯­æ³•ï¼što_string(int)ã€‚å°†intè½¬stringæ”¾å…¥å®¹å™¨ã€‚ 3.string çš„å¤§å°æ¯”è¾ƒç”¨&gt;ï¼Œè¿”å›žboolå€¼ã€‚ 4.æœ€åŽæŠŠå®¹å™¨ä¸­çš„å€¼ç”¨+æ“ä½œç¬¦é‡è½½ï¼Œå°†å­—ç¬¦ä¸²é“¾æŽ¥èµ·æ¥ã€‚ 5.å¦‚æžœç¬¬ä¸€ä¸ªå­—ç¬¦æ˜¯â€˜0â€™,å°±è¿”å›žâ€0â€ æ‰©å±•å¦‚æžœè¦æ±‚æœ€å°çš„æ•°ï¼Œä¹Ÿç”¨lambdaå‡½æ•°ã€‚å¦å¤–ï¼Œç”¨ç±»æ¥æŒ‡å®šæ–¹æ³•æ¯”classè¦æ›´å¥½ã€‚ 12345678910111213141516171819202122232425class Solution &#123;public: string PrintMinNumber(vector&lt;int&gt; numbers) &#123; vector&lt;string&gt; a; for (auto const&amp; item : numbers) &#123; a.push_back(to_string(item)); &#125; sort(a.begin(), a.end(), MyCompare); string ret; for (auto const&amp; it : a) ret += it; if (ret[0] == '0') return "0"; return ret; &#125;private: static bool MyCompare(const string&amp;str1, const string &amp;str2) &#123; return str1 + str2 &lt; str2 + str1;//æœ€å°çš„æ•° &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Sort</tag>
        <tag>String</tag>
        <tag>Array</tag>
        <tag>Permutations</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode400. Nth Digit]]></title>
    <url>%2F2019%2F03%2F20%2FLeetCode400-Nth-Digit%2F</url>
    <content type="text"><![CDATA[Find the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, â€¦ Note:n is positive and will fit within the range of a 32-bit signed integer (n &lt; 231). Example 1: 12345Input:3Output:3 Example 2: 12345678Input:11Output:0Explanation:The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10. æ€è·¯ è®¡ç®—næ˜¯å‡ ä½æ•°-è®°ä¸ºdigit è¿™é‡Œæ¯”è¾ƒå¤æ‚ã€‚æ–¹æ³•æ˜¯ä»Žné‡Œé¢å‡åŽ»[1,9]9ä¸ª,[10,99]90*2ä¸ª,[100,999]900*3ä¸ªâ€¦â€¦è¿™äº›åŒºé—´æ‰€å æ•°å­—æ€»ä¸ªæ•°ï¼Œå¾—åˆ°çš„næ˜¯å‰©ä¸‹çš„åœ¨digitä½æ•°ä¸­ï¼Œæ‰€ç”¨æŽ‰çš„æ•°å­—æ€»æ•°ã€‚ è¿™äº›åŒºé—´çš„åŸºåº•æ˜¯9ï¼Œç„¶åŽæ¯æ¬¡baseéƒ½ä¹˜ä»¥10ï¼Œå†ä¹˜ä»¥digitä½æ•°ï¼Œå°±å¾—åˆ°å‰é¢èŒƒå›´çš„æ€»æ•°å­—æ•°ã€‚å¯ä»¥æŠŠbase*digitçœ‹ä½œæ˜¯åº•çº¿ï¼Œå¤šå‡ºæ¥çš„åœ¨digitè¿›ä½åŽè®¡ç®—ã€‚ æ³¨æ„è¿™é‡Œbaseè¦ç”¨long,å¦åˆ™ä¼šæº¢å‡ºã€‚ 123456while (n - base * digit &gt; 0) &#123; n -= base * digit; base *= 10; digit++; &#125; æ‰¾åˆ°næ‰€åœ¨çš„æ•°æ˜¯å¤šå°‘-è®°ä¸ºnum n=10ï¼Œnth=(1)/2=0,nth+base=10,ä»–æŒ‡çš„æ•°æ˜¯10,index=(1)%2=1 n=11ï¼Œnth=(2)/2=1,nth+base=11,ä»–å€¼çš„æ•°æ˜¯10,index=(2)%2=0 n=12ï¼Œnth=(3)/2=1,nth+base=11,ä»–æŒ‡çš„æ•°æ˜¯11,index=(3)%2=1 n=13ï¼Œnth=(4)/2=2,nth+base=12,ä»–æ‰€æŒ‡çš„æ•°æ˜¯11ï¼Œindex=(4)%2=0 ä»Žä¸¤ä½æ•°å¼€å§‹æ‰¾è§„å¾‹ï¼Œå‘çŽ°numçš„å€¼å’Œindexæœ‰å…³ï¼Œå¦‚æžœindex==0æ—¶ï¼Œnum=nth+base-1;å¦åˆ™num=nth+base; ç¡®å®šnåœ¨numä¸­çš„ä½ç½®ï¼Œè¿”å›žè¯¥ä½ç½®çš„å€¼ å·²çŸ¥äº†indexå’Œnumå°±å¯ä»¥æŠŠnumè½¬æ¢ä¸ºstringæ¥åšè¿™é“é¢˜. ä¸Šä¸€æ­¥ä¸­index==0ï¼Œæ˜¯ä¸Šä¸€ä¸ªæ•°çš„æœ€åŽä¸€ä½ï¼Œæ‰€ä»¥è®©index=digitä½ã€‚ int-&gt;string-&gt;char-&gt;intçš„æ­¥éª¤å¦‚ä¸‹123string a = to_string(int);a = char;//charå¯ä»¥å¼ºåˆ¶è½¬æ¢ä¸ºstringï¼ŒaçŽ°åœ¨è¿˜æ˜¯stringint b = stoi(a);//inline int stoi(const string&amp;) C++ code12345678910111213141516171819202122232425262728class Solution &#123;public: int findNthDigit(int n) &#123; //1.è®¡ç®—ä½æ•° int digit=1; long base=9; while(n-base*digit&gt;0) &#123; n-=base*digit; base*=10; digit++; &#125; //2.æ‰¾åˆ°num int nth=n/digit; int index=n%digit; int num=0; num=pow(10,digit-1)+((index==0)?nth-1:nth); //3.è½¬æ¢å­—ç¬¦ä¸² if(index==0) index=digit;//å¾ˆå®¹æ˜“å¿˜æŽ‰ string a=to_string(num); a=a[index-1]; return stoi(a); &#125;&#125;; æ€»ç»“ éš¾ç‚¹æ˜¯ç¬¬ä¸€æ­¥ï¼Œæ€Žä¹ˆæ±‚næ‰€åœ¨çš„æ•°å­—çš„ä½æ•°ï¼Œè§‚å¯Ÿ1ä½æ•°ï¼Œä¸¤ä½æ•°ï¼Œä¸‰ä½æ•°åŽï¼Œå‘çŽ°å‰é¢æ•°çš„æ€»å’Œæ˜¯base*digitï¼Œå¹¶ä¸”baseæ˜¯ä»¥åä¸ºå€æ•°ï¼Œ9ä¸ºåº•å€å¢žçš„ã€‚è®°ä¸‹æº¢å‡ºçš„nå°±æ˜¯åœ¨å½“å‰digitä½æ•°ä¸­æ•°å­—çš„æ€»é‡ã€‚ æ‰¾è§„å¾‹ï¼Œå‘çŽ°numè·Ÿnthè¿˜æœ‰indexæœ‰å…³ç³»ï¼Œå…±åŒç‚¹æ˜¯éƒ½è¦åŠ pow(10,digit-1),ä¸åŒç‚¹æ˜¯index==0çš„æ—¶å€™ï¼Œnthè¦å‡ä¸€ï¼Œå› ä¸ºé‚£æ˜¯ä¸Šä¸€ä¸ªæ•°ã€‚ æœ€åŽä¸€æ­¥æ˜¯å­—ç¬¦ä¸²è½¬åŒ–çš„é—®é¢˜ï¼Œå…³é”®è¯­æ³•to_string(int),(string)char,stoi(const string&amp;)ã€‚ ç»†èŠ‚ï¼šbaseè¦ç”¨longï¼Œé‡åˆ°è¿­ä»£çš„å€å¢žå˜é‡æœ€å¥½éƒ½ç”¨long.]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode233.Number of Digit One]]></title>
    <url>%2F2019%2F03%2F18%2FLeetCode233-Number-of-Digit-One%2F</url>
    <content type="text"><![CDATA[Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n. Example: Input: 13Output: 6Explanation: Digit 1 occurred in the following numbers: 1, 10, 11, 12, 13. æ³•ä¸€ - æŒ‰ä½å‚è€ƒleetcodeå®˜æ–¹è§£ç­”ã€‚ 1.ä¸ªä½æ•°ä¸Šçš„1ï¼š æ¯10ä¸ªæ•°å†…ï¼Œå‡ºçŽ°ä¸€æ¬¡1 å¦‚æžœä¸ªä½æ•°ä¸ä¸º0ï¼Œä¸€å®šä¼šå‡ºçŽ°ä¸€æ¬¡1. n/10 + min(0,max(1,(n%10-1+1))) 2.åä½ä¸Šçš„1ï¼š æ¯100æ¬¡ï¼Œåä½ä¸Šå‡ºçŽ°10æ¬¡1ã€‚ å½“åä½æ•°å¤§äºŽ1ï¼Œä¼šå‡ºçŽ°10æ¬¡1;å¦‚161x(x:[0,9]),+x+1æ¬¡;16y0(y:[2,9])=+10æ¬¡ã€‚æ‰€ä»¥åªå¯èƒ½åŠ 0~10æ¬¡ã€‚ è®¾ä¸ªä½æ•°ä¸ºxï¼Œx = n%100-10 ã€‚è€Œä¸”xæ˜¯å¤§äºŽç­‰äºŽ0çš„ï¼Œæ‰€ä»¥ç”¨max(0,x)ï¼Œç”±äºŽè¦åŠ x+1æ¬¡ï¼Œæ‰€ä»¥ç”¨ max(0,x+1) n/100 * 10 + min(10, max(0 , ï¼ˆn%100-10ï¼‰ +1)) 3.ç™¾ä½ä¸Šçš„1ï¼š æ¯1000æ¬¡ï¼Œç™¾ä½ä¸Šå‡ºçŽ°100æ¬¡1. å¦‚æžœç™¾ä½ä¸Šçš„æ•°å­—å¤§äºŽäº†2ï¼Œç™¾ä½ä¸Šå‡ºçŽ°äº†100æ¬¡1ï¼ˆä¸è¶…è¿‡100æ¬¡ï¼‰ å¦‚æžœç™¾ä½æ•°æ˜¯1æˆ–è€…0ï¼Œç™¾ä½ä¸Šä¼šå‡ºçŽ°ï¼ˆn%1000 -100)+1æ¬¡1.ï¼ˆä¸å°äºŽ0æ¬¡ï¼‰ n /1000 *100 + min(100, max(0,n%1000 -100 +1)) å¦‚n=1234 ä¸ªä½çš„1ï¼š1234/101+min(1,4)=123\1+1=124 åä½çš„1ï¼š1234/10010 + min(10,25)=12\10+10=130 ç™¾ä½çš„1ï¼š1234/1000100+min(100,ï¼ˆ234-100)+1)=1\100+100=200 åƒä½çš„1ï¼š1234/100001000+min(1000,(1234-1000)+1)=0\1000+235=235 æ€»è®¡ï¼š124+130+200+235=689 æ•°å­¦æ¨¡åž‹1n/(degree*10)*degree + min(degree,max(0,n\%(10*degree)-degree+1)) C++ code1234567891011class Solution &#123;public: int countDigitOne(int n) &#123; if(n&lt;=0) return 0; int ret=0; for(long long degree=1;degree&lt;=n;degree*=10) ret += n /(degree*10)*degree + min(degree, max((long long)0, n % (10 * degree) - degree+1)); return ret; &#125;&#125;; T:O(logn)S:O(1) æ€»ç»“1.è¿™ç§æ–¹æ³•æ˜¯è®¡ç®—ä¸ªåç™¾åƒä¸‡ä½ä¸Š1å‡ºçŽ°çš„æ¬¡æ•°ï¼Œæ‰¾åˆ°ä¸åŒä½ä¸Š1å‡ºçŽ°æ¬¡æ•°çš„è§„å¾‹ï¼Œè§£å¾—é€šç”¨å…¬å¼ï¼Œä¸€èˆ¬æ˜¯ä¸€ä¸ªåˆ†æ®µå‡½æ•°ã€‚å†å°†æ‰€æœ‰ä½ä¸Šçš„æ¬¡æ•°ç›¸åŠ ï¼Œå°±æ˜¯æœ€ç»ˆç»“æžœã€‚2.è¿™é“é¢˜å®¹æ˜“é”™çš„åœ°æ–¹æ˜¯n/(degree10)degreeä¸èƒ½å†™æˆn/10ï¼Œå› ä¸ºå¯èƒ½n/(degree*10)çš„ç»“æžœæ˜¯0ã€‚3.ç”¨è¿­ä»£é˜²æ­¢æ ˆæº¢å‡ºï¼Œè¿˜å¯ä»¥ä½¿O(1)ã€‚4.é˜²æ­¢æ ˆæº¢å‡ºï¼Œç”¨long longæ¥è¡¨ç¤ºå¤§æ•°ï¼›åŒæ—¶å¼€å§‹retè¦èµ‹åˆå€¼0ï¼Œå¦åˆ™æ˜¯ä¸€ä¸ªå¾ˆå¤§çš„æ•°ï¼›ç”¨ä¸­çš„max()æ—¶ï¼Œè¦ç”¨(long long)å¼ºåˆ¶è½¬æ¢ã€‚ æ³•äºŒ - åˆ’åˆ†å‚è€ƒLCé«˜ç¥¨å›žç­”ã€‚ å«1çš„æ•°å­— 1çš„ä¸ªæ•° æ•°å­—èŒƒå›´ 1 1 [1,9] 10 11 12 13 14 15 16 17 18 19 11 [10,19] 21 1 [20,29] 31 1 [30,39] 41 1 [40,49] 51 1 [50,59] 61 1 [60,69] 71 1 [70,79] 81 1 [80,89] 91 1 [90,99] æ€»è®¡ 11+1*9=20 [001,099] 100 101 102 103 104 105 106 107 108 109 11 [100,109] 110 111 112 113 114 115 116 117 118 119 21 [110,119] 120 121 122 123 124 125 126 127 128 129 11 [120,129] â€¦ â€¦ â€¦ æ€»è®¡ 21+11*9=120 [100,199] â€¦ 20 [200,299]=[0,99] â€¦ 20 [300,399]=[0,99] â€¦ â€¦ â€¦ â€¦ 20 [900,999]=[0,99] æ€»è®¡ 120+20*9=300 [001,999] å¯¹äºŽä»»æ„ä¸¤ä½æ•°ï¼Œåä½æ•°ä¸Šçš„æ•°å­—+1å°±ä»£è¡¨1å‡ºçŽ°çš„ä¸ªæ•° å½“åä½æ•°å¤§äºŽç­‰äºŽ2çš„æ—¶å€™(x+8)/10ï¼Œè¦å†åŠ ä¸Šå¤šå‡ºæ¥çš„10ä¸ª1. å¦‚ï¼šn=3141592,æŒ‰ä¸ªåç™¾åƒä¸‡ä½æ¥åˆ’åˆ† å½“m=100æ—¶ï¼Œa=31415,b=92;ç™¾ä½æ•°1çš„å‰ç¼€æ˜¯â€â€åˆ°â€3141â€.æ‰€ä»¥æ˜¯3142æ¬¡ã€‚ æ‰€ä»¥ç™¾ä½æ˜¯1çš„æ—¶å€™ï¼Œå‡ºçŽ°äº† (a/10+1)*100 æ¬¡ã€‚ å½“m=1000æ—¶ï¼Œa=3141,b=592ï¼›åƒä½æ•°1çš„å‰ç¼€æ˜¯â€â€åˆ°â€314â€ï¼Œä¸€å…±315æ¬¡ã€‚ å› ä¸ºæœ€åŽä¸€ä¸ªåƒä½æ•°æ˜¯1ï¼Œæ‰€ä»¥æœ€åŽä¸€æ¬¡æ²¡æœ‰æ»¡1000æ¬¡ï¼Œè€Œæ˜¯â€000â€åˆ°â€592â€ï¼Œä¸€å…±593æ¬¡ã€‚ æ‰€ä»¥åƒä½æ˜¯1çš„æ—¶å€™ï¼Œå‡ºçŽ°äº†(a/10*1000)+(b+1)æ¬¡ ä¸ºäº†åˆ¤æ–­æœ€åŽä¸€ä½æ˜¯å¦ä¸º1.ç”¨ï¼ˆa+8)/10æ¥èŽ·å–æ»¡è½½çš„æ¬¡æ•°ï¼Œç”¨a%10==1æ¥åˆ¤æ–­æ˜¯å¦éœ€è¦æ·»åŠ é¢å¤–çš„æ¬¡æ•°ã€‚ C++ code12345678910111213141516class Solution &#123;public:int countDigitOne(int n) &#123; if(n&lt;=0) return 0; int ret=0; for(long long degree=1;degree&lt;=n;degree*=10) &#123; long long a = n/degree; long long b = n%degree; ret+=(a+8)/10 *degree//æ»¡è½½ +(a%10==1)*(b+1);//açš„æœ€åŽä¸€ä½ä¸º1ï¼Œä¼šåŠ å‰©ä¸‹çš„ä½™æ•°+1 &#125; return ret;&#125;&#125;; æ€»ç»“1.è¿™ç§æ–¹æ³•çš„æ€æƒ³æ˜¯æŠŠå¤§èŒƒå›´çš„æ•°åˆ’åˆ†ä¸ºå°èŒƒå›´çš„æ•°æ¥è®¡ç®—ã€‚2.å‰ç¼€çš„æœ€åŽä¸€ä½å¦‚æžœå¤§äºŽç­‰äºŽ2å°±è¿›æ»¡è½½ï¼Œå³(a+8)/10*degreeã€‚å¦‚æžœé¢˜ç›®é—®çš„æ˜¯3å‡ºçŽ°çš„å¤§å°ï¼Œå°±å¤§äºŽç­‰äºŽ4è¿›æ»¡è½½(a+4)/10*degreeã€‚3.åˆ¤æ–­æœ€åŽä¸€ä½æ˜¯ä¸æ˜¯1(a%10==1)ï¼Œå¦‚æžœæ˜¯1å°±è¦åŠ (å‰©ä¸‹çš„ä½™æ•°+1),åŠ 1æ˜¯å°¾å·ä¸º000çš„æ—¶å€™ã€‚]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç”¨C++å†™çš„ä¸€ä¸ªåƒè±†äººçš„å°æ¸¸æˆ]]></title>
    <url>%2F2019%2F03%2F17%2Fpacman%2F</url>
    <content type="text"><![CDATA[åˆ·é¢˜å¤ªè‡ªé—­äº†ï¼Œä¸å¦‚åšä¸ªå°æ¸¸æˆå‡å‡åŽ‹å§ã€‚ä¸‹åˆæ‘¸é±¼çœ‹äº†ä¸ªè§†é¢‘ï¼Œç”¨c++åšäº†ä¸€ä¸ªå°æ¸¸æˆï¼Œåƒè±†äººã€‚ä¸»è¦æ”¶èŽ·æ˜¯å­¦äº†ä¸€ç‚¹ç‚¹OOP+æ•°å­¦+æ•°æ®ç»“æž„+æ“ä½œç³»ç»Ÿã€‚æ¸¸æˆæ€è·¯å¦‚ä¸‹ã€‚ æ¶ˆæ¯é˜Ÿåˆ—æ¯ä¸€ä¸ªçª—å£ç¨‹åºæœ‰ä¸€ä¸ªæ¶ˆæ¯é˜Ÿåˆ—,ç³»ç»ŸæŠŠæ¶ˆæ¯æ”¾åˆ°é˜Ÿåˆ—é‡Œé¢,è®¾ç½®ä¸€ä¸ªå¾ªçŽ¯æ¥ç¿»è¯‘é˜Ÿåˆ—ä¸­çš„æ¶ˆæ¯.ç„¶åŽåˆ†å‘è¿™ä¸ªæ¶ˆæ¯. 12345678910// ä¸»æ¶ˆæ¯å¾ªçŽ¯: //while (GetMessage(&amp;msg, nullptr, 0, 0))//å¦‚æžœæ²¡æœ‰æ¶ˆæ¯,å°±é˜»å¡žåœ¨è¿™é‡Œ,ä¸ä¼šè¿”å›ž. while (PeekMessage(&amp;msg, nullptr, 0, 0,PM_REMOVE))&#123; //ä¿®æ”¹åŽå³ä½¿æ²¡æœ‰æ¶ˆæ¯.ä¹Ÿä¸ä¼šé˜»å¡ž. if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg))&#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; &#125; GDIç”»ç‚¹12345678910HWND g_hWnd = nullptr;//å®šä¹‰ä¸€ä¸ªå…¨å±€å˜é‡int APIENTRY wWinMain(_In_ HINSTANCE hInstance,_In_opt_ HINSTANCE hPrevInstance,_In_ LPWSTR lpCmdLine,_In_ int nCmdShow)&#123;HDC hdc = ::GetDC(g_hWnd);//ä¼ å…¥å…¨å±€å˜é‡çš„å¥æŸ„int x = rand()%WLENGTH ; //[0,WLENGTH)int y = rand()%HLENGTH ; //[0,HLENGTH)SetPixel(hdc, x, y, RGB(rand()%255, rand() % 255, rand() % 255));::DeleteDC(hdc);//é‡Šæ”¾hdc &#125; ç”»çº¿12345678910111213HDC hdc = ::GetDC(g_hWnd);HPEN hPen = CreatePen(PS_SOLID, 3, RGB(rand()%255, rand() % 255, rand() % 255));//æ–°ç”»ç¬”HPEN hOldPen = (HPEN)SelectObject(hdc, hPen);//é€‰ä¸­ç”»ç¬”int x = rand() % WLENGTH;int y = rand() % HLENGTH;int xx = rand() % WLENGTH;int yy = rand() % HLENGTH;MoveToEx(hdc, x, y, nullptr);LineTo(hdc, xx, yy);SelectObject(hdc, hOldPen);//æ¢å¤è€ç”»ç¬”DeleteObject(hPen);//åˆ é™¤ç”»ç¬”ReleaseDC(g_hWnd, hdc);Sleep(1);//ä½¿å½“å‰çº¿ç¨‹æš‚åœ1s ç”»çŸ©å½¢123456789101112131415161718HDC hdc = ::GetDC(g_hWnd);//ç©ºå¿ƒçŸ©å½¢ã€‚ HPEN hPen = CreatePen(PS_SOLID, 2, RGB(255, 0, 0));HPEN holdPen = (HPEN)SelectObject(hdc, hPen);Rectangle(hdc, 100, 200, 300, 500);//å·¦ä¸Šè§’å’Œå³ä¸‹è§’åæ ‡ã€‚(100,200),(300,500)SelectObject(hdc, holdPen);DeleteObject(hPen);//å®žå¿ƒçŸ©å½¢HBRUSH hBrush = CreateSolidBrush(RGB(0, 0, 255));RECT rect;rect.left = 50;rect.right = 150;rect.top = 270;rect.bottom = 370;FillRect(hdc, &amp;rect, hBrush);DeleteObject(hBrush); ReleaseDC(g_hWnd, hdc); ç”»å¼§12345678910111213141516HDC hdc = ::GetDC(g_hWnd); HPEN hPen = CreatePen(PS_SOLID, 2, RGB(255, 0, 0));HPEN holdPen = (HPEN)SelectObject(hdc, hPen);//åœ†ã€‚å·¦ä¸Šå³ä¸‹ Ellipse(hdc, 200, 150, 300, 250);//æ¤­åœ†ã€‚å·¦ä¸Šå³ä¸‹Ellipse(hdc, 200, 170, 300, 250);//å¼§å½¢Arc(hdc,100, 100, 300, 250,//çŸ©å½¢200,150,//èµ·å§‹ç‚¹200,200//ç»ˆç‚¹);SelectObject(hdc, holdPen);DeleteObject(hPen); ReleaseDC(g_hWnd, hdc); ç”»çŽ©å®¶123456789101112//é—­å˜´void Draw0() &#123;int x = 300, y = 300;//ä¸­å¿ƒç‚¹int r = 100;//åœ†çš„åŠå¾„HDC hdc = ::GetDC(g_hWnd);//äººè„¸Ellipse(hdc, x - r, y - r, x + r, y + r);//å˜´å·´MoveToEx(hdc, x, y, nullptr);LineTo(hdc, x - r, y);ReleaseDC(g_hWnd,hdc);&#125; 123456789101112131415161718192021222324#define PI 3.1415926f//åŠå¼ å˜´void Draw1() &#123; int x = 300, y = 300;//ä¸­å¿ƒç‚¹ int r = 100;//åœ†çš„åŠå¾„ HDC hdc = ::GetDC(g_hWnd); //è„¸ int x0, y0; int x1, y1; x0 = x + (r*sin(PI*1.25f)); y0 = y - (r*cos(PI*1.25f)); x1 = x - (r*sin(PI*0.75f)); y1 = y + (r*cos(PI*0.75f)); Arc(hdc, x-r, y-r, x+r, y+r,//çŸ©å½¢ x0, y0,//èµ·å§‹ç‚¹ x1, y1);//ç»ˆç‚¹ //å˜´å·´ MoveToEx(hdc, x0, y0, nullptr); LineTo(hdc, x, y); MoveToEx(hdc, x1, y1, nullptr); LineTo(hdc, x, y); ReleaseDC(g_hWnd, hdc);&#125; 12345678910111213//å…¨å¼ å˜´ã€‚åŠåœ†+ç«–çº¿void Draw2() &#123; int x = 300, y = 300;//ä¸­å¿ƒç‚¹ int r = 100;//åœ†çš„åŠå¾„ HDC hdc = ::GetDC(g_hWnd); Arc(hdc, x - r, y - r, x + r, y + r, x, y + r, x, y - r); MoveToEx(hdc,x, y - r, nullptr); LineTo(hdc, x, y + r); ReleaseDC(g_hWnd, hdc);&#125; åŠ¨ç”»123456789101112131415161718192021222324252627282930313233//ç”»çŽ©å®¶//æŽ§åˆ¶æ—¶é—´static DWORD dwTime = GetTickCount();if (GetTickCount() - dwTime &gt;= 40) dwTime = GetTickCount();//æ›´æ–°æ—¶é—´ else continue;//è·³å‡º //æ¸…é™¤ä¸Šä¸€æ¬¡ç”»å¸ƒHDC hdc = GetDC(g_hWnd);RECT rc;GetClientRect(g_hWnd,&amp;rc);//rcèŽ·å¾—çª—å£å¤§å°HBRUSH hbr = CreateSolidBrush(RGB(255, 255, 255));FillRect(hdc, &amp;rc, hbr);//çª—å£åˆ·ç™½DeleteObject(hbr);ReleaseDC(g_hWnd, hdc);//0ï¼šé—­å˜´//1.åŠå¼ //2.å…¨å¼ //3.åŠå¼ //4.é—­å˜´static int iFrame = 0;//è®¾ç½®ä¸€ä¸ªé™æ€å˜é‡æ¥å¾ªçŽ¯æ’­æ”¾iFrame++;if (iFrame &gt;= 5) iFrame = 0;switch (iFrame)&#123; case 0: Draw0();break; case 1: Draw1();break; case 2: Draw2();break; case 3: Draw1();break; case 4: Draw0();break;&#125; åœ°å›¾ç±»æŠ½è±¡ç±»åœ°å›¾çš„è®¾è®¡12345678910111213141516171819202122232425262728//æŠ½è±¡ç±»åœ°å›¾ï¼Œä¸‰å…³ç±»çš„çˆ¶ç±»class GMap&#123; //ä¿æŠ¤ç±»:å­ç±»å¯ä»¥è®¿é—®åˆ°ï¼Œé€šç”¨å˜é‡protected: static int LD;//éšœç¢ç‰©å°ºå¯¸ static int PD;//è±†å­åŠå¾„ void InitOp();//åˆå§‹åŒ–çŽ©å®¶å’Œæ•Œäºº bool mapData[MAPLENTH][MAPLENTH];//åœ°å›¾æ•°æ® bool peaMapData[MAPLENTH][MAPLENTH];//è±†å­æ•°æ® COLORREF color;//åœ°å›¾é¢œè‰²public: void DrawMap(HDC &amp;hdc);//ç»˜åˆ¶åœ°å›¾ void DrawPeas(HDC &amp;hdc);//ç»˜åˆ¶è±†å­ GMap() &#123;&#125;; virtual ~GMap(); //ä¸ºäº†è®©çŽ©å®¶ç±»å’Œæ•Œäººç±»å¯ä»¥è®¿é—®åˆ°åœ°å›¾ç±»ï¼Œå£°æ˜Žå‹å…ƒ friend class GObject; friend class PacMan;&#125;;//ç»§æ‰¿class Stage_1 :public GMap &#123;private: bool static initData[MAPLENTH][MAPLENTH];//åˆå§‹åŒ–åœ°å›¾public: Stage_1();//æž„é€ å‡½æ•°&#125;; æŠ½è±¡ç±»åœ°å›¾çš„å®žçŽ°123456789101112131415161718192021222324252627282930313233343536373839int GMap::LD = 36;//å¢™å®½int GMap::PD = 3;//è±†å­çš„åŠå¾„void GMap::InitOp()//åˆå§‹åŒ–æ•Œäººå’ŒçŽ©å®¶çš„ä½ç½®æ²¡æœ‰è±†å­&#123; peaMapData[E_ROW][E_COLUMS] = false; peaMapData[P_ROW][P_COLUMS] = false;&#125;void GMap::DrawMap(HDC &amp;memDC)&#123;HBRUSH hBrush = CreateSolidBrush(color);for (int i = 0; i &lt; MAPLENTH; i++) &#123;for (int j = 0; j &lt; MAPLENTH; j++) &#123;//ç»˜åˆ¶å¢™å£,xå¯¹åº”åˆ—,yå¯¹åº”è¡Œif (!mapData[i][j]) &#123;RECT rect;rect.left = j * LD;rect.top = i * LD;rect.right = (j + 1) * LD;rect.bottom = (i + 1) * LD;FillRect(memDC, &amp;rect, hBrush);&#125;&#125;&#125;DeleteObject(hBrush);&#125;void GMap::DrawPeas(HDC &amp;hdc)&#123; for (int i = 0; i &lt; MAPLENTH; i++)&#123;for (int j = 0; j &lt; MAPLENTH; j++)&#123;if (mapData[i][j]) &#123;//ç”»è±†å­,æŠŠè±†å­æ”¾åœ¨ä¸€ä¸ªçŸ©å½¢é‡Œé¢Ellipse(hdc,(LD / 2 - PD) + j*LD,//left(LD / 2 - PD) + i*LD,//top(LD / 2 + PD) + j*LD,//right(LD / 2 + PD) + i*LD);&#125;&#125;&#125;&#125;//bottomGMap::~GMap()&#123;&#125;//åˆå§‹åŒ–åœ°å›¾#define A true#define B falsebool Stage_1::initData[MAPLENTH][MAPLENTH] = &#123;.....&#125;;#undef A#undef B//å–æ¶ˆå®å®šä¹‰ï¼Œé˜²æ­¢æ­§ä¹‰ å¯ç§»åŠ¨å¯¹è±¡ç±»çš„è®¾è®¡ åŸºç±»GObjectçš„éƒ¨åˆ†å˜é‡ 123456789101112131415public:static GMap *pStage; //æŒ‡å‘åœ°å›¾ç±»çš„æŒ‡é’ˆ,è®¾ç½®ä¸ºé™æ€,ä½¿æ‰€æœ‰è‡ªç±»å¯¹è±¡éƒ½èƒ½å¤Ÿä½¿ç”¨ç›¸åŒçš„åœ°å›¾void DrawBlank(HDC &amp;hdc);// ç”»ç©ºç™½protected://æƒ³è®©çŽ©å®¶ç±»å’Œæ•Œäººç±»è®¿é—®è¿™äº›æ•°æ®//ç¥¯æ•°int m_nFrame;//åˆ¤æ–­ç‰©ä½“æ˜¯å¦åˆ°è¾¾é€»è¾‘åæ ‡ä½ç½®bool Achive();//é€»è¾‘ç¢°æ’žæ£€æµ‹,å°†ç‰©ä½“æ‘†æ”¾åˆ°åˆç†çš„ä½ç½®bool Collision();//å°†å®žé™…åæ ‡è½¬æ¢ä¸ºé€»è¾‘åæ ‡int PtTransform(int k) //åˆ°è¾¾é€»è¾‘ç‚¹åŽæ›´æ–°æ•°æ®virtual void AchiveCtrl(); æ•Œå†›å¯¹è±¡ 123456789101112131415161718class Enemy : public GObject&#123;protected: void Catch();//æ˜¯å¦æŠ“ä½çŽ©å®¶ void virtual MakeDecision(bool b) = 0; //ç¡®å®šæ–¹å‘.AIå®žçŽ°.ä¸‰ç§æ•Œäººé‡å†™ COLORREF color;public: static std::shared_ptr&lt;PacMan&gt; player;//æ™ºèƒ½æŒ‡é’ˆï¼ŒæŒ‡å‘çŽ©å®¶ï¼Œé™æ€å˜é‡ void virtual Draw(HDC &amp;hdc);//ç»˜åˆ¶è‡ªå·± Enemy(int x, int y) : GObject(x, y)//æž„é€ å‡½æ•° &#123; this-&gt;m_nSpeed = ENERMYSPEED;//è®¾ç½®é€Ÿåº¦ m_dir = LEFT;//è®¾ç½®æœå‘ m_cmd = UP;//è®¾ç½®ç§»åŠ¨æ–¹å‘ &#125; void virtual action();//è¦é‡å†™çš„åŠ¨ä½œ&#125;; class RedOne : public Enemy //éšæœºç§»åŠ¨ class BlueOne : public RedOne //å®ˆå«è€… class YellowOne : public RedOne //æ‰°ä¹±è€… çŽ©å®¶å¯¹è±¡ 123456789101112131415161718class PacMan : public GObject&#123;protected: virtual void AchiveCtrl();//é‡å†™è™šå‡½æ•°public: POINT GetPos();//èŽ·å–ä½ç½® bool IsOver();//æ¸¸æˆæ˜¯å¦ç»“æŸ bool IsWin();//çŽ©å®¶æ˜¯å¦èµ¢å¾—æ¸¸æˆ void Draw(HDC &amp;hdc);//ç»˜åˆ¶è‡ªå·± void SetTwCommand(TWARDS command);//è®¾ç½®çŽ©å®¶ä¸‹ä¸€æ­¥æŒ‡ä»¤ PacMan(int x, int y) : GObject(x, y)//æž„é€ å‡½æ•° &#123; this-&gt;m_nSpeed = PLAYERSPEED;//çŽ©å®¶é€Ÿåº¦ m_cmd = m_dir = LEFT;//è®¾ç½®æ–¹å‘ &#125; void action();//åŠ¨ä½œé‡å†™ void SetOver();//è®¾ç½®æ¸¸æˆç»“æŸå‡½æ•°&#125;; å¯ç§»åŠ¨å¯¹è±¡çš„å®žçŽ°123456789101112131415161718192021//å°†å®žé™…åæ ‡è½¬æ¢ä¸ºé€»è¾‘åæ ‡int GObject::PtTransform(int k)&#123; return (k - (pStage-&gt;LD) / 2) / pStage-&gt;LD;&#125;//åˆ¤æ–­ç‰©ä½“æ˜¯å¦åˆ°è¾¾é€»è¾‘åæ ‡ä½ç½®bool GObject::Achive()&#123; int n = (m_ptCenter.x - pStage-&gt;LD / 2) % pStage-&gt;LD; // è®¡ç®—xåæ ‡çš„ä½™æ•° int k = (m_ptCenter.y - pStage-&gt;LD / 2) % pStage-&gt;LD; // è®¡ç®—yåæ ‡çš„ä½™æ•° bool l = (n == 0 &amp;&amp; k == 0); // å¦‚æžœä¸¤ä¸ªä½™æ•°éƒ½ä¸º0,è¯´æ˜Žåˆ°è¾¾ä¸­å¿ƒä½ç½® return l;&#125;//åˆ°è¾¾é€»è¾‘ç‚¹åŽæ›´æ–°æ•°æ®void GObject::AchiveCtrl()&#123; if (Achive()) &#123; m_nArray = PtTransform(m_ptCenter.x); //æ›´æ–°åˆ— m_nRow = PtTransform(m_ptCenter.y); //æ›´æ–°è¡Œ &#125;&#125; å°†ä¸Šä¸€å¸§çš„å›¾åƒæ¸…é™¤,ç”»è¿™ä¸€å¸§çš„å›¾åƒ.1234567891011121314151617void GObject::DrawBlank(HDC &amp;hdc)&#123; // ç”³è¯·èµ„æº,å¹¶äº¤ç»™æ™ºèƒ½æŒ‡é’ˆå¤„ç† HBRUSH hbr = ::CreateSolidBrush(RGB(255, 255, 255)); //åˆ›å»ºç”»åˆ·ï¼Œç»˜åˆ¶çŸ©å½¢å‡½æ•°è¦æ±‚ä½¿ç”¨ std::shared_ptr&lt;HBRUSH&gt; phbr(&amp;hbr, [](auto hbr) &#123; //æŠŠèµ„æºäº¤ç»™æ™ºèƒ½æŒ‡é’ˆå¤„ç†ï¼Œè‡ªåŠ¨é‡Šæ”¾ // ç¦»å¼€ DrawBlankå‡½æ•°æ—¶,ä¼šè‡ªåŠ¨è°ƒç”¨é‡Šæ”¾èµ„æº DeleteObject(*hbr); &#125;); RECT rect; rect.top = m_nY - RD; rect.left = m_nX - RD; rect.right = m_nX + RD; rect.bottom = m_nY + RD; FillRect(hdc, &amp;rect, *phbr);//ç»˜åˆ¶ç©ºç™½çŸ©å½¢&#125; ç¢°æ’žæ£€æµ‹1234567891011121314151617181920212223242526272829303132333435363738394041424344bool GObject::Collision()&#123; bool b = false; //æ‰§è¡Œé‡å†™çš„AchiveCtrlå‡½æ•°æ¶ˆé™¤è±†å­ AchiveCtrl(); //åˆ¤æ–­æŒ‡ä»¤çš„æœ‰æ•ˆæ€§ if (m_nArray &lt; 0 || m_nRow &lt; 0 || m_nArray &gt; MAPLENTH - 1|| m_nRow &gt; MAPLENTH - 1) b = true; else if (Achive()) &#123; switch (m_cmd) &#123;//åˆ¤æ–­è¡Œè¿›çš„æ–¹å‘ case LEFT://åˆ¤æ–­ä¸‹ä¸€ä¸ªæ ¼å­æ˜¯å¦èƒ½å¤Ÿé€šè¡Œ if (m_nArray &gt; 0 &amp;&amp; !pStage-&gt;mapData[m_nRow][m_nArray - 1]) &#123; b = true;//æŒ‡ä»¤æ— æ•ˆ &#125;break; //ä»¥ä¸‹æ–¹å‘çš„åˆ¤æ–­åŽŸç†ç›¸åŒ case RIGHT: ... case UP: ... case DOWN: ...&#125; if (!b) m_dir = m_cmd; //æ²¡æ’žå¢™,æŒ‡ä»¤æˆåŠŸ &#125; //ä¾ç…§çœŸå®žçš„æ–¹å‘ä½ç§» m_nX = m_ptCenter.x; m_nY = m_ptCenter.y; int MAX = pStage-&gt;LD * MAPLENTH + pStage-&gt;LD / 2; int MIN = pStage-&gt;LD / 2; switch (m_dir) &#123; //åˆ¤æ–­è¡Œè¿›çš„æ–¹å‘ case LEFT://åˆ¤æ–­ä¸‹ä¸€ä¸ªæ ¼å­æ˜¯å¦èƒ½å¤Ÿé€šè¡Œ if (m_nArray &gt; 0 &amp;&amp; !pStage-&gt;mapData[m_nRow][m_nArray - 1]) &#123; b = true; break;&#125;//ç¢°æ’žäº† m_ptCenter.x -= m_nSpeed;//å‘å·¦ä½ç§» if (m_ptCenter.x &lt; MIN) m_ptCenter.x = MAX;//ç©¿å¢™ break; //ä»¥ä¸‹æ–¹å‘çš„åˆ¤æ–­åŽŸç†ç›¸åŒ case RIGHT: ... case UP: ... case DOWN: ... &#125; return b;&#125; æ•Œå†›å¯¹è±¡ 123456789// æŠ“ä½ï¼Œæ¸¸æˆç»“æŸvoid Enermy::Catch()&#123; int DX = m_ptCenter.x - player-&gt;GetPos().x; int DY = m_ptCenter.y - player-&gt;GetPos().y; if ((-RD &lt; DX &amp;&amp; DX &lt; RD) &amp;&amp; (-RD &lt; DY &amp;&amp; DY &lt; RD)) &#123; player-&gt;SetOver(); &#125;&#125; æ•Œå†›å¯¹è±¡ç»˜åˆ¶ 1234567891011121314151617181920212223242526void Enermy::Draw(HDC &amp;hdc)&#123; HPEN pen = ::CreatePen(0, 0, color); HPEN oldPen = (HPEN)SelectObject(hdc, pen); //ç»˜åˆ¶åŠåœ†åž‹çš„å¤´ //æ ¹æ®ç¥¯æ•°æ¥ç»˜åˆ¶èº«ä½“å’Œâ€œè…¿éƒ¨â€ if (m_nFrame % 2 == 0) &#123; //çŸ©å½¢çš„èº«å­ //ä»Žå·¦å¾€å³ç»˜åˆ¶â€œè…¿éƒ¨â€ &#125; else &#123; //ç»˜åˆ¶èº«ä½“ //ä»Žå·¦å¾€å³ç»˜åˆ¶â€œè…¿éƒ¨â€ &#125; //æ ¹æ®æ–¹å‘ç»˜åˆ¶çœ¼ç› switch (m_dir) &#123; case UP: case DOWN: case LEFT: case RIGHT: &#125; m_nFrame++; //å‡†å¤‡ç»˜åˆ¶ä¸‹ä¸€ç¥¯ SelectObject(hdc, oldPen);//è¿˜åŽŸç”»ç¬” DeleteObject(pen);//åˆ é™¤ç”»ç¬”å¯¹è±¡ return;&#125; æ•Œå†›å¯¹è±¡çš„è¡Œä¸º123456void Enermy::action()&#123; bool b = Collision();//ç¢°æ’žæ£€æµ‹ MakeDecision(b);//è®¾å®šæ–¹å‘ Catch();//å¼€å§‹æ•æ‰&#125; æ¸¸æˆä¸»ä½“é€»è¾‘12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// çŽ©å®¶å¯¹è±¡,æ™ºèƒ½æŒ‡é’ˆ// è‡ªå·± auto g_me = std::make_shared&lt;PacMan&gt;(P_ROW, P_COLUMS);// è®¾å®šå››ä¸ªæ•Œäººå¯¹è±¡auto e1 = std::make_shared&lt;RedOne&gt;(E_ROW, E_COLUMS);auto e2 = std::make_shared&lt;RedOne&gt;(E_ROW, E_COLUMS);auto e3 = std::make_shared&lt;BlueOne&gt;(E_ROW, E_COLUMS);auto e4 = std::make_shared&lt;YellowOne&gt;(E_ROW, E_COLUMS);//é™æ€å˜é‡ï¼Œåˆå§‹åŒ–ä¸ºç¬¬ä¸€å…³åœ°å›¾GObject::pStage = MapArray[s_n]; //å¼•ç”¨é™æ€æˆå‘˜å˜é‡// è®¾å®šçŽ©å®¶Enermy::player = g_me; // ä¸»æ¶ˆæ¯å¾ªçŽ¯:// çŽ©å®¶æ²¡æœ‰è¢«æŠ“,å¹¶ä¸”å…³å¡&lt;3while (!g_me-&gt;IsOver() &amp;&amp; s_n &lt; STAGE_COUNT) &#123;// åˆ¤æ–­æ˜¯å¦èµ¢å¾—æ¯”èµ›if (g_me-&gt;IsWin()) &#123;s_n++;// é‡è®¾è‡ªå·±å’Œæ•Œäººä½ç½® // åˆ¤æ–­æ˜¯å¦å®Œæˆäº†3å…³,å¦‚æžœå®Œæˆ,é€€å‡ºæ¸¸æˆ,å¦åˆ™è¿›å…¥ä¸‹ä¸€å…³if (s_n &lt; 3) &#123; continue;&#125;// ç»§ç»­è¿›è¡Œå¾ªçŽ¯else break;&#125;// è·³å‡ºå¾ªçŽ¯// èŽ·å–æ¶ˆæ¯if (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) &#123;TranslateMessage(&amp;msg);DispatchMessage(&amp;msg);&#125;// åˆ¤æ–­æ—¶é—´,å¦åˆ™ç”»å¾—å¤ªå¿«ï¼Œæ•Œäººä¸€ä¸‹å°±æŠŠæˆ‘ä»¬æŠ“ä½äº†å°±æ¸¸æˆç»“æŸäº†if (GetTickCount() - dwLastTime &gt;= 40) &#123;dwLastTime = GetTickCount();&#125;else &#123;// æ—¶é—´ä¸åˆ°,æœ¬æ¬¡ä¸è¿›è¡Œç»˜ç”»continue;&#125;// èŽ·å¾—è®¾å¤‡HDC hdc = ::GetDC(g_hwnd);// ä¸ä½¿ç”¨æ—¶è‡ªåŠ¨é‡Šæ”¾std::shared_ptr&lt;HDC__&gt; dc(hdc, [](auto hdc) &#123;::ReleaseDC(g_hwnd, hdc);&#125;);// ç”»è±†å­MapArray[s_n]-&gt;DrawPeas(hdc);// ç”»åœ°å›¾MapArray[s_n]-&gt;DrawMap(hdc);// ç”»æ•ŒäººåŠè‡ªåŠ¨è¿åŠ¨ // ç”»è‡ªå·± // è‡ªå·±å‘å‰ç§»åŠ¨ // èŽ·å–æŒ‰é”® : æŽ§åˆ¶è‡ªå·±çš„æ–¹å‘ // å¦‚æžœæ¸¸æˆç»“æŸif (g_me-&gt;IsOver()) &#123;... &#125;// å¦åˆ™,æç¤ºèµ¢å¾—æ¸¸æˆelse &#123; ...&#125; é‡‘æ‰‹æŒ‡1234567891011//å¿«é€Ÿé€šå…³if (GetAsyncKeyState('B') &amp; 0x8000)&#123; for (int i = 0; i &lt; MAPLENTH; i++) &#123; for (int j = 0; j &lt; MAPLENTH; j++) &#123; peaMapData[i][j] = false; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Projects</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Game</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode172. Factorial Trailing Zeroes]]></title>
    <url>%2F2019%2F03%2F15%2FLeetCode172-Factorial-Trailing-Zeroes%2F</url>
    <content type="text"><![CDATA[Given an integer n, return the number of trailing zeroes in n!. Example 1: 123Input: 3Output: 0Explanation: 3! = 6, no trailing zero. Example 2: 123Input: 5Output: 1Explanation: 5! = 120, one trailing zero. Note: Your solution should be in logarithmic time complexity. The idea is: The ZERO comes from 10. The 10 comes from 2 x 5 And we need to account for all the products of 5 and 2. likes 4Ã—5 = 20 â€¦ So, if we take all the numbers with 5 as a factor, weâ€™ll have way more than enough even numbers to pair with them to get factors of 10 Example OneHow many multiples of 5 are between 1 and 23? There is 5, 10, 15, and 20, for four multiples of 5. Paired with 2â€™s from the even factors, this makes for four factors of 10, so: 23! has 4 zeros. Example TwoHow many multiples of 5 are there in the numbers from 1 to 100? because 100 Ã· 5 = 20, so, there are twenty multiples of 5 between 1 and 100. but wait, actually 25 is 5Ã—5, so each multiple of 25 has an extra factor of 5, e.g. 25 Ã— 4 = 100ï¼Œwhich introduces extra of zero. So, we need know how many multiples of 25 are between 1 and 100? Since 100 Ã· 25 = 4, there are four multiples of 25 between 1 and 100. Finally, we get 20 + 4 = 24 trailing zeroes in 100! The above example tell us, we need care about 5, 5Ã—5, 5Ã—5Ã—5, 5Ã—5Ã—5Ã—5 â€¦. Example ThreeBy given number 4617. 5^1 : 4617 Ã· 5 = 923.4, so we get 923 factors of 5 5^2 : 4617 Ã· 25 = 184.68, so we get 184 additional factors of 5 5^3 : 4617 Ã· 125 = 36.936, so we get 36 additional factors of 5 5^4 : 4617 Ã· 625 = 7.3872, so we get 7 additional factors of 5 5^5 : 4617 Ã· 3125 = 1.47744, so we get 1 more factor of 5 5^6 : 4617 Ã· 15625 = 0.295488, which is less than 1, so stop here. Then 4617! has 923 + 184 + 36 + 7 + 1 = 1151 trailing zeroes. C/C++ code1123456789101112class Solution &#123;public: int trailingZeroes(int n) &#123; int sum=0; while(n&gt;0)&#123; sum+=n/5; n/=5; &#125; return sum; &#125;&#125;;&#125; C/C++ code2123456class Solution &#123;public: int trailingZeroes(int n) &#123; return n==0?0:n/5+trailingZeroes(n/5); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode53. Maximum Subarray]]></title>
    <url>%2F2019%2F03%2F15%2FLeetCode53-Maximum-Subarray%2F</url>
    <content type="text"><![CDATA[Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: 123Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum = 6. Follow up:If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. Optimization problem -DP the format of the sub problem(or the state of each sub problem). recursive 1maxSubArray(A, i) = maxSubArray(A, i - 1) &gt; 0 ? maxSubArray(A, i - 1) : 0 + A[i]; åŠ¨æ€è§„åˆ’ç”¨å¾ªçŽ¯åšã€‚F(i)=numsi&lt;=0);F(i)=nums[i]+F(i-1)(F(i-1)&gt;0) ç»†èŠ‚numsåªæœ‰{-1}æ—¶ï¼Œæ‰€ä»¥å¼€å§‹sum=nums[0]ï¼Œç„¶åŽä»Žç¬¬äºŒä¸ªå¼€å§‹å¾ªçŽ¯ã€‚ 12345678910111213141516171819202122232425class Solution &#123;public: int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123; if(array.empty()) return 0; int cur=array[0]; int max=cur; for(auto it = array.begin()+1;it!=array.end();it++) &#123; if(cur&lt;=0) &#123; cur = *it; &#125; else &#123; cur+=*it; &#125; if(cur&gt;max) &#123; max=cur; &#125; &#125; return max; &#125;&#125;; Divide-and-Conquer The Divide-and-Conquer algorithm breaks nums into two halves and find the maximum subarray sum in them recursively. the maximum subarray spans the two halves. a linear algorithm: starting from the middle element and move to both ends (left and right ends), record the maximum sum we have seen. In this case, the maximum sum is finally equal to the middle element plus the maximum sum of moving leftwards and the maximum sum of moving rightwards. Since we are done with LHS and RHS, we only need to check the case where we pass the middle element.(i.e. the middle element must be included).In that case, since our question asks a continuous subset, it must expand that way. åˆ†æ²»æ³•2*O(n/2)+O(1)=O(n) divideï¼šç”¨é€’å½’æ¥åˆ†åˆ«æ±‚å·¦å³å­é›†çš„max merge:ç”¨dpæ¥ä»Žå·¦å³åˆ†åˆ«çº¿æ€§æŽ¢ç´¢ï¼ŒåŠ ä¸Šmid æœ€åŽæ‰¾åˆ°divideå’Œmergeä¸­æœ€å¤§çš„å°±æ˜¯è¦æ±‚çš„å€¼ã€‚12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; return maxSubArray(nums, 0, nums.size() - 1); &#125;private: int maxSubArray(vector&lt;int&gt;&amp; nums, int l, int r) &#123; if (l &gt; r) &#123; return INT_MIN; &#125; //divide: int m = l + (r - l) / 2; int lmax = maxSubArray(nums, l, m - 1);//left int rmax = maxSubArray(nums, m + 1, r);//right int partmax = max(lmax, rmax);//not including mid //Merge: int ml= 0,mr = 0; //left-DP:O(n/2) for (int i = m - 1, sum = 0; i &gt;= l; i--) &#123; sum += nums[i]; ml = max(sum, ml); &#125; //right-DP:O(n/2) for (int i = m + 1, sum = 0; i &lt;= r; i++) &#123; sum += nums[i]; mr = max(sum, mr); &#125; //Merge-including mid,for continuous subset:O(1) int contmax=ml + mr + nums[m]; return max(partmax,contmax); //2*O(n/2)+O(1)=O(n) &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Optimization problem</tag>
        <tag>Divide and Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kadane's Algorithm]]></title>
    <url>%2F2019%2F03%2F15%2FKadane-s-Algorithm%2F</url>
    <content type="text"><![CDATA[Kadaneâ€™s algorithm Aka Maximum Sum of Subarray Dynamic Programming Maximum Subarray ProblemFrom Wikipedia In computer science, the maximum subarray problem is the task of finding the contiguous subarray within a one-dimensional array, a[1â€¦n], of numbers which has the largest sum. The task is to find a subarray (contiguous elements) of the given array that has the largest sum. For instance: 1[1, 5, -1, 0, 10] The answer would be 15 or the entire array (itâ€™s also a subarray) 1[0, -1, -5, 0, -4] The answer would be 0 and so on. SolutionsBrute-forceAll you need is going through all sub-arrays, keep the global maximum and compare. Dynamic Programming (Kadaneâ€™s Algorithm) O(n) runtime complexity O(1) space. Following function shows the Kadaneâ€™s algorithm implementation which uses two variables, one to store the local maximum and the other to keep track of the global maximum: 123456def max_subarray(A): max_ending_here = max_so_far = A[0] for x in A[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far So we assume that the largest subarray is the first element, then we go through A[1:] elements (all elements except the first one). At each step, what we do is: Can current element plus the last largest sum_ help to find a largest subarray (line 4)? If yes, update the max_ending_here or our local maximum, otherwise current element is the largest subarray (array of one). Then update the global maximum or max_so_far if there is a new global maximum. When the loop is over, return the global maximum. ConclusionKadaneâ€™s algorithm is a Dynamic Programming approach to solve â€œthe largest contiguous elements in an arrayâ€ with runtime of O(n).]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ è¯­è¨€ç¯‡ CV(const and volatile) Type Qualifiers]]></title>
    <url>%2F2019%2F03%2F14%2FC-%E8%AF%AD%E8%A8%80%E7%AF%87-cv-const-and-volatile-type-qualifiers%2F</url>
    <content type="text"><![CDATA[cv (const and volatile) type qualifiers const - defines that the type is constant. volatile - defines that the type is volatile. const1234567891011121314151617class complex&#123;public: complex (double r = 0, double i = 0): re (r), im (i) &#123; &#125; complex&amp; operator += (const complex&amp;); complex&amp; operator -= (const complex&amp;); complex&amp; operator *= (const complex&amp;); complex&amp; operator /= (const complex&amp;); double real () const &#123; return re; &#125; double imag () const &#123; return im; &#125;private: double re, im; friend complex&amp; __doapl (complex *, const complex&amp;); friend complex&amp; __doami (complex *, const complex&amp;); friend complex&amp; __doaml (complex *, const complex&amp;);&#125;; åªæœ‰member funåŽé¢å¯ä»¥ç”¨ constå®šä¹‰ã€‚æˆå‘˜å˜é‡åŽé¢ä¸å¯ä»¥å†™constï¼Œå†™åœ¨å‰é¢ã€‚ const obj å¦‚æžœè°ƒç”¨ non-const member funä¼šç¼–è¯‘å‡ºé”™ã€‚ é”™è¯¯ï¼šå¦‚æžœå®šä¹‰æ—¶æ²¡æœ‰å†™æˆvoid print() const{}; å°±ä¼šæŠ¥é”™ã€‚å› ä¸ºstræ˜¯const-objï¼Œä¸èƒ½ç”¨non-const member funè°ƒç”¨ã€‚ ä¾‹å­ï¼šSTDé‡Œçš„æ“ä½œç¬¦é‡è½½æ¥è‡ª TEMPLATE CLASS basic_stringçš„å®šä¹‰ã€‚stringç±»çš„operator[]ã€‚ ç”¨æˆ·å¯èƒ½æ‹¿[]æ¥æ”¹å˜å­—ç¬¦ä¸²ã€‚å¦‚String str[5]=â€aâ€;ç”±äºŽstringçš„å®žçŽ°æœºåˆ¶æ˜¯å…±äº«æ¨¡å¼ï¼Œä¸å¯ä»¥ç›´æŽ¥æ”¹å˜å†…éƒ¨å†…å®¹ã€‚åªèƒ½æ‹·è´ä¸€ä»½å†æ”¹å˜ã€‚æ‰€ä»¥è¦åšcow(copy on write)è®¾è®¡ã€‚ å¦‚æžœconst String str[2];stræ˜¯const objï¼Œå…¶å†…éƒ¨ä¸å¯ä»¥åŠ¨ã€‚æ‰€ä»¥ä¸å¿…è€ƒè™‘cowã€‚const objåªä¼šè°ƒç”¨const funï¼Œæ‰€ä»¥const funä¸å¿…å†™cowã€‚ 12345678910111213reference operator[](size_type _Off)&#123; // ä¸‹æ ‡å¯å˜åºåˆ— // å¿…é¡»è€ƒè™‘cow return (this-&gt;_Myptr()[_Off]);&#125;const_reference operator[](size_type _Off) const&#123; // ä¸‹æ ‡ä¸å¯å˜åºåˆ— // ä¸å¿…è€ƒè™‘cow return (this-&gt;_Myptr()[_Off]);&#125; å¯è§constå±žäºŽç­¾åçš„ä¸€éƒ¨åˆ†ï¼Œè¿™ä¸¤ä¸ªå‡½æ•°å¯ä»¥é‡è½½ã€‚ C++è§„å®šï¼šå¦‚æžœç±»ä¸­æœ‰æˆå‘˜å‡½æ•°çš„const fun å’Œnonconst funåŒæ—¶å­˜åœ¨ï¼Œåˆ™const objé»˜è®¤è°ƒç”¨const funï¼Œnon-const objé»˜è®¤è°ƒç”¨non-const funã€‚ C++è§„å®šï¼šnon-const funï¼ˆobjå¯å˜ï¼‰å¯ä»¥è°ƒç”¨const funï¼ˆobjä¸å¯å˜ï¼‰ã€‚ åè¿‡æ¥æŠ¥é”™ã€‚ ä¾‹å­ï¼šã€Šcpp primerã€‹15èŠ‚ -åŸºç±»çš„å®šä¹‰1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Quote &#123; /* ** istream&amp;ï¼šå¿…é¡»æ˜¯éžå¸¸é‡ï¼Œå› ä¸ºæœ¬æ“ä½œå°±æ˜¯å‘æµè¯»å‡ºæ•°æ®ï¼Œå…¶çŠ¶æ€ä¼šæ”¹å˜ï¼› ** Quote&amp; ï¼šå¿…é¡»æ˜¯éžå¸¸é‡ï¼Œå› ä¸ºæœ¬æ“ä½œå°±æ˜¯å‘æ­¤å¯¹è±¡å†™å…¥æ•°æ®ï¼Œæ­¤å¯¹è±¡å€¼ä¼šæ”¹å˜ï¼› */ friend istream&amp; operator&gt;&gt;(istream&amp;, Quote&amp;); /* **ostream&amp; ï¼šå¿…é¡»æ˜¯éžå¸¸é‡ï¼Œå› ä¸ºæœ¬æ“ä½œå°±æ˜¯å‘æµå†™å…¥æ•°æ®ï¼Œå…¶çŠ¶æ€ä¼šæ”¹å˜ï¼› **const Quote&amp; ï¼šå¼•ç”¨æ˜¯å› ä¸ºé¿å…èµ‹å€¼å®žå‚ï¼›å¸¸é‡æ˜¯å› ä¸ºé€šå¸¸æ‰“å°å¯¹è±¡ä¸ä¼šæ”¹å˜å¯¹è±¡æœ¬èº«çš„å€¼ï¼› */ friend ostream&amp; operator&lt;&lt;(ostream&amp;, const Quote&amp;); public: /*è¿™ç§ä¼ é€’ä¸­çš„ä»£ç ä½¿ç”¨ä»¥ä¸‹å˜é‡æ¥æŽ§åˆ¶ç¼–è¯‘ï¼› **å˜é‡ï¼šIN_CLASS_INITS/DEFAULT_FCNSï¼›å¯¹åº”C++ä½œç”¨ï¼šç±»åˆå§‹çŠ¶æ€è®¾ç½®/default(é»˜è®¤)ï¼› */#if defined(IN_CLASS_INITS) &amp;&amp; defined(DEFAULT_FCNS) //è‹¥å®šä¹‰ç±»åˆå§‹å€¼è®¾ç½®åŠé»˜è®¤å€¼ï¼Œåˆ™å®šä¹‰é»˜è®¤æž„é€ å‡½æ•°,ä¸æŽ¥å—ä»»ä½•å®žå‚ï¼› Quote() = default; #else /*è‹¥æœªå®šä¹‰ç±»åˆå§‹å€¼åŠé»˜è®¤å€¼ï¼Œåˆ™å®šä¹‰æž„é€ å‡½æ•°ï¼Œå‡½æ•°ä½“ç©ºï¼› **æž„é€ å‡½æ•°åˆå§‹åˆ—è¡¨ä¸ºæ–°åˆ›å»ºçš„æ•°æ®æˆå‘˜priceåˆå§‹åŒ–ï¼Œå¯¹åº”åˆå§‹åŒ–å€¼ä¸º 0.0ï¼› */ Quote() : price(0.0) &#123; &#125;#endif // !defined(IN_CLASS_INITS) &amp;&amp; defined(DEFAULT_FCNS) //åˆå§‹åŒ–æž„é€ å‡½æ•° Quote(const string &amp;book,double sales_price): bookNo(book),price(sales_price)&#123; &#125; //è™šæžæž„å‡½æ•°ï¼ŒåŠ¨æ€ç»‘å®š#ifdef DEFAULT_FCNS virtual ~Quote() = default;#else virtual ~Quote() &#123; &#125;#endif // DEFAULT_FCNS //const funã€‚ å› ä¸ºbookNoè¢«æœŸæœ›æ˜¯const objï¼Œæ‰€ä»¥åªèƒ½è¢«const funè°ƒç”¨ï¼Œå¿…é¡»å®šä¹‰ä¸ºconst funï¼Œå¦åˆ™æŠ¥é”™ã€‚ string isbn() const &#123; return bookNo; &#125; //è™šå‡½æ•°ã€‚å°†åœ¨æ´¾ç”Ÿç±»ä¸­é‡å†™ï¼Œæ ¹æ®ä¹¦çš„æ•°é‡ï¼Œé‡‡å–ä¸åŒçš„æŠ˜æ‰£ç®—æ³•ã€‚ //å› ä¸ºpriceï¼ˆå®šä»·ï¼‰ä¹Ÿæ˜¯const obj,ä¸ä¼šè¢«æ”¹ã€‚æ‰€ä»¥å®šä¹‰ä¸ºconst funã€‚ virtual double net_price(size_t n) const &#123; return n*price; &#125;//è™šå‡½æ•°è¿”å›žåŠ¨æ€åˆ†é…çš„è‡ªèº«å‰¯æœ¬private: const string bookNo;//ä¹¦å·ï¼Œè¢«æœŸæœ›æ˜¯const objprotected:#ifndef IN_CLASS_INITS const double price = 0.0;#else const double price;#endif // !IN_CLASS_INITS&#125;; mutableMay appear in the declaration of a [non-static [class members] of non-reference non-const] type: 1234class X &#123; mutable const int* p; // OK mutable int* const q; // ill-formed&#125;; Mutable is used to specify that the member does not affect the externally visible state of the class (as often used for [mutexes, memo caches, lazy evaluation, and access instrumentation]). 12345678910111213class ThreadsafeCounter &#123; mutable std::mutex m; // The "M&amp;M rule": mutable and mutex go together int data = 0; public: int get() const &#123; std::lock_guard&lt;std::mutex&gt; lk(m); return data; &#125; void inc() &#123; std::lock_guard&lt;std::mutex&gt; lk(m); ++data; &#125;&#125;;]]></content>
      <categories>
        <category>ã€ŠC++ Primerã€‹</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>const</tag>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode295.Find Median from Data Stream]]></title>
    <url>%2F2019%2F03%2F14%2FLeetCode295-Find-Median-from-Data-Stream%2F</url>
    <content type="text"><![CDATA[Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. For example,[2,3,4], the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5 Design a data structure that supports the following two operations: void addNum(int num) - Add a integer number from the data stream to the data structure.double findMedian() - Return the median of all elements so far. Example: addNum(1)addNum(2)findMedian() -&gt; 1.5addNum(3)findMedian() -&gt; 2 Follow up: If all integer numbers from the stream are between 0 and 100, how would you optimize it?If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it? æ³•ä¸€å¼€ä¸¤ä¸ªstlçš„ä¼˜å…ˆé˜Ÿåˆ—-maxheapã€‚smallæ”¾å‰ä¸€åŠå¤§çš„æ•°ï¼Œlargeæ”¾åŽä¸€åŠå¤§çš„æ•°ã€‚ä¸ºäº†è®©ä»–ä»¬çš„é¡ºåºä»Žå°åˆ°å¤§ä¸å˜ï¼Œsmallçš„ç”¨åŽŸæ•°å­˜ï¼Œlargeçš„ç”¨è´Ÿæ•°å­˜ã€‚å¢žåˆ O(logn)ï¼ŒæŸ¥æ‰¾O(1)ç»†èŠ‚ï¼š1.å¦‚æžœæ˜¯å¥‡æ•°å¤§å°ï¼Œsmall.top()å°±æ˜¯è¦æ±‚çš„ä¸­ä½æ•°ã€‚å¦‚æžœæ˜¯å¶æ•°ï¼Œ(small.top()-large.top())/2å°±æ˜¯ä¸­ä½æ•°ï¼Œæ˜¯å‡ä¸æ˜¯åŠ 2.ä¼˜å…ˆé˜Ÿåˆ—çš„ç±»åž‹æ˜¯long. -2^31 (which negated is itself, when using 32-bit ints), I use integer types larger than 32 bits.3.(small.top()-large.top())/2.0ã€‚è¦é™¤ä»¥2.0ï¼Œå¦åˆ™è¿”å›žçš„æ˜¯æ•´æ•° 12345678910111213141516171819202122232425262728293031323334class MedianFinder &#123;private: std::priority_queue&lt;long&gt; small,large; public: /** initialize your data structure here. */ MedianFinder() &#123; &#125; void addNum(int num) &#123; small.push(num);//O(logn) large.push(-small.top());//O(logn) small.pop();//O(logn) //ä¿è¯smallå¤§äºŽæˆ–è€…ç­‰äºŽlargeçš„ä¸ªæ•° if(small.size()&lt;large.size()) &#123; small.push(-large.top()); large.pop(); &#125; &#125; double findMedian() &#123; return small.size()&gt;large.size()? small.top():(small.top()-large.top())/2.0; &#125;&#125;;/** * Your MedianFinder object will be instantiated and called as such: * MedianFinder obj = new MedianFinder(); * obj.addNum(num); * double param_2 = obj.findMedian(); */ æ³•äºŒå¼€ä¸¤ä¸ªstlçš„ä¼˜å…ˆé˜Ÿåˆ—-maxheapå’Œminheapï¼Œç”¨æ¥å­˜å‰åŽä¸€åŠçš„æ•°ç»†èŠ‚ï¼š1.å¦‚æžœnumå°äºŽmaxheap.top(),è¯´æ˜Žåœ¨numå°çš„é‚£ä¸€åŠé‡Œï¼Œæ”¾å…¥æœ€å¤§å †ï¼Œå¦‚æžœä¸è¿™æ ·çš„è¯ï¼Œå¯èƒ½ä¼šæŽ’åºå¤±è´¥ã€‚2.å‡å®šmaxheapæ°¸è¿œå¤§äºŽæˆ–è€…ç­‰äºŽminheapçš„æ•°é‡ï¼Œè¿™æ ·å¦‚æžœä¸¤ä¸ªå †ç›¸ç­‰å°±æ˜¯å¹³å‡å€¼ã€‚ä¸ç›¸ç­‰å°±æ˜¯maxheap.top3.åˆ©ç”¨AVLçš„æ€æƒ³ï¼Œä¿è¯ä¸¤ä¸ªå †çš„æ·±åº¦ä¹‹å·®ä¸è¶…è¿‡1ï¼Œå¦‚æžœè¶…è¿‡1,å°±æŠŠmaxå †é¡¶æ”¾å…¥minå †ä¸­ 1234567891011121314151617181920212223242526272829303132333435class MedianFinder &#123;private: priority_queue&lt;long&gt; maxheap; priority_queue&lt;long, vector&lt;long&gt;, greater&lt;long&gt;&gt; minheap;public: /** initialize your data structure here. */ MedianFinder() &#123; &#125; void addNum(int num) &#123; //ç»†èŠ‚ï¼šå¦‚æžœnumå°äºŽmaxheap.top(),è¯´æ˜Žåœ¨numå°çš„é‚£ä¸€åŠé‡Œï¼Œæ”¾å…¥æœ€å¤§å †ï¼Œå¦‚æžœä¸è¿™æ ·çš„è¯ï¼Œå¯èƒ½ä¼šæŽ’åºå¤±è´¥ã€‚ if (maxheap.size() == 0 || num &lt; maxheap.top()) &#123; maxheap.push(num); &#125; else minheap.push(num); //å¹³è¡¡äºŒå‰æ ‘ if (minheap.size()&gt; maxheap.size()) &#123; maxheap.push(minheap.top()); minheap.pop(); &#125; else if (maxheap.size()&gt;1 + minheap.size()) &#123; minheap.push(maxheap.top()); maxheap.pop(); &#125; &#125; double findMedian() &#123; return maxheap.size()&gt;minheap.size() ? maxheap.top() : (maxheap.top() + minheap.top()) / 2.0; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>AVL</tag>
        <tag>priority_queue</tag>
        <tag>Heapsort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ ç®—æ³•ç¯‡ std::nth_element]]></title>
    <url>%2F2019%2F03%2F14%2FC-%E7%AE%97%E6%B3%95%E7%AF%87-std-nth-element%2F</url>
    <content type="text"><![CDATA[template&lt; class RandomIt &gt; void nth_element( RandomIt first, RandomIt nth, RandomIt last ); 123456789101112131415#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;functional&gt; int main()&#123; std::vector&lt;int&gt; v&#123;5, 6, 4, 3, 2, 6, 7, 9, 3&#125;; std::nth_element(v.begin(), v.begin() + v.size()/2, v.end()); std::cout &lt;&lt; "The median is " &lt;&lt; v[v.size()/2] &lt;&lt; '\n'; std::nth_element(v.begin(), v.begin()+1, v.end(), std::greater&lt;int&gt;()); std::cout &lt;&lt; "The second largest element is " &lt;&lt; v[1] &lt;&lt; '\n';&#125; è¾“å‡ºï¼š 12The median is 5The second largest element is 7 to be conituedâ€¦]]></content>
      <categories>
        <category>ã€ŠC++ Primerã€‹</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>Sort</tag>
        <tag>Algorithms library</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[åˆ·é¢˜ç¬”è®° C/C++åŸºç¡€]]></title>
    <url>%2F2019%2F03%2F13%2F%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-C-C-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[ç¼–è¯‘Q: 1234567void func()&#123; char b[2]=&#123;0&#125;; strcpy(b,"aaaa");&#125;ä»¥ä¸‹è¯´æ³•é‚£ä¸ªæ­£ç¡®() Debugç‰ˆå´©æºƒï¼ŒReleaseç‰ˆæ­£å¸¸ A: 1234assert å«ä¹‰æ˜¯æ–­è¨€ï¼Œå®ƒæ˜¯æ ‡å‡†C++çš„cassertå¤´æ–‡ä»¶ä¸­å®šä¹‰çš„ä¸€ä¸ªå®ï¼Œç”¨æ¥åˆ¤æ–­ä¸€ä¸ªæ¡ä»¶è¡¨è¾¾å¼çš„å€¼æ˜¯å¦ä¸ºture,å¦‚æžœä¸ä¸ºtrue, ç¨‹åºä¼šç»ˆæ­¢ï¼Œå¹¶ä¸”æŠ¥å‘Šå‡ºé”™è¯¯ï¼Œè¿™æ ·å°±å¾ˆå®¹æ˜“å°†é”™è¯¯å®šä½ é€šå¸¸æˆ‘ä»¬å¼€å‘çš„ç¨‹åºæœ‰2ç§æ¨¡å¼:Debugæ¨¡å¼å’ŒReleaseæ¨¡å¼1. åœ¨Debugæ¨¡å¼ä¸‹,ç¼–è¯‘å™¨ä¼šè®°å½•å¾ˆå¤šè°ƒè¯•ä¿¡æ¯,ä¹Ÿå¯ä»¥åŠ å…¥å¾ˆå¤šæµ‹è¯•ä»£ç ,æ¯”å¦‚åŠ å…¥æ–­è¨€assertï¼Œæ–¹ä¾¿æˆ‘ä»¬ç¨‹åºå‘˜æµ‹è¯•,ä»¥åŠå‡ºçŽ°bugæ—¶çš„åˆ†æžè§£å†³ã€‚2. Releaseæ¨¡å¼ä¸‹,å°±æ²¡æœ‰ä¸Šè¿°é‚£äº›è°ƒè¯•ä¿¡æ¯,è€Œä¸”ç¼–è¯‘å™¨ä¹Ÿä¼šè‡ªåŠ¨ä¼˜åŒ–ä¸€äº›ä»£ç ,è¿™æ ·ç”Ÿæˆçš„ç¨‹åºæ€§èƒ½æ˜¯æœ€ä¼˜çš„,ä½†æ˜¯å¦‚æžœå‡ºçŽ°é—®é¢˜,å°±ä¸æ–¹ä¾¿åˆ†æžæµ‹è¯•äº†ã€‚å› ä¸ºè¿™æ ·ä¼šè¦†ç›–ä¸å±žäºŽè‡ªå·±çš„å†…å­˜ï¼Œè¿™æ˜¯æ­ä¸Šäº†ç¨‹åºå´©æºƒçš„åˆ—è½¦ï¼Œå³æœªå®šä¹‰è¡Œä¸ºï¼Œå‡ºçŽ°ä»€ä¹ˆåŽæžœéƒ½æœ‰å¯èƒ½çš„ï¼Œç¨‹åºå‘˜çš„èŒè´£æ˜¯ä¿è¯ä¸è¶Šç•Œï¼Œè€Œä¸æ˜¯è¿½é—®è¶Šç•Œä¹‹åŽä¼šå‘ç”Ÿä»€ä¹ˆã€‚ Q: 12345ä»¥ä¸‹å™è¿°æ­£ç¡®çš„æ˜¯ï¼ˆ ï¼‰ã€‚å¯ä»¥æŠŠdefineå’Œifå®šä¹‰ä¸ºç”¨æˆ·æ ‡è¯†ç¬¦ã€‚Ã—å¯ä»¥æŠŠdefineå®šä¹‰ä¸ºç”¨æˆ·æ ‡è¯†ç¬¦ï¼Œä½†ä¸èƒ½æŠŠifå®šä¹‰ä¸ºç”¨æˆ·æ ‡è¯†ç¬¦ã€‚âˆšå¯ä»¥æŠŠifå®šä¹‰ä¸ºç”¨æˆ·æ ‡è¯†ç¬¦ï¼Œä½†ä¸èƒ½æŠŠdefineå®šä¹‰ä¸ºç”¨æˆ·æ ‡è¯†ç¬¦ã€‚Ã—defineå’Œiféƒ½ä¸èƒ½å®šä¹‰ä¸ºç”¨æˆ·æ ‡è¯†ç¬¦ã€‚Ã— A: 12é¢„å®šä¹‰æ ‡è¯†ç¬¦ï¼šdefine scanf printf includeã€‚â€» é¢„å®šä¹‰æ ‡è¯†ç¬¦å¯ä»¥åšä¸ºç”¨æˆ·æ ‡è¯†ç¬¦ã€‚ Q: 123456å¼•ç”¨æ ‡å‡†åº“ï¼Œä¸‹é¢çš„è¯´æ³•å“ªäº›æ˜¯æ­£ç¡®çš„ï¼Ÿæ­£ç¡®ç­”æ¡ˆ: B ä½ çš„ç­”æ¡ˆ: B (æ­£ç¡®)A.è¯­å¥#include "stdio. h" æ˜¯æ­£ç¡®çš„ï¼Œè€Œä¸”ç¨‹åºç¼–è¯‘çš„é€Ÿåº¦æ¯”#include&lt;stdio. h&gt;è¦å¿«B.è¯­å¥#include &lt;stdio. h&gt;æ˜¯æ­£ç¡®çš„ï¼Œè€Œä¸”ç¨‹åºç¼–è¯‘çš„é€Ÿåº¦æ¯”#include"stdio. h"è¦å¿«C.è¯­å¥#include "stdio. h"å’Œ#include &lt;stdio. h&gt;éƒ½æ˜¯æ­£ç¡®çš„ï¼Œç¨‹åºç¼–è¯‘é€Ÿåº¦æ²¡æœ‰åŒºåˆ«D.è¯­å¥#include "stdio. h"æ˜¯é”™è¯¯çš„ A: 12é€šè¿‡&lt;&gt;ï¼Œï¼ˆåº“é‡Œï¼‰ä¸€æ­¥å°±æ‰¾åˆ°äº†é€šè¿‡â€œâ€ï¼Œ ç”±äºŽå…ˆä»Žå½“å‰ç›®å½•ä¸­æ‰¾ï¼ˆæœªæ‰¾åˆ°ï¼‰ï¼Œå†åˆ°åº“ä¸­å¯»æ‰¾ï¼ˆæ‰¾åˆ°ï¼‰ï¼Œæ¯”å‰è€…å¤šäº†ä¸€æ­¥ï¼Œæ‰€ä»¥èŠ±è´¹æ—¶é—´æ¯”å‰è€…å¤š C++åŸºç¡€å†…å­˜ç®¡ç†stackQ:å¦‚ä¸‹C++ç¨‹åºï¼Œè¯·é—®åˆšè¿›å…¥funcå‡½æ•°æ—¶ï¼Œå‚æ•°åœ¨æ ˆä¸­çš„å½¢å¼å¯èƒ½ä¸º ï¼ˆå·¦ä¾§ä¸ºåœ°å€ï¼Œå³ä¾§ä¸ºæ•°æ®â€”ï¼‰ 123int i=0x22222222ï¼› char szTest[]=â€aaaaâ€; //açš„asciiç ä¸º0x61 func(I, szTest); //å‡½æ•°åŽŸåž‹ä¸ºvoid func(int a,char *sz); A: 123450x0013FCF0 0x0013FCF80x0013FCF4 0x222222220x0013FCF8 0x616161611ï¼Œå¯¹äºŽx86ï¼Œæ ˆçš„å­˜å‚¨ï¼šä»Žé«˜åˆ°ä½Ž2ï¼Œå‡½æ•°è°ƒç”¨å…¥æ ˆé¡ºåºæ˜¯ï¼šä»Žå³åˆ°å·¦ è¡¨è¾¾å¼sizeofQï¼š 1234567win32ç³»ç»Ÿé‡Œï¼Œä¸‹é¢å‡ ä¸ªsizeofçš„è¿è¡Œç»“æžœæ˜¯ï¼ˆï¼‰int intValue=1024;char str[]="Tencent";const char* ch=str;sizeof(intValue)=__a___;//4sizeof(str)=__b____;//8sizeof(ch)=____c___;//4 A: 1234567891011121314151617181920212223242526272829303132333435363738394041424344451. cppp ex4_29:int x[10]; int *p = x;cout &lt;&lt; sizeof(x) / sizeof(*x);//10/1=10æ•°ç»„æ‰€å å†…å­˜å¤§å°/æ•°ç»„æ¯ä¸ªå…ƒç´ æ‰€å å†…å­˜çš„å¤§å°=æ•°ç»„çš„å®¹é‡ã€‚å› ä¸ºcppæ•°ç»„ä¸å†…ç½®æ±‚å®¹é‡çš„æ–¹æ³•ï¼Œå¯ä»¥ç”¨è¿™ä¸ªæ–¹æ³•æ±‚æ•°ç»„å®¹é‡ã€‚æ— è®ºæ˜¯æ•´åž‹æ•°ç»„è¿˜æ˜¯å­—ç¬¦æ•°ç»„ï¼Œæ•°ç»„åä½œä¸ºå³å€¼çš„æ—¶å€™éƒ½ä»£è¡¨æ•°ç»„é¦–å…ƒç´ çš„é¦–åœ°å€ã€‚æ•°ç»„åä¸å‘ç”Ÿé™çº§ï¼ˆè¿˜æ˜¯æ•°ç»„ï¼‰ï¼šsizeofï¼ˆæ•°ç»„åï¼‰ï¼Œ&amp;æ•°ç»„å æ•°ç»„å‘ç”Ÿé™çº§ï¼ˆå˜æˆæŒ‡é’ˆï¼‰: æ•°ç»„åä½œä¸ºå‚æ•°ä¼ å‚ï¼Œæ•°ç»„åå‚ä¸Žè¿ç®—cout &lt;&lt; sizeof(p) / sizeof(*p);//4/4=1 æŒ‡é’ˆçš„å¤§å°/æŒ‡é’ˆæ‰€æŒ‡å†…å®¹ç±»åž‹intçš„å¤§å°2. char str1[]="Tencent";char str2[]=&#123;'T','e','n','c','e','n','t'&#125;;æ³¨æ„åŒºåˆ«ï¼šsizeof(str1)=8;//8*sizeof(char)=8;//å¯¹äºŽä¸€ä¸ªæ•°ç»„ï¼Œè¿”å›žè¿™ä¸ªæ•°ç»„å çš„æ€»ç©ºé—´."Tencent"æ•æ„Ÿè¯æœ‰T e n c e n t \0å…«ä¸ªå­—ç¬¦ï¼Œæ‰€ä»¥stræ•°ç»„çš„é•¿åº¦æ˜¯8.sizeof(str2)=7; //æ²¡æœ‰ç»“æŸç¬¦strlen(str1)=7;//strlenä¸åŒºåˆ†æ˜¯æ•°ç»„è¿˜æ˜¯æŒ‡é’ˆï¼Œå°±è¯»åˆ°\0ä¸ºæ­¢è¿”å›žé•¿åº¦ã€‚å¹¶ä¸”strlenæ˜¯ä¸æŠŠ\0è®¡å…¥å­—ç¬¦ä¸²çš„é•¿åº¦çš„ã€‚sizeofï¼ˆcharï¼‰=1;//charç±»åž‹å ä¸€ä¸ªå­—èŠ‚sizeofï¼ˆintï¼‰=4;//intç±»åž‹å 4ä¸ªå­—èŠ‚sizeof(ch)=sizeof(char*)=4;//chæ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œåœ¨ C/C++ ä¸­ä¸€ä¸ªæŒ‡é’ˆå 4ä¸ªå­—èŠ‚ 3.ã€Šcpppã€‹p139ï¼šsizeofè¿”å›žä¸€ä¸ªè¡¨è¾¾å¼æˆ–è€…ç±»åž‹åå­—æ‰€å çš„å­—èŠ‚æ•°ã€‚æ»¡è¶³å³ç»“åˆå¾‹,ä¸”ä¸Ž*ä¼˜å…ˆçº§ä¸€æ ·ï¼Œæ‰€ä»¥sizeof *pç­‰ä»·äºŽsizeof(*p)ã€‚è¿”å›žå€¼æ˜¯size_tç±»åž‹ã€‚sizeofä¸ä¼šè®¡ç®—è¿ç®—å¯¹è±¡çš„å€¼ã€‚å³ä½¿è§£å¼•ç”¨ä¸€ä¸ªæ— æ•ˆæŒ‡é’ˆï¼Œä¾ç„¶æ˜¯ä¸€ä¸ªå®‰å…¨çš„è¡Œä¸ºï¼Œå› ä¸ºæŒ‡é’ˆå¹¶æ²¡æœ‰çœŸæ­£è¢«ä½¿ç”¨ã€‚è¯­æ³•ï¼šâ‘ sizeof(type);ç±»åž‹å¤§å°ã€‚â‘¡sizeof expr;è¡¨è¾¾å¼å¤§å°ã€‚className data,*p;sizeof(className);//classNameç±»åž‹çš„å¯¹è±¡æ‰€å ç©ºé—´å¤§å°sizeof data;//åŒsizeof(className)sizeof *p;//åŒsizeof(className)sizeof p;//æŒ‡é’ˆå¤§å°,44.ex4_28:è¾“å‡ºæ¯ç§ç©ºé—´å†…ç½®ç±»åž‹å¤§å°ï¼ˆ32ä½ï¼‰bool is 1bytes.char is 1bytes.wchar_t is 2bytes.char16_t is 2bytes.char32_t is 4bytes.short is 2bytes.int is 4bytes.long is 4bytes.long long is 8bytes.float is 4bytes.double is 8bytes.long double is 8bytes. è¿ç®—ç¬¦ä¼˜å…ˆçº§Q: 1234567ä»¥ä¸‹ç¨‹åºçš„è¾“å‡ºç»“æžœæ˜¯ï¼ˆ1ï¼‰ã€‚main()&#123; int a=4,b=5,c=0,d; d=!a&amp;&amp;!b||!c; printf("%d\n",d);&#125; A: 123456789101112å•ç›®ä¼˜å…ˆçº§æœ€é«˜ã€‚d=0&amp;&amp;0||1ã€‚é€»è¾‘è¡¨è¾¾å¼ä»Žå·¦è‡³å³ã€‚ç­”æ¡ˆä¸º1.[æ‰©å±•]1.ex4_30ï¼šsizeofä¼˜å…ˆçº§å’Œè§£å¼•ç”¨*ä¸€çº§ï¼Œæ¬¡äºŽæˆå‘˜é€‰æ‹©ï¼Œå•ç›®&gt;åŒç›®sizeof x + y // (sizeof x)+y . "sizeof" has higher precedence than binary`\+`.sizeof p-&gt;mem[i] // sizeof(p-&gt;mem[i])sizeof a &lt; b // sizeof(a) &lt; bsizeof f() // å¦‚æžœFè¿”å›žç©ºï¼Œåˆ™æ— å®šä¹‰ã€‚å¦åˆ™è¿”å›žè¿”å›žæŒ‡çš„ç±»åž‹æ‰€å å¤§å°ã€‚2.[]é«˜äºŽ*,[]ä»Žå·¦å¾€å³ï¼Œ*ä»Žå³å¾€å·¦int *c[4];//16ã€‚4ä¸ªï¼ˆint*)ç±»åž‹çš„æ•°ç»„=16int(*d)[4];//4ã€‚æŒ‡å‘4ä¸ªintåž‹çš„æ•°ç»„çš„æŒ‡é’ˆ=4 è½¬åž‹Q: 1234567891011#include &lt;stdio.h&gt;int main(void)&#123; unsigned int a = 1; signed int b = -3; int c; (a+b&gt;0)?(c=1):(c=0); printf("%d",c); return 0;&#125;æ­£ç¡®ç­”æ¡ˆ: 1 ä½ çš„ç­”æ¡ˆ: 0 (é”™è¯¯) A: 12unsigned int + int = unsigned int + [unsigned int]int ä¼šè½¬æ¢ä¸º unsigned int å­—ç¬¦ä¸²ã€å‘é‡ã€æ•°ç»„å­—ç¬¦ä¸²æ•°ç»„1.çŽ¯å½¢é˜Ÿåˆ—c[1..m],mä¸ºæ•°ç»„é•¿åº¦ï¼Œfä¸ºé˜Ÿå¤´å…ƒç´ åœ¨æ•°ç»„ä¸­çš„ä½ç½®ï¼Œræ˜¯é˜Ÿå°¾å…ƒç´ çš„åŽä¸€ä½ç½®(é¡ºæ—¶é’ˆ),è‹¥é˜Ÿåˆ—éžç©ºï¼Œé˜Ÿåˆ—ä¸­å…ƒç´ ä¸ªæ•°çš„å…¬å¼ï¼š(r-f+m)%m Q: 12345ä»¥ä¸‹ C è¯­è¨€æŒ‡ä»¤ï¼šint a[5] = &#123;1,3,5,7,9&#125;;int *p = (int *)(&amp;a+1);printf(â€œ%d,%dâ€,*(a+1) ï¼Œ *(p-1));è¿è¡Œç»“æžœæ˜¯ä»€ä¹ˆï¼Ÿ A: 1[è§£]3,9 Q: 12345ä¸‹åˆ—å…³äºŽå¯¹è±¡æ•°ç»„çš„æè¿°ä¸­ï¼Œ( B )æ˜¯é”™è¯¯çš„ã€‚A.å¯¹è±¡æ•°ç»„çš„ä¸‹æ ‡æ˜¯ä»Ž 0 å¼€å§‹çš„B.å¯¹è±¡æ•°ç»„çš„æ•°ç»„åæ˜¯ä¸€ä¸ªå¸¸é‡æŒ‡é’ˆC.å¯¹è±¡æ•°ç»„çš„æ¯ä¸ªå…ƒç´ æ˜¯åŒä¸€ä¸ªç±»çš„å¯¹è±¡D.å¯¹è±¡æ•°ç»„åªèƒ½èµ‹åˆå€¼ï¼Œè€Œä¸èƒ½è¢«èµ‹å€¼ã€‚ A: 12B:æ•°ç»„åæ°¸è¿œä¸å¯èƒ½æ˜¯æŒ‡é’ˆï¼Œè¿™æ˜¯ä¸¤ä¸ªç±»åž‹ï¼Œåªä¸è¿‡å‡½æ•°ä¼ é€’æ—¶æ•°ç»„åä¼šé€€åŒ–æˆæŒ‡é’ˆã€‚D:æ•°ç»„åªèƒ½åˆå§‹åŒ–èµ‹åˆå€¼ï¼Œå¯ä»¥å¯¹æ•°ç»„ä¸­çš„æˆå‘˜èµ‹å€¼ï¼Œä½†ä¸èƒ½å¯¹æ•°ç»„èµ‹å€¼ã€‚ æŒ‡é’ˆæ•°ç»„Q: 12345678è®¾æœ‰ä»¥ä¸‹å®šä¹‰ï¼ša[4][3]=&#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;;int (*prt)[3]=a, *p=a[0];åˆ™ä»¥ä¸‹èƒ½å¤Ÿæ­£ç¡®è¡¨ç¤ºæ•°ç»„å…ƒç´ a[1][2]çš„è¡¨è¾¾å¼æ˜¯å“ªäº›ï¼Ÿ A. *((*prt+1)[2])B. *(*(p+5))C. (*prt+1)+2D. *(*(a+1)+2)ã€‚âˆš A: 123456789101112131415161718192021222324252627282930313233ä¸»è¦è€ƒå¯Ÿ.ä¸‹æ ‡å’ŒæŒ‡é’ˆè½¬åŒ–å…¬å¼ï¼š*(a+n) = a[n]æ‹†åˆ†äºŒç»´æ•°ç»„int a[4][3] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 &#125;;æ‹†åˆ†æˆï¼šint b[3] = &#123;1, 2, 3 &#125;;int c[3] = &#123;4, 5, 6 &#125;;int d[3] = &#123;7, 8, 9 &#125;;int e[3] = &#123;10, 11, 12 &#125;;é‚£ä¹ˆå°±æœ‰ï¼ša[4] = &#123; b, c, d, e &#125;; aæ˜¯æ•°ç»„aä¸­ç¬¬ä¸€ä¸ªå…ƒç´ bçš„åœ°å€ int (*prt)[3]=aå°±æ˜¯int b[3];int *prt = &amp;b;å³å®šä¹‰äº†ä¸€ä¸ªæŒ‡å‘â€œæ•°ç»„ç¬¬ä¸€ä¸ªå…ƒç´ çš„åœ°å€â€çš„æŒ‡é’ˆprtï¼›aè¡¨ç¤ºçš„æ­£æ˜¯bçš„åœ°å€ã€‚æ‰€ä»¥ï¼Œè¿™é‡Œç­‰ä»·äºŽï¼šprt = aã€‚Aï¼š* (( * prt+1)[2])*a å³a[0]ï¼Œä¹Ÿå°±æ˜¯bï¼›( b+1) è¡¨ç¤º å…ƒç´ 2çš„åœ°å€ï¼Œä¹Ÿå°±æ˜¯a[0][1]çš„åœ°å€ï¼›(b+1)[2] â†’ *( (b+1) + 2 ) = *(b+3) = b[3]ï¼Œè¶Šç•Œäº†ï¼å…¶å®žå°±æ˜¯c[0]ï¼ŒVSä¸ŠéªŒè¯è¿‡ï¼Œè¾“å‡ºä¹Ÿæ˜¯Bï¼š* ( * (p+5))int *p = a[0]ï¼Œç›¸å½“äºŽint *p = bï¼Œé‡åˆ°pç›´æŽ¥ç”¨bæ›¿æ¢å°±è¡Œäº†ï¼* (p+5)ç­‰ä»·äºŽb[5]ï¼Œä¹Ÿå°±æ˜¯c[2]ï¼Œå…ƒç´ 6ï¼Œå‰é¢è¿˜å¤šä¸ª*ï¼Œæ‰€ä»¥è¿™ä¸ªé”™çš„ä¹Ÿå¾ˆæ˜Žæ˜¾ã€‚Cï¼š( * prt+1)+2( * a+1)+2,*ä¼˜å…ˆçº§é«˜äºŽ+,(b+1) + 2 = b+3ï¼Œæ˜¯4çš„åœ°å€ï¼Œä¹Ÿå°±æ˜¯c[0]çš„åœ°å€ï¼›åŒæ ·é”™è¯¯ã€‚D:ä¸‹æ ‡å’ŒæŒ‡é’ˆè½¬åŒ–å…¬å¼ï¼š*(a+n) = a[n]ï¼Œè¿™ä¸ªæ­£åéƒ½å¯ä»¥ä½¿ç”¨ï¼Œè€Œä¸”å¾ˆå¥½ç”¨ã€‚ å£°æ˜ŽconstQ: 12345678What is output if you compile and execute the following c code?void main()&#123; int i = 11; int const *p = &amp;i; p++; printf("%d",*p);&#125; A: 12345678910111213141516171819202122232425262728293031323334353637383940414243[è§£]Garbage valueã€‚pæŒ‡æ˜¯å¸¸é‡ï¼Œä¸èƒ½æ”¹å˜æ‰€æŒ‡åœ°å€ã€‚[æ‰©å±•]1.constç”¨æ¥å®šä¹‰ä¸èƒ½æ”¹å˜çš„å˜é‡ã€‚æ‰€ä»¥â‘ å¯¹è±¡å¿…é¡»åˆå§‹åŒ–ã€‚â‘¡ä¸€ç»åˆ›é€ åŽä¸èƒ½èµ‹å€¼ã€‚const int i =get_size();//æ­£ç¡®ã€‚è¿è¡Œæ—¶åˆå§‹åŒ–ã€‚const int j = 42;//æ­£ç¡®ã€‚ç¼–è¯‘æ—¶åˆå§‹åŒ–ã€‚const int k;//é”™è¯¯ã€‚æœªåˆå§‹åŒ–ã€‚j=33;//é”™è¯¯ã€‚ä¸èƒ½èµ‹å€¼ã€‚const int h = j;//æ­£ç¡®ã€‚æ‹·è´åˆå§‹åŒ–ã€‚æ‹·è´ä¸€ä¸ªå¯¹è±¡å¹¶ä¸ä¼šæ”¹å˜å®ƒã€‚2.reference to constï¼šä¸ç”¨åšä¿®æ”¹ç»‘å®šçš„å¯¹è±¡ã€‚const int c=1024;const int &amp;r1=c;//æ­£ç¡®ã€‚å¸¸é‡å¼•ç”¨æŒ‡å‘å¸¸é‡å¯¹è±¡ã€‚r1 = 31; //é”™è¯¯ã€‚å¸¸é‡å¼•ç”¨ä¸èƒ½èµ‹å€¼ã€‚int &amp;r2 = c;//é”™è¯¯ã€‚éžå¸¸é‡å¼•ç”¨ä¸èƒ½æŒ‡å‘å¸¸é‡å¯¹è±¡ã€‚int n=1;const int &amp;r3=n;//æ­£ç¡®ã€‚å¸¸é‡å¼•ç”¨æŒ‡å‘éžå¸¸é‡å¯¹è±¡ã€‚3.C++è§„å®šå¼•ç”¨çš„ç±»åž‹å¿…é¡»å’Œå¼•ç”¨å¯¹è±¡ä¸€è‡´ã€‚ä½†æ˜¯ä¸¤ç§ä¾‹å¤–ã€‚â‘ åˆå§‹åŒ–ã€å¸¸é‡å¼•ç”¨ã€‘æ—¶ï¼Œå…è®¸ç”¨ä»»ä½•è¡¨è¾¾å¼ä½œä¸ºåˆå§‹å€¼ã€‚â‘¡å…è®¸ã€å¸¸é‡å¼•ç”¨ã€‘ç»‘å®šã€éžå¸¸é‡ã€‘çš„å¯¹è±¡ã€å­—é¢å€¼ã€è¡¨è¾¾å¼ã€‚int i =42;const int &amp;r1 = i;//æ­£ç¡®ã€‚å¯¹è±¡const int &amp;r2 = 42;//æ­£ç¡®ã€‚å­—é¢å€¼const int &amp;r3 = r1 *2 ;//æ­£ç¡®ã€‚è¡¨è¾¾å¼int &amp;r4 = r1*2;//é”™è¯¯ã€‚éžæ³•ã€‚å¸¸é‡å¼•ç”¨ä¸å¯ä»¥è¢«ç»‘å®šåˆ°éžå¸¸é‡å¼•ç”¨ä¸Šã€‚å› ä¸ºå¸¸é‡å¼•ç”¨å¯¹è±¡çš„å€¼æ˜¯ä¸å¯ä»¥æ”¹å˜çš„ã€‚4.å½“ä¸€ä¸ªå¸¸é‡å¼•ç”¨è¢«ç»‘å®šåˆ°å¦ä¸€ä¸ªç±»åž‹ä¸Šå‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿdouble dval =3.14;const int &amp;r1 = dval;//r1çš„æ“ä½œæ˜¯æ•´åž‹è¿ç®—ã€‚è€Œdvalæ˜¯åŒç²¾åº¦ã€‚ä¸ºäº†è®©r1ç»‘å®šä¸€ä¸ªæ•´æ•°ï¼Œç¼–è¯‘å™¨ä¼šæŠŠdvalè½¬ä¸ºintçš„ä¸´æ—¶å˜é‡ï¼šconst int temp =dval;const int &amp;r1 =temp;5.constå’ŒæŒ‡é’ˆæ–¹æ³•æ˜¯ï¼šä»Žå³å¾€å·¦é˜…è¯»ã€‚â‘ C++å…è®¸ã€å¸¸é‡å¼•ç”¨ã€‘ç»‘å®šã€éžå¸¸é‡ã€‘double dval = 3.14;const double *p = &amp;dval;//æ­£ç¡®ã€‚pæ‰€æŒ‡å¯¹è±¡æ˜¯å¸¸é‡ã€‚ä¸èƒ½é€šè¿‡pæ”¹å˜pæŒ‡å‘å¯¹è±¡çš„å€¼ã€‚ï¼ˆæŒ‡å‘å¸¸é‡çš„æŒ‡é’ˆï¼š"è‡ªä»¥ä¸º"æŒ‡å‘äº†å¸¸é‡ï¼Œä¸ä¼šæ”¹å˜æ‰€æŒ‡å¯¹è±¡çš„å€¼ã€‚ï¼‰â‘¡constæŒ‡é’ˆint num = 0;int *const p = &amp;num;//pæ˜¯å¸¸é‡ã€‚ç±»åž‹æ˜¯æŒ‡é’ˆã€‚pä¸€ç›´æŒ‡å‘num storage_duration static é™æ€æˆ–çº¿ç¨‹å­˜å‚¨æœŸå’Œå†…éƒ¨é“¾æŽ¥ã€‚å†…å­˜ä¸­åªå­˜åœ¨ä¸€ä¸ªã€‚ extern é™æ€æˆ–çº¿ç¨‹å­˜å‚¨æœŸå’Œå†…éƒ¨é“¾æŽ¥ã€‚å¤–éƒ¨å˜é‡ï¼Œå¯ä»¥ä¾›æ‰€æœ‰æºæ–‡ä»¶ä½¿ç”¨ thread_local çº¿ç¨‹å­˜å‚¨æœŸã€‚ mutable ä¸å½±å“å­˜å‚¨æœŸæˆ–é“¾æŽ¥ã€‚ register (c++17å¼ƒç”¨) æ”¾åœ¨å¯„å­˜å™¨ä¸­ï¼Œè€Œéžå†…å­˜ä¸­ï¼Œ æ•ˆçŽ‡æ›´é«˜ï¼Œä¸€èˆ¬æ˜¯ä¸´æ—¶å˜é‡ auto (c++11å‰) é»˜è®¤éƒ½æ˜¯è‡ªåŠ¨å˜é‡ 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;mutex&gt; thread_local unsigned int rage = 1; std::mutex cout_mutex;//a synchronization primitive that can be used to protect shared data from being simultaneously accessed by multiple threads. void increase_rage(const std::string&amp; thread_name)&#123; ++rage; // åœ¨é”å¤–ä¿®æ”¹ OK ï¼›è¿™æ˜¯çº¿ç¨‹å±€åŸŸå˜é‡ std::lock_guard&lt;std::mutex&gt; lock(cout_mutex); std::cout &lt;&lt; "Rage counter for " &lt;&lt; thread_name &lt;&lt; ": " &lt;&lt; rage &lt;&lt; '\n';&#125; int main()&#123; std::thread a(increase_rage, "a"), b(increase_rage, "b"); &#123; std::lock_guard&lt;std::mutex&gt; lock(cout_mutex); std::cout &lt;&lt; "Rage counter for main: " &lt;&lt; rage &lt;&lt; '\n'; &#125; a.join(); b.join();&#125; output 123Rage counter for a: 2Rage counter for main: 1Rage counter for b: 2 pointerQ: 12345678910111213è‹¥æœ‰ä»¥ä¸‹è¯´æ˜Žå’Œå®šä¹‰ï¼Œåœ¨å¿…è¦çš„èµ‹å€¼ä¹‹åŽï¼Œå¯¹funå‡½æ•°çš„æ­£ç¡®è°ƒç”¨è¯­å¥æ˜¯ï¼ˆï¼‰ã€‚int fun (int *c) &#123; â€¦ &#125; void main() &#123; int (*a)(int*)=fun,"b ( ),w[10],c; â€¦ &#125; æ­£ç¡®ç­”æ¡ˆ: B ä½ çš„ç­”æ¡ˆ: D (é”™è¯¯)A. a=a(w)ï¼›B. (*a)(&amp;c)ï¼›C. b=*b(w);D. fun(b); A: 1234A: a(w)è°ƒç”¨æ­£ç¡®ï¼Œä½†å°†å…¶è¿”å›žå€¼èµ‹å€¼ç»™aæ˜¯é”™è¯¯çš„ï¼Œå› ä¸ºè¿”å›žå€¼æ˜¯æ•´åž‹æ•°ï¼Œè€Œaæ˜¯ä¸€å‡½æ•°æŒ‡é’ˆï¼Œæ‰€ä»¥ç­”æ¡ˆAæ˜¯é”™è¯¯çš„ã€‚B: å› ä¸ºaæŒ‡å‘äº†å‡½æ•°funï¼Œæ‰€ä»¥å®ƒç­‰ä»·äºŽfun(&amp;c)çš„è°ƒç”¨ï¼Œæ˜¯æ­£ç¡®çš„ã€‚C: å› bæ˜¯ä¸€ä¸ªè¿”å›žå€¼ä¸ºæ•´åž‹æ•°æŒ‡é’ˆçš„å‡½æ•°ï¼Œ*b(w)æœ¬èº«å°±æ˜¯é”™è¯¯çš„ã€‚D: båŽé¢çœæŽ‰äº†æ‹¬å·ï¼Œå› ä¸ºbæ˜¯å‡½æ•°ï¼Œæ•…ä¹Ÿæ˜¯é”™è¯¯çš„ã€‚ C++æ ‡å‡†åº“IOåº“Q: 12345678910111213141516ä¸‹é¢çš„ç¨‹åºæ‰§è¡ŒåŽï¼Œæ–‡ä»¶test.txtä¸­çš„å†…å®¹æ˜¯ï¼ˆï¼‰. #include &lt;stdio.h&gt; void fun (char *fname,char *st) &#123; FTLE *myf;int i; myf=fopen (fname,"w"); for (i=0;i&lt;strlen(st);i++) fputc (st[i],myf); fclose (myf); &#125; void main() &#123; fun("test.txt","new world")ï¼›fun("test.txt","hello,"); &#125; è¾“å‡ºï¼šhello, A: 1234567891011121314151617181920æ‰“å¼€æ–‡ä»¶é‡‡ç”¨çš„æ˜¯wæ–¹å¼ï¼Œè¯¥æ–¹æ³•è¡¨ç¤ºä¼š[å°†åŽŸæ–‡ä»¶æ¸…é™¤]ï¼Œç„¶åŽå†é‡æ–°å†™å…¥ã€‚fopenå­˜åœ¨ä¸‹é¢å‡ ç§æ¨¡å¼ï¼šr ä»¥åªè¯»æ–¹å¼æ‰“å¼€æ–‡ä»¶ï¼Œè¯¥æ–‡ä»¶å¿…é¡»å­˜åœ¨ã€‚r+ ä»¥è¯»/å†™æ–¹å¼æ‰“å¼€æ–‡ä»¶ï¼Œè¯¥æ–‡ä»¶å¿…é¡»å­˜åœ¨ã€‚rb+ ä»¥è¯»/å†™æ–¹å¼æ‰“å¼€ä¸€ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶ï¼Œåªå…è®¸è¯»/å†™æ•°æ®ã€‚rt+ ä»¥è¯»/å†™æ–¹å¼æ‰“å¼€ä¸€ä¸ªæ–‡æœ¬æ–‡ä»¶ï¼Œå…è®¸è¯»å’Œå†™ã€‚w æ‰“å¼€åªå†™æ–‡ä»¶ï¼Œè‹¥æ–‡ä»¶å­˜åœ¨åˆ™é•¿åº¦æ¸…ä¸º 0ï¼Œå³è¯¥æ–‡ä»¶å†…å®¹æ¶ˆå¤±ï¼Œè‹¥ä¸å­˜åœ¨åˆ™åˆ›å»ºè¯¥æ–‡ä»¶ã€‚w+ æ‰“å¼€å¯è¯»/å†™æ–‡ä»¶ï¼Œè‹¥æ–‡ä»¶å­˜åœ¨åˆ™æ–‡ä»¶é•¿åº¦æ¸…ä¸ºé›¶ï¼Œå³è¯¥æ–‡ä»¶å†…å®¹ä¼šæ¶ˆå¤±ã€‚è‹¥æ–‡ä»¶ä¸å­˜åœ¨åˆ™å»ºç«‹è¯¥æ–‡ä»¶ã€‚a ä»¥é™„åŠ çš„æ–¹å¼æ‰“å¼€åªå†™æ–‡ä»¶ã€‚è‹¥æ–‡ä»¶ä¸å­˜åœ¨ï¼Œåˆ™ä¼šå»ºç«‹è¯¥æ–‡ä»¶ï¼Œå¦‚æžœæ–‡ä»¶å­˜åœ¨ï¼Œå†™å…¥çš„æ•°æ®ä¼šè¢«åŠ åˆ°æ–‡ä»¶å°¾ï¼Œå³[æ–‡ä»¶åŽŸå…ˆçš„å†…å®¹ä¼šè¢«ä¿ç•™]ï¼ˆEOF ç¬¦ä¿ç•™ï¼‰ã€‚a+ ä»¥é™„åŠ æ–¹å¼æ‰“å¼€å¯è¯»/å†™çš„æ–‡ä»¶ã€‚è‹¥æ–‡ä»¶ä¸å­˜åœ¨ï¼Œåˆ™ä¼šå»ºç«‹è¯¥æ–‡ä»¶ï¼Œå¦‚æžœæ–‡ä»¶å­˜åœ¨ï¼Œåˆ™å†™å…¥çš„æ•°æ®ä¼šè¢«åŠ åˆ°æ–‡ä»¶å°¾åŽï¼Œå³æ–‡ä»¶åŽŸå…ˆçš„å†…å®¹ä¼šè¢«ä¿ç•™ï¼ˆåŽŸæ¥çš„ EOF ç¬¦ä¸ä¿ç•™ï¼‰ã€‚wb ä»¥åªå†™æ–¹å¼æ‰“å¼€æˆ–æ–°å»ºä¸€ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶ï¼Œåªå…è®¸å†™æ•°æ®ã€‚wb+ ä»¥è¯»/å†™æ–¹å¼æ‰“å¼€æˆ–å»ºç«‹ä¸€ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶ï¼Œå…è®¸è¯»å’Œå†™ã€‚wt+ ä»¥è¯»/å†™æ–¹å¼æ‰“å¼€æˆ–å»ºç«‹ä¸€ä¸ªæ–‡æœ¬æ–‡ä»¶ï¼Œå…è®¸è¯»å†™ã€‚at+ ä»¥è¯»/å†™æ–¹å¼æ‰“å¼€ä¸€ä¸ªæ–‡æœ¬æ–‡ä»¶ï¼Œå…è®¸è¯»æˆ–åœ¨æ–‡æœ¬æœ«è¿½åŠ æ•°æ®ã€‚ab+ ä»¥è¯»/å†™æ–¹å¼æ‰“å¼€ä¸€ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶ï¼Œå…è®¸è¯»æˆ–åœ¨æ–‡ä»¶æœ«è¿½åŠ æ•°æ®ã€‚ Q: 12345å·²çŸ¥ï¼šint xï¼Œyï¼›double zï¼›ä»¥ä¸‹è¯­å¥ä¸­é”™è¯¯çš„å‡½æ•°è°ƒç”¨æ˜¯ï¼ˆDï¼‰ã€‚ A.scanf(â€œ%d,%1x,%1e",&amp;x,&amp;y,&amp;z)ï¼›âˆšB.scanf(â€œ%2d*%d%1fâ€,&amp;x,&amp;y,&amp;z)ï¼›âˆšC.scanf(â€œ%x%*d%oâ€,&amp;x,&amp;y)ï¼›âˆšD.scanf(â€œ%x%o%6.2f",&amp;x,&amp;y,&amp;z)ï¼›Ã— A: 123Bï¼šåªèƒ½èŽ·å–xçš„å€¼ï¼Œyå’Œzéƒ½ä¸èƒ½æ­£å¸¸èŽ·å–ï¼Œä½†æ˜¯ä¸ä¼šæŠ¥é”™ã€‚Cï¼š*æ ¼å¼ï¼Œè¡¨ç¤ºè·³è¿‡æ­¤æ•°æ®ä¸è¯»å…¥ã€‚æ”¾åœ¨%ä¸Žæ ¼å¼dï¼ˆæˆ–è€…sï¼Œcç­‰ï¼‰ä¹‹é—´ã€‚ Dï¼šscanfä¸­çš„æ ¼å¼æŽ§åˆ¶ç¬¦ä¸èƒ½æŒ‡æ˜Žæµ®ç‚¹æ•°çš„ç²¾åº¦ï¼ŒDä¸­%6.2fæ˜¯é”™è¯¯çš„ã€‚ Q: 123456789101112131415#incude &lt;stdio.h&gt;main()ï½› FILE*fpï¼› int i,a[6]=&#123;1,2,3,4,5,6&#125;ï¼› fp=fopen("d2.dat","w+")ï¼› for(i=0ï¼›i&lt;6;i++) fprintf(fp,"%d\n",a [i])ï¼› rewind(fpï¼‰ï¼› for(i=0ï¼›i&lt;6;i++) fscanf( fp,"%d",&amp;a[5-i])ï¼› fclose(fpï¼‰ï¼› for(i=0ï¼›i&lt;6ï¼›i++) printf("%d,",a [i])ï¼›//6,5,4,3,2,1,&#125; A: 12345678910[è§£]fprintfæ˜¯C/C++ä¸­çš„ä¸€ä¸ªæ ¼å¼åŒ–å†™â€”åº“å‡½æ•°ï¼Œä½äºŽå¤´æ–‡ä»¶&lt;stdio.h&gt;ä¸­ï¼Œå…¶ä½œç”¨æ˜¯æ ¼å¼åŒ–è¾“å‡ºåˆ°ä¸€ä¸ªæµ/æ–‡ä»¶ä¸­for(i=0ï¼›i&lt;6;i++) fprintf(fp,"%d\n",a [i])ï¼› //è¿™å¥æ˜¯æŠŠa[i]ä¾æ¬¡å†™å…¥æ–‡ä»¶æµæŒ‡é’ˆfp å†…å®¹ä¸º1 2 3 4 5 6rewind(fpï¼‰//æŠŠæ–‡ä»¶æµæŒ‡é’ˆä»Žæ–°æŒ‡å‘æ–‡ä»¶çš„å¼€å¤´fscanf å…¶åŠŸèƒ½ä¸ºæ ¹æ®æ•°æ®æ ¼å¼(format)ä»Žè¾“å…¥æµ(stream)ä¸­å†™å…¥æ•°æ®(argument)for(i=0ï¼›i&lt;6;i++) fscanf( fp,"%d",&amp;a[5-i])ï¼›//æŠŠæ–‡ä»¶æµæŒ‡é’ˆfpä¾æ¬¡æŒ‡å‘çš„å†…å®¹å†™å…¥åˆ°a[5-i],a[5]=1,a[4]=2,a[3]=3,a[2]=4,a[1]=5,a[0]=6; Q: 1ä»ŽæŽ§åˆ¶å°è¾“å…¥ä»¥","åˆ†éš”çš„å­—ç¬¦ä¸²ï¼Œè¦æ±‚æŠŠå­—ç¬¦ä¸²å­˜å…¥æ•°ç»„ä¸­ã€‚ A: 123456789101112131415161718192021222324252627282930313233343536373839404142434445[è§£]#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;vector&gt;#include &lt;array&gt; int main()&#123; string str; getline(cin, str); istringstream input(str); vector&lt;array&lt;char, 100&gt;&gt; v; // æ³¨æ„ï¼šä¸‹åˆ—å¾ªçŽ¯åœ¨ä»Ž getline() è¿”å›žçš„æµä¸Šçš„ // std::ios_base::operator bool() è¿”å›ž false æ—¶ç»ˆæ­¢ for (array&lt;char, 100&gt;a; input.getline(&amp;a[0], 100, 'ï¼Œ'); ) &#123; v.push_back(a); &#125; for (auto&amp; a : v) &#123; std::cout &lt;&lt; &amp;a[0] &lt;&lt; '\n'; &#125; return 0;&#125;[æ‰©å±•]basic_istream&amp; getline( char_type* s, std::streamsize count, char_type delim );//ä»Žæµé‡Šå‡ºå­—ç¬¦åˆ°æ•°ç»„ï¼Œé‡åˆ°è¡Œå°¾ã€æŒ‡å®šçš„åˆ†éš”ç¬¦ delimã€è¶…è¿‡æ•°ç»„å®¹é‡æ—¶åœæ­¢ã€‚int main()&#123; string str; getline(cin, str); std::istringstream input(str); std::vector&lt;int&gt; v; char a[100]; while(input.getline(&amp;a[0], 100, ',')) v.push_back(atoi(a)); for (auto a : v) &#123; std::cout &lt;&lt;a &lt;&lt; '\n'; &#125; return 0;&#125; ç±»è®¾è®¡è€…çš„å·¥å…·ç±»unionQ: 12345678910è‹¥æœ‰ä»¥ä¸‹è¯´æ˜Žå’Œå®šä¹‰union dt&#123;int a; char b; double c;&#125;data;ä»¥ä¸‹å™è¿°ä¸­é”™è¯¯çš„æ˜¯ ( C ) ã€‚ A.dataçš„æ¯ä¸ªæˆå‘˜èµ·å§‹åœ°å€éƒ½ç›¸åŒã€‚âˆšB.å˜é‡dataæ‰€å å†…å­˜å­—èŠ‚æ•°ä¸Žæˆå‘˜cæ‰€å å­—èŠ‚æ•°ç›¸ç­‰ã€‚âˆšC.ç¨‹åºæ®µï¼šdata.a=5;printf("%f\n",data.c);è¾“å‡ºç»“æžœä¸º5.000000ã€‚Ã—D.dataå¯ä»¥ä½œä¸ºå‡½æ•°çš„å®žå‚ã€‚âˆš A: 1234567printfå‡½æ•°åªæ˜¯å°†å†…å­˜ä¸­çš„æ•°æ®ä»¥ä¸åŒçš„ç±»åž‹è¾“å‡ºï¼Œè€Œä¸èƒ½å°†å†…å­˜ä¸­çš„æ•´åž‹æ•°æ®è‡ªåŠ¨è½¬æ¢ä¸ºç­‰å€¼çš„æµ®ç‚¹æ•°ï¼Œæ•…Cæ˜¯é”™è¯¯çš„ã€‚åœ¨å†…å­˜ä¸­ï¼Œå®žæ•°ä¸Žæ•´æ•°çš„å­˜æ”¾å½¢å¼å®Œå…¨ä¸ä¸€æ ·ï¼Œå…±ç”¨ä½“çš„æˆå‘˜å…±ç”¨çš„æ˜¯åŒä¸€å—å†…å­˜ï¼Œè€Œä¸æ˜¯åŒä¸€ä¸ªæ•°å€¼ï¼Œå› æ­¤é€‰é¡¹Cæ˜¯é”™è¯¯çš„ã€‚æµ®ç‚¹æ•°å­˜å‚¨æ ¼å¼ä¸ºIEEE754æ ‡å‡†ï¼Œä»¥32ä½float(4å­—èŠ‚)ä¸ºä¾‹ï¼Œfloat i = 21.375ï¼›iåœ¨è®¡ç®—æœºå­˜å‚¨åˆ†ä¸ºä¸‰ä¸ªéƒ¨åˆ†ï¼Œ- ç¬¦å·ä½S- é˜¶ç E,é˜¶ç Eç”¨åç§»å€¼è¡¨ç¤º- å°¾ç M,å°¾ç Mç”¨åŽŸç è¡¨ç¤º 12345Sä¸ºç¬¦å·ä½ï¼Œ1ä»£è¡¨è´Ÿæ•°ï¼Œ0ä»£è¡¨æ•´æ•°ï¼ŒEä»£è¡¨åç§»127çš„å¹‚ï¼ŒMä»£è¡¨å°¾æ•°ã€‚ç”±äºŽi&lt;0,æ‰€ä»¥S = 1,å¯¹äºŽE ,i çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸º10101.011ï¼Œç„¶åŽäºŒè¿›åˆ¶å³ç§»4ä½ï¼Œè®©æœ€å·¦è¾¹ä¿ç•™ä¸€ä½1ï¼Œå³10101.011 = 1.0101011*2^4,é‚£ä¹ˆE = 127+4 = 131=10000011,å¯¹äºŽMï¼Œå°±æ˜¯å°æ•°ç‚¹åŽçš„çš„æ•°0101011ï¼Œç”±äºŽè¦ä¿è¯ä½23ä½ï¼Œæ‰€ä»¥åœ¨æœ«å°¾è¡¥0ï¼Œå³M=0101011000000000000000æ‰€ä»¥içš„å­˜å‚¨ä¸ºS+ E+M= 1-10000011-01010110000000000000000. classQ:ä¸‹é¢ç¨‹åºçš„è¾“å‡ºæ˜¯ä»€ä¹ˆï¼Ÿ 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;class parent&#123; int i;//æœªå£°æ˜Žè®¿é—®æƒé™åˆ™é»˜è®¤private,å®ƒå’Œç»“æž„ä½“çš„å”¯ä¸€åŒºåˆ«protected: int x;//å­ç±»å¯ä»¥è®¿é—®x,ä¸èƒ½è®¿é—®ipublic: parent() &#123; x = 0; i = 0; &#125; void change() &#123; x++; i++; &#125; void display();&#125;;class son :public parent&#123;public: void modify();&#125;;void parent::display() &#123; cout &lt;&lt; "x=" &lt;&lt; x &lt;&lt; endl; &#125;void son::modify() &#123; x++; &#125;int main()&#123; son A; //A.x=0 ; A.i=0 parent B;//B.x=0;B.i=0 A.display();//x=0 A.change();//æ‰§è¡Œparent::change().A.x=1; A.i=1 A.modify();//æ‰§è¡Œson::modify().A.x=2; A.i=1 A.display();//x=2 B.change();//æ‰§è¡Œparent::change().B.x=1; B.i=1 B.display();//x=1 &#125; A: 1234567è¾“å‡ºï¼šx=0 x=2 x=1- å­ç±»ä¼šç»§æ‰¿çˆ¶ç±»é™¤æž„é€ å‡½æ•°å’Œæžæž„å‡½æ•°ä¹‹å¤–[æ‰€æœ‰çš„æ•°æ®æˆå‘˜å’Œæˆå‘˜å‡½æ•°]ã€‚è™½ç„¶sonä¸èƒ½ç»§æ‰¿parentçš„æž„é€ å‡½æ•°,ä½†åˆå§‹åŒ–Aæ—¶å¼ºåˆ¶è°ƒç”¨äº†parentçš„æž„é€ å‡½æ•°ã€‚- å®žä¾‹åŒ–åŽï¼Œ[å­ç±»å’Œçˆ¶ç±»çš„å¯¹è±¡äº’ä¸å½±å“]ã€‚- ç±»çš„æˆå‘˜å˜é‡[æœªå£°æ˜Žè®¿é—®æƒé™åˆ™é»˜è®¤private]ï¼Œè¿™æ˜¯å®ƒå’Œç»“æž„ä½“çš„å”¯ä¸€åŒºåˆ«ã€‚- åŸºç±»çš„privateæˆå‘˜ä¸èƒ½è¢«å­ç±»è®¿é—®ï¼Œä½†å…¶protectedæˆå‘˜å¯ä»¥è¢«å­ç±»è®¿é—®ï¼Œä¸¤è€…å‡ä¸å¯åœ¨ç±»å¤–è®¿é—®ï¼Œæ•…æ–‡ä¸­å­ç±»å¯ä»¥è®¿é—®x,ä¸èƒ½è®¿é—®i static membersQ: 12345å…³äºŽç±»çš„é™æ€æˆå‘˜çš„æè¿°ï¼šA. é™æ€æˆå‘˜ä¸å±žäºŽå¯¹è±¡ï¼Œæ˜¯ç±»çš„å…±äº«æˆå‘˜ã€‚âˆšB. non-const staticæ•°æ®æˆå‘˜è¦åœ¨ç±»å¤–å®šä¹‰å’Œåˆå§‹åŒ–,const staticçš„æ•°æ®æˆå‘˜å¿…é¡»åœ¨ç±»é‡Œåˆå§‹åŒ–ã€‚âˆšC. é™æ€æˆå‘˜å‡½æ•°ä¸æ‹¥æœ‰thisæŒ‡é’ˆï¼Œéœ€è¦é€šè¿‡ç±»å‚æ•°è®¿é—®å¯¹è±¡æˆå‘˜ã€‚âˆšD. åªæœ‰é™æ€æˆå‘˜å‡½æ•°å¯ä»¥æ“ä½œé™æ€æ•°æ®æˆå‘˜ã€‚Ã— A: é‡è½½æ™®é€šå‡½æ•°çš„é‡è½½Q1: 12345ä¸‹åˆ—å¯¹é‡è½½å‡½æ•°çš„æè¿°ä¸­ï¼Œ_____A_______æ˜¯é”™è¯¯çš„ã€‚A.é‡è½½å‡½æ•°ä¸­ä¸å…è®¸ä½¿ç”¨é»˜è®¤å‚æ•°.B.é‡è½½å‡½æ•°ä¸­ç¼–è¯‘æ—¶æ ¹æ®å‚æ•°è¡¨è¿›è¡Œé€‰æ‹©C.æž„é€ å‡½æ•°é‡è½½å°†ä¼šç»™åˆå§‹åŒ–å¸¦æ¥å¤šç§æ–¹å¼D.ä¸è¦ä½¿ç”¨é‡è½½å‡½æ•°æ¥æè¿°æ¯«æ— ç›¸å¹²çš„å‡½æ•° A1: 12345ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œåœ¨å‡½æ•°è°ƒç”¨æ—¶å½¢å‚ä»Žå®žå‚é‚£é‡Œå–å¾—å€¼ï¼Œå› æ­¤å®žå‚çš„ä¸ªæ•°åº”äºŽå½¢å‚ç›¸åŒã€‚æœ‰æ—¶å¤šæ¬¡è°ƒç”¨åŒæ ·çš„å®žå‚ï¼Œc++æä¾›ç®€å•çš„å¤„ç†åŠžæ³•ï¼Œç»™å®žå‚ä¸€ä¸ªé»˜è®¤å€¼ï¼Œè¿™æ ·å½¢å‚å°±ä¸å¿…ä»Žå®žå‚å–å€¼äº†ã€‚å¦‚æœ‰ä¸€å‡½æ•°ç”³æ˜Žfloat area (float r=6.5)ï¼›æŒ‡å®šrçš„é»˜è®¤å€¼ä¸º6.5ã€‚å¦‚æžœåœ¨è°ƒç”¨æ­¤å‡½æ•°æ—¶ï¼Œç¡®è®¤rçš„å€¼ä¸º6.5ï¼Œåˆ™å¯ä»¥ä¸å¿…ç»™å‡ºå®žå‚çš„å€¼ï¼Œå¦‚ï¼š area( )ï¼› //ç›¸å½“äºŽareaï¼ˆ6.5ï¼‰ï¼›å¦‚æžœä¸æƒ³ä½¿å½¢å‚å–é»˜è®¤å€¼ï¼Œåˆ™é€šè¿‡å®žå‚å¦è¡Œç»™å‡ºã€‚å¦‚ï¼šarea(7.5)ã€‚ Q2: 123456ä»¥ä¸‹ä¸æ˜¯double compare(int,int)çš„é‡è½½å‡½æ•°çš„æ˜¯()æ­£ç¡®ç­”æ¡ˆ: D ä½ çš„ç­”æ¡ˆ: D (æ­£ç¡®)int compare(double,double)double compare(double,double)double compare(double,int)int compare(int,int) A2: 1234567891011121314é‡è½½å‡½æ•°ä¸Žç±»åž‹æ— å…³ï¼Œæ‰€ä»¥ä¸çœ‹ç±»åž‹ã€‚- æˆå‘˜å‡½æ•°è¢«é‡è½½çš„ç‰¹å¾ï¼š 1. ç›¸åŒçš„èŒƒå›´ï¼ˆåœ¨åŒä¸€ä¸ªç±»ä¸­ï¼‰ï¼› 2. å‡½æ•°åå­—ç›¸åŒï¼› 3. å‚æ•°ä¸åŒï¼› 4. virtual å…³é”®å­—å¯æœ‰å¯æ— ã€‚- è¦†ç›–æ˜¯æŒ‡æ´¾ç”Ÿç±»å‡½æ•°è¦†ç›–åŸºç±»å‡½æ•°ï¼Œç‰¹å¾æ˜¯ï¼š 1. ä¸åŒçš„èŒƒå›´ï¼ˆåˆ†åˆ«ä½äºŽæ´¾ç”Ÿç±»ä¸ŽåŸºç±»ï¼‰ï¼› 2. å‡½æ•°åå­—ç›¸åŒï¼› 3. å‚æ•°ç›¸åŒï¼› 4. åŸºç±»å‡½æ•°å¿…é¡»æœ‰ virtual å…³é”®å­—ã€‚- éšè—æ˜¯æŒ‡æ´¾ç”Ÿç±»çš„å‡½æ•°å±è”½äº†ä¸Žå…¶åŒåçš„åŸºç±»å‡½æ•°ï¼Œè§„åˆ™å¦‚ä¸‹ï¼š 1. å¦‚æžœæ´¾ç”Ÿç±»çš„å‡½æ•°ä¸ŽåŸºç±»çš„å‡½æ•°åŒåï¼Œä½†æ˜¯å‚æ•°ä¸åŒã€‚æ­¤æ—¶ï¼Œä¸è®ºæœ‰æ—  virtual å…³é”®å­—ï¼ŒåŸºç±»çš„å‡½æ•°å°†è¢«éšè—ï¼ˆæ³¨æ„åˆ«ä¸Žé‡è½½æ··æ·†ï¼‰ã€‚ 2. å¦‚æžœæ´¾ç”Ÿç±»çš„å‡½æ•°ä¸ŽåŸºç±»çš„å‡½æ•°åŒåï¼Œå¹¶ä¸”å‚æ•°ä¹Ÿç›¸åŒï¼Œä½†æ˜¯åŸºç±»å‡½æ•°æ²¡æœ‰ virtual å…³é”®å­—ã€‚æ­¤æ—¶ï¼ŒåŸºç±»çš„å‡½æ•°è¢«éšè—ï¼ˆæ³¨æ„åˆ«ä¸Žè¦†ç›–æ··æ·†ï¼‰ã€‚ è¿ç®—ç¬¦é‡è½½Q: 123456æœ‰å…³è¿ç®—ç¬¦é‡è½½æ­£ç¡®çš„æè¿°æ˜¯ï¼ˆDï¼‰æ­£ç¡®ç­”æ¡ˆ: D ä½ çš„ç­”æ¡ˆ: A (é”™è¯¯)c++è¯­è¨€å…è®¸åœ¨é‡è½½è¿ç®—ç¬¦æ—¶æ”¹å˜è¿ç®—ç¬¦çš„æ“ä½œä¸ªæ•°c++è¯­è¨€å…è®¸åœ¨é‡è½½è¿ç®—ç¬¦æ—¶æ”¹å˜è¿ç®—ç¬¦çš„ä¼˜å…ˆçº§c++è¯­è¨€å…è®¸åœ¨é‡è½½è¿ç®—ç¬¦æ—¶æ”¹å˜è¿ç®—ç¬¦çš„ç»“åˆæ€§c++è¯­è¨€å…è®¸åœ¨é‡è½½è¿ç®—ç¬¦æ—¶æ”¹å˜è¿ç®—ç¬¦åŽŸæ¥çš„åŠŸèƒ½ A: 12c ++è¯­è¨€å…è®¸åœ¨é‡è½½è¿ç®—ç¬¦æ—¶æ”¹å˜è¿ç®—ç¬¦åŽŸæ¥çš„åŠŸèƒ½ã€‚ä¾‹å¦‚å°†â€œ + + "ç¬¦å·é‡è½½æ—¶ï¼Œå¯ä»¥å®šä¹‰ä¸ºâ€œ--"çš„åŠŸèƒ½ã€‚ä½†æ˜¯ï¼Œä¸æå€¡è¿™æ ·åšï¼Œé‡è½½è¿ç®—ç¬¦æœ€å¥½ä»ä¿æŒåŽŸæœ‰çš„åŠŸèƒ½ã€‚ä¸Žæ™®é€šå‡½æ•°çš„é‡è½½è§„åˆ™ä¸åŒï¼Œè¿™é‡Œçš„å¯¹è±¡æ˜¯è¿ç®—ç¬¦ï¼ˆè¿ç®—ç¬¦é‡è½½æ˜¯ç‰¹æ®Šçš„å‡½æ•°é‡è½½ï¼‰ï¼Œè¿ç®—ç¬¦é‡è½½æœ‰è‡ªå·±çš„è§„åˆ™ï¼Œä¸è¦æ··ä¸ºä¸€è°ˆã€‚ åŠ¨æ€ç»‘å®šçº¯è™šå‡½æ•°Q1: 123456å…³äºŽçº¯è™šå‡½æ•°ï¼Œä¸‹åˆ—è¡¨è¿°æ­£ç¡®çš„æ˜¯ï¼Ÿï¼ˆ B ï¼‰æ­£ç¡®ç­”æ¡ˆ: B ä½ çš„ç­”æ¡ˆ: C (é”™è¯¯)A.æ´¾ç”Ÿç±»å¿…é¡»å®žçŽ°åŸºç±»çš„çº¯è™šå‡½æ•°B.çº¯è™šå‡½æ•°çš„å£°æ˜Žæ€»æ˜¯ä»¥â€œ=0â€ç»“æŸC.çº¯è™šå‡½æ•°æ˜¯ç»™å‡ºå®žçŽ°ç‰ˆæœ¬ï¼ˆå³æ— å‡½æ•°ä½“å®šä¹‰ï¼‰çš„è™šå‡½æ•°D.å«æœ‰çº¯è™šå‡½æ•°çš„ç±»ä¸€å®šæ˜¯æ´¾ç”Ÿç±» A1: 123A.å«æœ‰çº¯è™šå‡½æ•°çš„ç±»æ˜¯æŠ½è±¡ç±»ï¼Œå¯¹äºŽç»§æ‰¿æŠ½è±¡ç±»çš„æ´¾ç”Ÿç±»æ¥è¯´ï¼Œå¦‚æžœ[æ´¾ç”Ÿç±»å®žçŽ°äº†åŸºç±»çš„çº¯è™šå‡½æ•°ï¼Œåˆ™æ´¾ç”Ÿç±»å¯ä»¥å®žä¾‹åŒ–]ã€‚è‹¥æ´¾ç”Ÿç±»æ²¡æœ‰å®žçŽ°è¯¥çº¯è™šå‡½æ•°ï¼Œåˆ™è¯¥[æ´¾ç”Ÿç±»ä¹Ÿæ˜¯æŠ½è±¡ç±»]ï¼Œå³ä¸èƒ½å®žä¾‹åŒ–ã€‚C.çº¯è™šå‡½æ•°æ˜¯éœ€è¦åœ¨è¯¥ç±»ä¸‹ä¸å®žçŽ°è€Œ[åœ¨æ´¾ç”Ÿç±»ä¸­å®žçŽ°]çš„å‡½æ•°ã€‚D.å«æœ‰çº¯è™šå‡½æ•°çš„ç±»ä¸€å®šæ˜¯[åŸºç±»]ï¼Œéœ€è¦[æ´¾ç”Ÿç±»]æ¥[å®žçŽ°å…¶è™šå‡½æ•°çš„åŠŸèƒ½]ã€‚ Q2: 1234å¦‚æžœä¸ä½¿ç”¨å¤šæ€æœºåˆ¶ï¼Œé‚£ä¹ˆé€šè¿‡åŸºç±»çš„æŒ‡é’ˆè™½ç„¶å¯ä»¥æŒ‡å‘æ´¾ç”Ÿç±»å¯¹è±¡ï¼Œä½†æ˜¯åªèƒ½è®¿é—®ä»ŽåŸºç±»ç»§æ‰¿çš„æˆå‘˜ã€‚æ­£ç¡®ç­”æ¡ˆ: A ä½ çš„ç­”æ¡ˆ: A (æ­£ç¡®)A.æ˜¯B.å¦ A2: 1è‹¥ä¸ä½¿ç”¨å¤šæ€æœºåˆ¶ï¼Œåˆ™åŠ¨æ€ç»‘å®šä¸å­˜åœ¨ã€‚å³åŸºç±»ä¸Žæ´¾ç”Ÿç±»è™šå‡½æ•°æ— æ³•æ ¹æ®æŒ‡é’ˆæŒ‡å‘çš„å¯¹è±¡åŠ¨æ€é€‰æ‹©ã€‚ è™šå‡½æ•°å°±æ— æ³•ä½¿ç”¨ã€‚ é¢å‘å¯¹è±¡Q: 12345åœ¨C++é¢å‘å¯¹è±¡ç¼–ç¨‹è¯­è¨€ä¸­ï¼Œä»¥ä¸‹é˜è¿° A.æŽ¥å£ä¸­å¯ä»¥ç”¨è™šæ–¹æ³•ã€‚Ã—B.ä¸€ä¸ªç±»å¯ä»¥å®žçŽ°å¤šä¸ªæŽ¥å£ã€‚âˆšC.æŽ¥å£ä¸èƒ½è¢«å®žä¾‹åŒ–ã€‚âˆšD.æŽ¥å£ä¸­å¯ä»¥åŒ…å«å·²ç»å®žçŽ°çš„æ–¹æ³•ã€‚Ã— A: 123æŽ¥å£æ˜¯æŒ‡[åªåŒ…å«çº¯è™šå‡½æ•°]çš„[æŠ½è±¡ç±»]ã€‚A:æŽ¥å£å’Œæ™®é€šçš„æŠ½è±¡ç±»ä¸ä¸€æ ·ã€‚æ‰€ä»¥Aä¸å¯¹ï¼Œå¿…é¡»æ˜¯çº¯è™šå‡½æ•°ã€‚D:æŽ¥å£å³åªåŒ…å«çº¯è™šå‡½æ•°çš„æŠ½è±¡ç±»ï¼Œæ‰€ä»¥Dæ˜¯ä¸å¯¹çš„ã€‚]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[åˆ·é¢˜ç¬”è®° æ“ä½œç³»ç»Ÿ]]></title>
    <url>%2F2019%2F03%2F13%2F%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[å†…å­˜ç®¡ç†Q1. 164ä½ç³»ç»Ÿå’Œ32ä½ç³»ç»Ÿçš„åŒºåˆ« A1. 1238ä½çš„cpuï¼Œä¸€æ¬¡å¤„ç†ä¸€ä¸ª8ä½çš„æ•°æ®ï¼Œæ¯”å¦‚'10001000'ï¼Œå¦‚æžœ'+1'è¿™ä¸ªè¿ç®—ï¼Œcpuè¦å…ˆåš'+'ï¼Œå†åš'1'ä¼ ç»™cpu16ä½çš„cpuï¼Œä¸€æ¬¡å¤„ç†2ä¸ªå­—èŠ‚(16ä½)32ä½çš„cpuï¼Œä¸€æ¬¡å¤„ç†4ä¸ªå­—èŠ‚ type 32bit - byte count 64bit - byte count range bool 1 ture,false char 1 -128~127(-2^7~2^7-1) unsigned char 1 0~255(0~2^8-1) short 2 -32768~32767(-2^15~2^15-1) unsigned short 2 0~65535(2^16-1) int 4 (-2^31~2^31-1) unsigned int 4 (0~2^32-1) long 4 8 unsigned long 4 8 long long 8 -2^64~2^64-1 float 4 -2^128~2^128ï¼Œç²¾åº¦ä¸º6~7ä½æœ‰æ•ˆæ•°å­— double 8 -2^1024~2^1024ï¼Œç²¾åº¦ä¸º15~16ä½ long double 8 -2^1024~2^1024ï¼Œç²¾åº¦ä¸º15~16ä½ * 4 8 é™¤äº†longå’ŒæŒ‡é’ˆæœ‰åŒºåˆ«ä¹‹å¤–ï¼Œå…¶å®ƒä¸å˜ã€‚ è¿›ç¨‹çº¿ç¨‹Q: 12345ä¸‹é¢å“ªäº›æ–¹å¼å¯ä»¥ç”¨äºŽçº¿ç¨‹ä¹‹é—´çš„åŒæ­¥ï¼Ÿ ä¸´ç•ŒåŒºã€‚âˆšäº’æ–¥åŒºã€‚âˆšäº‹ä»¶ã€‚âˆšä¿¡å·é‡ã€‚âˆš A: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647è¿›ç¨‹ä¸­çº¿ç¨‹åŒæ­¥çš„å››ç§å¸¸ç”¨æ–¹å¼ï¼š- ä¸´ç•ŒåŒºï¼ˆCCriticalSectionï¼‰ å½“å¤šä¸ªçº¿ç¨‹è®¿é—®ä¸€ä¸ªç‹¬å æ€§å…±äº«èµ„æºæ—¶ï¼Œå¯ä»¥ä½¿ç”¨ä¸´ç•ŒåŒºå¯¹è±¡ã€‚[æ‹¥æœ‰ä¸´ç•ŒåŒºçš„çº¿ç¨‹]å¯ä»¥è®¿é—®è¢«ä¿æŠ¤èµ·æ¥çš„èµ„æºæˆ–ä»£ç æ®µï¼Œå…¶ä»–çº¿ç¨‹è‹¥æƒ³è®¿é—®ï¼Œåˆ™è¢«æŒ‚èµ·ï¼Œç›´åˆ°æ‹¥æœ‰ä¸´ç•ŒåŒºçš„çº¿ç¨‹æ”¾å¼ƒä¸´ç•ŒåŒºä¸ºæ­¢ã€‚å…·ä½“åº”ç”¨æ–¹å¼ï¼š 1. å®šä¹‰ä¸´ç•ŒåŒºå¯¹è±¡CcriticalSection g_CriticalSection; 2. åœ¨è®¿é—®å…±äº«èµ„æºï¼ˆä»£ç æˆ–å˜é‡ï¼‰ä¹‹å‰ï¼Œå…ˆèŽ·å¾—ä¸´ç•ŒåŒºå¯¹è±¡ï¼Œg_CriticalSection.Lockï¼ˆï¼‰ï¼› 3. è®¿é—®å…±äº«èµ„æºåŽï¼Œåˆ™æ”¾å¼ƒä¸´ç•ŒåŒºå¯¹è±¡ï¼Œg_CriticalSection.Unlockï¼ˆï¼‰ï¼› - äº‹ä»¶ï¼ˆCEventï¼‰ äº‹ä»¶æœºåˆ¶ï¼Œåˆ™å…è®¸ä¸€ä¸ªçº¿ç¨‹åœ¨å¤„ç†å®Œä¸€ä¸ªä»»åŠ¡åŽï¼Œä¸»åŠ¨å”¤é†’å¦å¤–ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œä»»åŠ¡ã€‚æ¯”å¦‚åœ¨æŸäº›ç½‘ç»œåº”ç”¨ç¨‹åºä¸­ï¼Œä¸€ä¸ªçº¿ç¨‹å¦‚Aè´Ÿè´£ä¾¦å¬é€šä¿¡ç«¯å£ï¼Œå¦å¤–ä¸€ä¸ªçº¿ç¨‹Bè´Ÿè´£æ›´æ–°ç”¨æˆ·æ•°æ®ï¼Œåˆ©ç”¨äº‹ä»¶æœºåˆ¶ï¼Œåˆ™çº¿ç¨‹Aå¯ä»¥é€šçŸ¥çº¿ç¨‹Bä½•æ—¶æ›´æ–°ç”¨æˆ·æ•°æ®ã€‚ æ¯ä¸ªCeventå¯¹è±¡å¯ä»¥æœ‰ä¸¤ç§çŠ¶æ€ï¼šæœ‰ä¿¡å·çŠ¶æ€å’Œæ— ä¿¡å·çŠ¶æ€ã€‚ Ceventç±»å¯¹è±¡æœ‰ä¸¤ç§ç±»åž‹ï¼šäººå·¥äº‹ä»¶å’Œè‡ªåŠ¨äº‹ä»¶ã€‚ è‡ªåŠ¨äº‹ä»¶å¯¹è±¡ï¼Œåœ¨è¢«è‡³å°‘ä¸€ä¸ªçº¿ç¨‹é‡Šæ”¾åŽè‡ªåŠ¨è¿”å›žåˆ°æ— ä¿¡å·çŠ¶æ€ï¼› äººå·¥äº‹ä»¶å¯¹è±¡ï¼ŒèŽ·å¾—ä¿¡å·åŽï¼Œé‡Šæ”¾å¯åˆ©ç”¨çº¿ç¨‹ï¼Œä½†ç›´åˆ°è°ƒç”¨æˆå‘˜å‡½æ•°ReSet()æ‰å°†å…¶è®¾ç½®ä¸ºæ— ä¿¡å·çŠ¶æ€ã€‚ åœ¨åˆ›å»ºCeventå¯¹è±¡æ—¶ï¼Œé»˜è®¤åˆ›å»ºçš„æ˜¯è‡ªåŠ¨äº‹ä»¶ã€‚ 1. 1234CEvent( BOOL bInitiallyOwn=FALSE, //æŒ‡å®šäº‹ä»¶å¯¹è±¡åˆå§‹åŒ–çŠ¶æ€ï¼ŒTRUEä¸ºæœ‰ä¿¡å·ï¼ŒFALSEä¸ºæ— ä¿¡å·ï¼› BOOL bManualReset=FALSE, //æŒ‡å®šè¦åˆ›å»ºçš„äº‹ä»¶æ˜¯å±žäºŽäººå·¥äº‹ä»¶è¿˜æ˜¯è‡ªåŠ¨äº‹ä»¶ã€‚TRUEä¸ºäººå·¥äº‹ä»¶ï¼ŒFALSEä¸ºè‡ªåŠ¨äº‹ä»¶ï¼› LPCTSTR lpszName=NULL, LPSECURITY_ATTRIBUTES lpsaAttribute=NULL); 2. BOOL CEventï¼šï¼šSetEvent(); å°†Ceventç±»å¯¹è±¡çš„çŠ¶æ€è®¾ç½®ä¸ºæœ‰ä¿¡å·çŠ¶æ€ã€‚ å¦‚æžœäº‹ä»¶æ˜¯äººå·¥äº‹ä»¶ï¼Œåˆ™Ceventç±»å¯¹è±¡ä¿æŒä¸ºæœ‰ä¿¡å·çŠ¶æ€ï¼Œç›´åˆ°è°ƒç”¨æˆå‘˜å‡½æ•°ResetEvent()å°†å…¶é‡æ–°è®¾ä¸ºæ— ä¿¡å·çŠ¶æ€æ—¶ä¸ºæ­¢ã€‚ å¦‚æžœä¸ºè‡ªåŠ¨äº‹ä»¶ï¼Œåˆ™åœ¨SetEventï¼ˆï¼‰åŽå°†äº‹ä»¶è®¾ç½®ä¸ºæœ‰ä¿¡å·çŠ¶æ€ï¼Œç”±ç³»ç»Ÿè‡ªåŠ¨é‡ç½®ä¸ºæ— ä¿¡å·çŠ¶æ€ã€‚ 3. BOOL CEventï¼šï¼šResetEvent(); å°†äº‹ä»¶çš„çŠ¶æ€è®¾ç½®ä¸ºæ— ä¿¡å·çŠ¶æ€ï¼Œå¹¶ä¿æŒè¯¥çŠ¶æ€ç›´è‡³SetEventï¼ˆï¼‰è¢«è°ƒç”¨ä¸ºæ­¢ã€‚ ç”±äºŽè‡ªåŠ¨äº‹ä»¶æ˜¯ç”±ç³»ç»Ÿè‡ªåŠ¨é‡ç½®ï¼Œæ•…è‡ªåŠ¨äº‹ä»¶ä¸éœ€è¦è°ƒç”¨è¯¥å‡½æ•°ã€‚ 4. ä¸€èˆ¬é€šè¿‡è°ƒç”¨WaitForSingleObjectï¼ˆï¼‰å‡½æ•°æ¥ç›‘è§†äº‹ä»¶çŠ¶æ€ã€‚ - äº’æ–¥é‡ï¼ˆCMutexï¼‰ äº’æ–¥å¯¹è±¡å’Œä¸´ç•ŒåŒºå¯¹è±¡éžå¸¸ç›¸ä¼¼ï¼Œåªæ˜¯å…¶[å…è®¸åœ¨è¿›ç¨‹é—´]ä½¿ç”¨ï¼Œè€Œä¸´ç•ŒåŒº[åªé™åˆ¶ä¸ŽåŒä¸€è¿›ç¨‹çš„å„ä¸ªçº¿ç¨‹]ä¹‹é—´ä½¿ç”¨ï¼Œä½†æ˜¯æ›´èŠ‚çœèµ„æºï¼Œæ›´æœ‰æ•ˆçŽ‡ã€‚ - ä¿¡å·é‡ï¼ˆCSemphoreï¼‰ å½“éœ€è¦ä¸€ä¸ªè®¡æ•°å™¨æ¥[é™åˆ¶å¯ä»¥ä½¿ç”¨æŸå…±äº«èµ„æºçš„çº¿ç¨‹æ•°ç›®]æ—¶ï¼Œå¯ä»¥ä½¿ç”¨â€œä¿¡å·é‡â€å¯¹è±¡ã€‚ CSemaphoreç±»å¯¹è±¡ä¿å­˜äº†å¯¹å½“å‰è®¿é—®æŸä¸€ä¸ªæŒ‡å®šèµ„æºçš„çº¿ç¨‹çš„è®¡æ•°å€¼ï¼Œè¯¥è®¡æ•°å€¼æ˜¯[å½“å‰è¿˜å¯ä»¥ä½¿ç”¨è¯¥èµ„æºçš„çº¿ç¨‹æ•°ç›®]ã€‚ å¦‚æžœè¿™ä¸ªè®¡æ•°è¾¾åˆ°äº†é›¶ï¼Œåˆ™æ‰€æœ‰å¯¹è¿™ä¸ªCSemaphoreç±»å¯¹è±¡æ‰€æŽ§åˆ¶çš„èµ„æºçš„è®¿é—®å°è¯•éƒ½è¢«æ”¾å…¥åˆ°ä¸€ä¸ªé˜Ÿåˆ—ä¸­ç­‰å¾…ï¼Œç›´åˆ°è¶…æ—¶æˆ–è®¡æ•°å€¼ä¸ä¸ºé›¶ä¸ºæ­¢ã€‚ CSemaphore( LONG lInitialCount = 1, //ä¿¡å·é‡å¯¹è±¡çš„åˆå§‹è®¡æ•°å€¼ï¼Œå³å¯è®¿é—®çº¿ç¨‹æ•°ç›®çš„åˆå§‹å€¼ï¼› LONG lMaxCount = 1, //ä¿¡å·é‡å¯¹è±¡è®¡æ•°å€¼çš„æœ€å¤§å€¼ï¼Œè¯¥å‚æ•°å†³å®šäº†åŒä¸€æ—¶åˆ»å¯è®¿é—®ç”±ä¿¡å·é‡ä¿æŠ¤çš„èµ„æºçš„çº¿ç¨‹æœ€å¤§æ•°ç›®ï¼› LPCTSTR pstrName = NULL, LPSECURITY_ATTRIBUTES lpsaAttributes = NULL ); ä¸€èˆ¬æ˜¯å°†å½“å‰å¯ç”¨èµ„æºè®¡æ•°è®¾ç½®ä¸ºæœ€å¤§èµ„æºè®¡æ•°ï¼Œæ¯å¢žåŠ ä¸€ä¸ªçº¿ç¨‹å¯¹å…±äº«èµ„æºçš„è®¿é—®ï¼Œå½“å‰å¯ç”¨èµ„æºè®¡æ•°å°±å‡1ï¼Œåªè¦å½“å‰å¯ç”¨èµ„æºè®¡æ•°å¤§äºŽ0ï¼Œå°±å¯ä»¥å‘å‡ºä¿¡å·é‡ä¿¡å·ã€‚å¦‚æžœä¸º0ï¼Œåˆ™æ”¾å…¥ä¸€ä¸ªé˜Ÿåˆ—ä¸­ç­‰å¾…ã€‚ çº¿ç¨‹åœ¨å¤„ç†å®Œå…±äº«èµ„æºåŽï¼Œåº”åœ¨ç¦»å¼€çš„åŒæ—¶é€šè¿‡ReleaseSemaphoreï¼ˆï¼‰å‡½æ•°å°†å½“å‰å¯ç”¨èµ„æºæ•°åŠ 1ã€‚]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ é¢å‘å¯¹è±¡ç¯‡ Union]]></title>
    <url>%2F2019%2F03%2F13%2FC-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AF%87-Union%2F</url>
    <content type="text"><![CDATA[Rules The union is only as big as necessary to hold its [largest data] member. The other data members are allocated in the [same bytes] as part of that [largest member]. The details of that allocation are [implementation-defined], and itâ€™s [undefined behavior] to read from the member of the union that [wasnâ€™t most recently written]. Many compilers implement, as a [non-standard language extension], the ability to [read inactive] members of a union. 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdint&gt;union S&#123; std::int32_t n; // occupies 4 bytes std::uint16_t s[2]; // uint16_t:unsigned integer type with width of exactly 16 // occupies 4 bytes(2*2=4) std::uint8_t c; // uint8_t:unsigned integer type with width of exactly 8 // occupies 1 byte&#125;; // the whole union occupies 4 bytes[rule.1] int main()&#123; S s = &#123;0x12345678&#125;; // initializes the first member, s.n is now the active member // at this point, reading from s.s or s.c is undefined behavior[rule.3] std::cout &lt;&lt; std::hex &lt;&lt; "s.n = " &lt;&lt; s.n &lt;&lt; '\n'; s.s[0] = 0x0011; // s.s is now the active member // at this point, reading from n or c is UB but most compilers define it[rule.4] std::cout &lt;&lt; "s.c is now " &lt;&lt; +s.c &lt;&lt; '\n' // 11 or 00, depending on platform &lt;&lt; "s.n is now " &lt;&lt; s.n &lt;&lt; '\n'; // 12340011 or 00115678&#125; output 123s.n = 12345678s.c is now 0s.n is now 115678 Member allocatingEach member is allocated as if it is the only member of the class. Conctors and Dectors of membersIf members of a union are classes with [user-defined constructors] and [destructors], to switch the active member, [explicit destructor] and [placement new] are generally needed: 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt; union S&#123; std::string str; std::vector&lt;int&gt; vec; ~S() &#123;&#125; // needs to know which member is active, only possible in union-like class &#125;;// the whole union occupies max(sizeof(string), sizeof(vector&lt;int&gt;))[rule.1] int main()&#123; S s = &#123;"Hello, world"&#125;; // at this point, reading from s.vec is undefined behavior[rule.3] std::cout &lt;&lt; "s.str = " &lt;&lt; s.str &lt;&lt; '\n'; s.str.~basic_string(); new (&amp;s.vec) std::vector&lt;int&gt;;//placement new // now, s.vec is the active member of the union s.vec.push_back(10); std::cout &lt;&lt; s.vec.size() &lt;&lt; '\n'; s.vec.~vector();//explicit destructor&#125; output 12s.str = Hello, world1 Member lifetime1234567891011121314151617181920union A &#123; int x; int y[4]; &#125;;struct B &#123; A a; &#125;;union C &#123; B b; int k; &#125;;int f() &#123; C c; // does not start lifetime of any union member c.b.a.y[3] = 4; // OK: "c.b.a.y[3]", names union members c.b and c.b.a.y; // This creates objects to hold union members c.b and c.b.a.y return c.b.a.y[3]; // OK: c.b.a.y refers to newly created object&#125; struct X &#123; const int a; int b; &#125;;union Y &#123; X x; int k; &#125;;void g() &#123; Y y = &#123; &#123; 1, 2 &#125; &#125;; // OK, y.x is active union member (9.2) int n = y.x.a; y.k = 4; // OK: ends lifetime of y.x, y.k is active member of union y.x.b = n; // undefined behavior: y.x.b modified outside its lifetime, // "y.x.b" names y.x, but X's default constructor is deleted, // so union member y.x's lifetime does not implicitly start&#125; Anonymous unions12345678910int main()&#123; union &#123; int a; const char* p; &#125;; a = 1; p = "Jennifer";&#125; Union-like classesA union-like class is either a (non-union) class that has at least one anonymous union as a member or a union. A union-like class has a set of variant members: the non-static data members of its member anonymous unions; in addition, if the union-like class is a union, its non-static data members that are not anonymous unions. Union-like classes can be used to implement tagged unions. 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt; // S has one non-static data member (tag), three enumerator members (CHAR, INT, DOUBLE), // and three variant members (c, i, d)struct S&#123; enum&#123;CHAR, INT, DOUBLE&#125; tag; union &#123; char c; int i; double d; &#125;;&#125;; void print_s(const S&amp; s)&#123; switch(s.tag) &#123; case S::CHAR: std::cout &lt;&lt; s.c &lt;&lt; '\n'; break; case S::INT: std::cout &lt;&lt; s.i &lt;&lt; '\n'; break; case S::DOUBLE: std::cout &lt;&lt; s.d &lt;&lt; '\n'; break; &#125;&#125; int main()&#123; S s = &#123;S::CHAR, 'a'&#125;; print_s(s); s.tag = S::INT; s.i = 123; print_s(s);&#125; output 12a123]]></content>
      <categories>
        <category>ã€ŠC++ Primerã€‹</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>OOP</tag>
        <tag>union</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ è¯­è¨€ç¯‡ Named requirements]]></title>
    <url>%2F2019%2F03%2F12%2FC-%E8%AF%AD%E8%A8%80%E7%AF%87-Named-requirements%2F</url>
    <content type="text"><![CDATA[Utilities library:Type support std::is_objectDefined in header &lt;type_traits> (c++11) cv-qualified type, value is true. function, reference, or void types, value is false. 12template&lt; class T &gt; struct is_object; 12345678910111213141516#include &lt;iostream&gt;#include &lt;type_traits&gt; int main() &#123; class cls &#123;&#125;; std::cout &lt;&lt; std::boolalpha; //IO library:IO manipulators std::cout &lt;&lt; std::is_object&lt;int&gt;::value &lt;&lt; '\n'; //true,cv-qualified type std::cout &lt;&lt; std::is_object&lt;int&amp;&gt;::value &lt;&lt; '\n'; //false,reference type std::cout &lt;&lt; std::is_object&lt;cls&gt;::value &lt;&lt; '\n'; //true,cv-qualified type std::cout &lt;&lt; std::is_object&lt;cls&amp;&gt;::value &lt;&lt; '\n'; //false,reference type&#125; Named Requirements: Library-Wide Function Object A FunctionObject type is the type of an object that can be used on the left of the function call operator. ï¼ˆèƒ½ä»¥å‡½æ•°è°ƒç”¨è¯­æ³•è°ƒç”¨çš„å¯¹è±¡ã€‚ï¼‰ RequirementsThe type T satisfies FunctionObject if The type T satisfies std::is_object, and Given f, a value of type T or const T args, suitable argument list, which may be empty Notesâ€» Functions and references to functions are not function object types, but can be used where function object types are expected due to function-to-pointer implicit conversion(pointers to functionsæŒ‡å‘å‡½æ•°çš„æŒ‡é’ˆ). Standard library All pointers to functions satisfy this requirement. All [Function objects] defined in &lt;functional> Some [return types of functions] of &lt;functional> Predicate The Predicate requirements describe a callable that returns a value testable as a bool.è°“è¯è¦æ±‚æè¿°å¯è°ƒç”¨å¯¹è±¡è¿”å›žå¯ä½œä¸º bool æµ‹è¯•çš„å€¼ã€‚ Predicate is typically used with algorithms that take input data (individual objects/containers) and a predicate, which is then called on input data to decide on further course of action. Some examples of predicate usage in C++ standard library are: std::all_of, std::any_of,std::none_of Take an array of elements and a predicate as an input. Call predicate on individual input elements, and return true if for all/any/none elements, predicate returns true. 123456789101112131415161718192021222324252627282930int main()&#123; std::vector&lt;int&gt; v(10, 2); std::partial_sum(v.begin(), v.end(), v.begin()); //&lt;numeric&gt;,è®¡ç®—èŒƒå›´ [first, last) çš„å­èŒƒå›´ä¸­å…ƒç´ çš„éƒ¨åˆ†å’Œï¼Œå¹¶å†™å…¥åˆ°å§‹äºŽ d_first çš„èŒƒå›´ã€‚é»˜è®¤ç‰ˆæœ¬ç”¨ operator+ ï¼Œç¬¬äºŒç‰ˆæœ¬ç”¨ç»™å®šçš„äºŒå…ƒå‡½æ•° op å¯¹å…ƒç´ æ±‚å’Œ. std::cout &lt;&lt; "Among the numbers: "; std::copy(v.begin(), v.end(), std::ostream_iterator&lt;int&gt;(std::cout, " ")); std::cout &lt;&lt; '\n'; //all_of:è‹¥ä¸€å…ƒè°“è¯å¯¹èŒƒå›´ä¸­æ‰€æœ‰å…ƒç´ è¿”å›ž true åˆ™ä¸º true ï¼Œå¦åˆ™ä¸º false ã€‚è‹¥èŒƒå›´ä¸ºç©ºåˆ™è¿”å›ž true ã€‚ if (std::all_of(v.begin(), v.end(), [](int i)&#123; return i % 2 == 0; &#125;)) &#123; std::cout &lt;&lt; "All numbers are even\n"; &#125; //none_of: è‹¥ä¸€å…ƒè°“è¯ä¸å¯¹èŒƒå›´ä¸­ä»»ä½•å…ƒç´ è¿”å›ž true åˆ™ä¸º true ï¼Œå¦åˆ™ä¸º false ã€‚è‹¥èŒƒå›´ä¸ºç©ºåˆ™è¿”å›ž true ã€‚ if (std::none_of(v.cbegin(), v.cend(), std::bind(std::modulus&lt;int&gt;(), std::placeholders::_1, 2))) &#123; std::cout &lt;&lt; "None of them are odd\n"; &#125; //any_of: è‹¥ä¸€å…ƒè°“è¯å¯¹èŒƒå›´ä¸­è‡³å°‘ä¸€ä¸ªå…ƒç´ è¿”å›ž true åˆ™ä¸º true ï¼Œå¦åˆ™ä¸º false ã€‚è‹¥èŒƒå›´ä¸ºç©ºåˆ™è¿”å›ž false ã€‚ struct DivisibleBy &#123; const int d; DivisibleBy(int n) : d(n) &#123;&#125; bool operator()(int n) const &#123; return n % d == 0; &#125; &#125;; if (std::any_of(v.cbegin(), v.cend(), DivisibleBy(7))) &#123; std::cout &lt;&lt; "At least one number is divisible by 7\n"; &#125;&#125; output: 1234Among the numbers: 2 4 6 8 10 12 14 16 18 20 All numbers are evenNone of them are oddAt least one number is divisible by 7 std::find_if Take sequence of elements, and a predicate. Return first element in the sequence, for which predicate returns value equal to true 12345678910111213141516171819202122int main()&#123; int n1 = 3; int n2 = 5; std::vector&lt;int&gt; v&#123;0, 1, 2, 3, 4&#125;; auto result1 = std::find(std::begin(v), std::end(v), n1); auto result2 = std::find(std::begin(v), std::end(v), n2); if (result1 != std::end(v)) &#123; std::cout &lt;&lt; "v contains: " &lt;&lt; n1 &lt;&lt; '\n';//v contains: 3 &#125; else &#123; std::cout &lt;&lt; "v does not contain: " &lt;&lt; n1 &lt;&lt; '\n'; &#125; if (result2 != std::end(v)) &#123; std::cout &lt;&lt; "v contains: " &lt;&lt; n2 &lt;&lt; '\n'; &#125; else &#123; std::cout &lt;&lt; "v does not contain: " &lt;&lt; n2 &lt;&lt; '\n';//v does not contain: 5 &#125;&#125; In other words, if an algorithm takes a [Predicate] pred and an [iterator] first, it should be able to test the object of the type pointed to by the iterator first using the given predicate via a construct like if(pred(*first)) {â€¦} .The function object [pred] shall not apply any [non-constant function] through the [dereferenced iterator]. This function object may be a [pointer to function] or [an object of a type with an appropriate function call operator]. BinaryPredicate BinaryPredicate is a set of requirements expected by some of the standard library facilities from the user-provided arguments. Given a BinaryPredicate bin_pred and a pair of iterators iter1 and iter2 or an iterator iter and a value value, the expression bin_pred(iter1, iter2) or, respectively, bin_pred(*iter, value), must be contextually convertible to bool.In addition, evaluation of that expression is not allowed to call non-const member functions of the dereferenced iterators. Requirements Predicate CopyConstructible (unless otherwise specified) Compare Compare is a set of requirements expected by some of the standard library facilities from the user-provided function object types. The return value of the function call operation applied to an object of a type satisfying Compare, when contextually converted to bool, yields true if the first argument of the call appears before the second in the strict weak ordering relation induced by this type, and false otherwise. As with any BinaryPredicate(äºŒå…ƒè°“è¯), evaluation of that expression is not allowed to call non-const functions through the dereferenced iterators. RequirementsThe type T satisfies Compare if The type T satisfies BinaryPredicate, andGiven comp, an object of type T equiv(a, b), an expression equivalent to !comp(a, b) &amp;&amp; !comp(b, a) The following expressions must be valid and have their specified effects Expression Return type Requirements comp(a, b) implicitly convertible to bool Establishes strict weak ordering relation with the following propertiesFor all a, comp(a,a)==falseIf comp(a,b)==true then comp(b,a)==falseif comp(a,b)==true and comp(b,c)==true then comp(a,c)==true equiv(a, b) bool Establishes equivalence relationship with the following propertiesFor all a, equiv(a,a)==trueIf equiv(a,b)==true, then equiv(b,a)==trueIf equiv(a,b)==true and equiv(b,c)==true, then equiv(a,c)==true Note: comp induces a strict total ordering on the equivalence classes determined by equiv to be continuedâ€¦to be reviewedâ€¦]]></content>
      <categories>
        <category>ã€ŠC++ Primerã€‹</category>
      </categories>
      <tags>
        <tag>Function Object</tag>
        <tag>C++</tag>
        <tag>Predicate</tag>
        <tag>BinaryPredicate</tag>
        <tag>Compare</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ ç®—æ³•ç¯‡ std::sort_heap]]></title>
    <url>%2F2019%2F03%2F12%2FC-%E7%AE%97%E6%B3%95%E7%AF%87-std-sort-heap%2F</url>
    <content type="text"><![CDATA[STLå †æ“ä½œ(å‡½æ•°æ¨¡æ¿) is_heap(v.begin(), v.end()) æ£€æŸ¥èŒƒå›´ [first, last) ä¸­çš„å…ƒç´ æ˜¯å¦ä¸ºæœ€å¤§å †ã€‚[c++11] auto heap_end = is_heap_until(v.begin(), v.end()); æ£€éªŒèŒƒå›´ [first, last) å¹¶å¯»æ‰¾å§‹äºŽ first ä¸”ä¸ºæœ€å¤§å †çš„æœ€å¤§èŒƒå›´ï¼Œè¿”å›žå †çš„æœ€åŽä¸€ä¸ªã€‚[c++11] make_heap(v.begin(), v.end()); æ ¹æ®åŒºé—´å†…çš„å…ƒç´ åˆ›å»ºå‡ºä¸€ä¸ªæœ€å¤§å † ã€‚ è‡³å¤š 3*Næ¬¡æ¯”è¾ƒã€‚ push_heap(v.begin(), v.end()); Inserts the element at the position last-1 into the max heap defined by the range [first, last-1). å¦‚æžœä¸æ˜¯æœ€å¤§å †ï¼Œä¸ä¼šæŠ¥é”™ï¼Œä½†æ˜¯æ— æ³•ç”Ÿæˆæœ€å¤§å †ã€‚ è¿›è¡Œlog(N)æ¬¡æ¯”è¾ƒã€‚ pop_heap(v.begin(), v.end()); ç§»åŠ¨æœ€å¤§å…ƒç´ åˆ°ç»“å°¾ã€‚ å¦‚æžœä¸æ˜¯æœ€å¤§å †ï¼Œä¼šæŠ¥é”™ã€‚ sort_heap(v.begin(), v.end()); è½¬æ¢æœ€å¤§å † [first, last) ä¸ºä»¥å‡åºæŽ’åºçš„èŒƒå›´ã€‚ å¦‚æžœä¸æ˜¯æœ€å¤§å †ï¼Œä¼šæŠ¥é”™ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;int main()&#123; std::vector&lt;int&gt; v = &#123; 3, 1, 4, 1, 5, 9 &#125;; std::push_heap(v.begin(), v.end()); std::cout &lt;&lt; "heap:\t"; for (const auto &amp;i : v) &#123; std::cout &lt;&lt; i &lt;&lt; ' '; &#125; std::cout &lt;&lt; '\n'; //æ ¹æ®åŒºé—´å†…çš„å…ƒç´ åˆ›å»ºå‡ºä¸€ä¸ªæœ€å¤§å † std::make_heap(v.begin(), v.end()); // 9 5 4 1 1 3 std::cout &lt;&lt; "heap:\t"; for (const auto &amp;i : v) &#123; std::cout &lt;&lt; i &lt;&lt; ' '; &#125; std::cout &lt;&lt; '\n'; std::pop_heap(v.begin(), v.end()); // ç§»åŠ¨æœ€å¤§å…ƒç´ åˆ°ç»“å°¾ std::cout &lt;&lt; "after pop_heap: "; for (auto i : v) std::cout &lt;&lt; i &lt;&lt; ' ';// 5 3 4 1 1 9 std::cout &lt;&lt; '\n'; int largest = v.back(); v.pop_back(); // å®žé™…ç§»å‡ºæœ€å¤§å…ƒç´  std::cout &lt;&lt; "largest element: " &lt;&lt; largest &lt;&lt; '\n';//9 std::cout &lt;&lt; "heap without largest: "; for (auto i : v) std::cout &lt;&lt; i &lt;&lt; ' ';// 5 3 4 1 1 std::cout &lt;&lt; '\n'; //è½¬æ¢æœ€å¤§å † [first, last) ä¸ºä»¥å‡åºæŽ’åºçš„èŒƒå›´ï¼Œå¿…é¡»ä¿è¯æ˜¯æœ€å¤§å †ï¼Œå¦åˆ™æŠ¥é”™ã€‚ if (std::is_heap(v.begin(), v.end()))//æ£€æŸ¥èŒƒå›´ [first, last) ä¸­çš„å…ƒç´ æ˜¯å¦ä¸ºæœ€å¤§å †ã€‚[c++11] std::sort_heap(v.begin(), v.end());//1 1 3 4 5 std::cout &lt;&lt; "\nsorted:\t"; for (const auto &amp;i : v) &#123; std::cout &lt;&lt; i &lt;&lt; ' '; &#125; std::cout &lt;&lt; '\n'; std::make_heap(v.begin(), v.end()); // å¾ˆå¯èƒ½æ‰°ä¹±å † v.push_back(2); v.push_back(6); auto heap_end = std::is_heap_until(v.begin(), v.end()); std::cout &lt;&lt; "all of v: "; for (auto i : v) std::cout &lt;&lt; i &lt;&lt; ' '; std::cout &lt;&lt; '\n'; std::cout &lt;&lt; "only heap: "; for (auto i = v.begin(); i != heap_end; ++i) std::cout &lt;&lt; *i &lt;&lt; ' '; std::cout &lt;&lt; '\n'; std::push_heap(v.begin(), v.end()); std::cout &lt;&lt; "push_heap: "; for (auto i : v) std::cout &lt;&lt; i &lt;&lt; ' '; std::cout &lt;&lt; '\n';&#125; è¾“å‡ºï¼š 123456789heap: 9 1 3 1 5 4heap: 9 5 4 1 1 3after pop_heap: 5 3 4 1 1 9largest element: 9heap without largest: 5 3 4 1 1sorted: 1 1 3 4 5all of v: 5 4 3 1 1 2 6only heap: 5 4 3 1 1 2push_heap: 6 4 5 1 1 2 3 using priority_queuemax-heap(default)12345678910class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; priority_queue&lt;int&gt; pq(nums.begin(), nums.end()); for (int i = 0; i &lt; k - 1; i++) &#123; pq.pop();//å°†å †é¡¶å…ƒç´ åˆ é™¤k-1æ¬¡ã€‚ &#125; return pq.top(); &#125;&#125;; min-heap12345678910111213class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq; for (int num : nums) &#123; pq.push(num); if (pq.size() &gt; k) &#123; pq.pop(); &#125; &#125; return pq.top(); &#125;&#125;; using multiset(rbt)min-heap(default)12345678910111213class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; multiset&lt;int&gt; mset; for (int num : nums) &#123; mset.insert(num); if (mset.size() &gt; k) &#123; mset.erase(mset.begin());//multisetæ²¡æœ‰pop()ï¼Œåªèƒ½ç”¨erase(it); &#125; &#125; return *mset.begin();//multisetä¹Ÿæ²¡æœ‰top()ï¼Œä»–æ˜¯ &#125;&#125;; max-heap12345678910class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; multiset&lt;int, greater&lt;int&gt;&gt; mset(nums.begin(), nums.end()); for (int i = 0; i &lt; k - 1; i++) &#123; mset.erase(mset.begin()); &#125; return *mset.begin(); &#125;&#125;; implements a max-heapIn the above we have presented heap solutions using STL. You may also implement your own heap if you are interested. I suggest you to read the Heapsort chapter of Introduction to Algorithms if you are not familiar with it. The following code implements a max-heap. 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; buildMaxHeap(nums); for (int i = 0; i &lt; k - 1; i++) &#123; swap(nums[0], nums[--heapSize]); maxHeapify(nums, 0); &#125; return nums[0]; &#125;private: int heapSize; int left(int i) &#123; return (i &lt;&lt; 1) + 1; &#125; int right(int i) &#123; return (i &lt;&lt; 1) + 2; &#125; void maxHeapify(vector&lt;int&gt;&amp; nums, int i) &#123; int largest = i, l = left(i), r = right(i); if (l &lt; heapSize &amp;&amp; nums[l] &gt; nums[largest]) &#123; largest = l; &#125; if (r &lt; heapSize &amp;&amp; nums[r] &gt; nums[largest]) &#123; largest = r; &#125; if (largest != i) &#123; swap(nums[i], nums[largest]); maxHeapify(nums, largest);//é€’å½’ &#125; &#125; void buildMaxHeap(vector&lt;int&gt;&amp; nums) &#123; heapSize = nums.size(); for (int i = (heapSize &gt;&gt; 1) - 1; i &gt;= 0; i--) &#123; maxHeapify(nums, i); &#125; &#125;&#125;; REFæœ€å¤§å †ï¼ˆåˆ›å»ºã€åˆ é™¤ã€æ’å…¥å’Œå †æŽ’åºï¼‰]]></content>
      <categories>
        <category>ã€ŠC++ Primerã€‹</category>
      </categories>
      <tags>
        <tag>RBT</tag>
        <tag>STL</tag>
        <tag>Sort</tag>
        <tag>priority_queue</tag>
        <tag>Algorithms library</tag>
        <tag>Heapsort</tag>
        <tag>multiset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ å®¹å™¨ç¯‡ std::priority_queue]]></title>
    <url>%2F2019%2F03%2F12%2FC-%E5%AE%B9%E5%99%A8%E7%AF%87-std-priority-queue%2F</url>
    <content type="text"><![CDATA[priority_queueDefined in header &lt;queue> 12345template&lt; class T, class Container = std::vector&lt;T&gt;, class Compare = std::less&lt;typename Container::value_type&gt;&gt; class priority_queue; A container adaptor : O(1) for lookup of the largest element(by default) ; O(logn) for insertion and extraction. Compare: change the ordering, e.g. using std::greater&lt;T> makes the top the smallest. Similar to managing a heap in some random access container, with the benefit of not being able to accidentally invalidate the heap. Example123456789101112131415161718192021222324252627282930313233#include &lt;functional&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;iostream&gt; template&lt;typename T&gt; void print_queue(T&amp; q) &#123; while(!q.empty()) &#123; std::cout &lt;&lt; q.top() &lt;&lt; " "; q.pop(); &#125; std::cout &lt;&lt; '\n';&#125; int main() &#123; std::priority_queue&lt;int&gt; q; //largest element(by default) for(int n : &#123;1,8,5,6,3,4,0,9,7,2&#125;) q.push(n); print_queue(q);//9 8 7 6 5 4 3 2 1 0 std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt; &gt; q2; //the top is the smallest. for(int n : &#123;1,8,5,6,3,4,0,9,7,2&#125;) q2.push(n); print_queue(q2);//0 1 2 3 4 5 6 7 8 9 // Using lambda to compare elements. auto cmp = [](int left, int right) &#123; return (left ^ 1) &lt; (right ^ 1);&#125;; std::priority_queue&lt;int, std::vector&lt;int&gt;, decltype(cmp)&gt; q3(cmp); for(int n : &#123;1,8,5,6,3,4,0,9,7,2&#125;) q3.push(n); print_queue(q3);//8 9 6 7 4 5 2 3 0 1 &#125; decltype[c++11] åˆ†æžè¡¨è¾¾å¼å¹¶å¾—åˆ°å®ƒçš„ç±»åž‹ï¼Œè€Œä¸è®¡ç®—è¡¨è¾¾å¼çš„å€¼ã€‚ 1decltype(f()) sum=x;//sumçš„ç±»åž‹å°±æ˜¯å‡½æ•°fçš„è¿”å›žç±»åž‹ å¦‚æžœdecltypeä½¿ç”¨çš„è¡¨è¾¾å¼æ˜¯ä¸€ä¸ªå˜é‡ï¼Œåˆ™decltypeè¿”å›žè¯¥å˜é‡çš„ç±»åž‹ï¼ˆåŒ…æ‹¬é¡¶å±‚constå’Œå¼•ç”¨åœ¨å†…ï¼‰ 1234const int ci=0,&amp;cj=ci;decltype(ci) x=0;//xçš„ç±»åž‹æ˜¯const intdecltype(cj) y=x;//yçš„ç±»åž‹æ˜¯const int&amp;ï¼Œyç»‘å®šåˆ°xdecltype(cj) z;//é”™è¯¯ã€‚å¼•ç”¨å¿…é¡»åˆå§‹åŒ–ã€‚ å¦‚æžœdecltypeä½¿ç”¨çš„è¡¨è¾¾å¼ä¸æ˜¯å˜é‡ï¼Œåˆ™è¿”å›žè¯¥è¡¨è¾¾å¼å¯¹åº”çš„ç»“æžœçš„ç±»åž‹ï¼ˆæ˜¯ä¸ªå·¦å€¼ï¼Œå¯èƒ½æ˜¯å¼•ç”¨ï¼Œæ‰€ä»¥å®šä¹‰çš„æ—¶å€™éœ€è¦åˆå§‹åŒ–ï¼‰ã€‚ 123int i=42,*p=&amp;i,&amp;r=i;decltype(r+0) b;//ræ˜¯ä¸€ä¸ªå¼•ç”¨ï¼Œå¦‚æžœæƒ³è®©è¿”å›žçš„ç±»åž‹æ˜¯ræ‰€æŒ‡çš„ç±»åž‹ï¼Œå¿…é¡»å¾—æŠŠrä½œä¸ºè¡¨è¾¾å¼çš„ä¸€éƒ¨åˆ†ï¼Œr+0å°±æ˜¯ä¸€ä¸ªå…·ä½“çš„å€¼ï¼Œè€Œä¸æ˜¯å¼•ç”¨ã€‚decltype(*p) c;//è¡¨è¾¾å¼çš„å†…å®¹æ˜¯è§£å¼•ç”¨æ“ä½œï¼Œ decltype((var))çš„ç»“æžœæ°¸è¿œæ˜¯å¼•ç”¨ï¼Œdecltype(var)çš„ç»“æžœåªæœ‰å½“varæ˜¯å¼•ç”¨æ—¶æ‰æ˜¯å¼•ç”¨ã€‚å› ä¸ºåœ¨c++ä¸­ï¼Œå¦‚æžœä¸ºå˜é‡åŠ ä¸Šæ‹¬å·ï¼Œç¼–è¯‘å™¨å°±ä¼šæŠŠä»–å½“ä½œä½œä¸ºèµ‹å€¼è¯­å¥å·¦å€¼çš„è¡¨è¾¾å¼ã€‚123int i=31;decltype((i)) b;//é”™ã€‚bæ˜¯int&amp;ï¼Œå¿…é¡»åˆå§‹åŒ–ã€‚decltype(i) e;//æ­£ç¡®ã€‚ræ˜¯intï¼Œæœªåˆå§‹åŒ–çš„ã€‚ to be continuedâ€¦ next time to complete whats the meaning of decltype..]]></content>
      <categories>
        <category>ã€ŠC++ Primerã€‹</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>Containers library</tag>
        <tag>Sort</tag>
        <tag>priority_queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ é¢å‘å¯¹è±¡ç¯‡ Struct]]></title>
    <url>%2F2019%2F03%2F12%2FC-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AF%87-Struct%2F</url>
    <content type="text"><![CDATA[ç»“æž„ä½“æˆå‘˜å­˜å‚¨å¯¹é½è§„åˆ™å…¶å®žå­—èŠ‚å¯¹é½çš„ç»†èŠ‚å’Œå…·ä½“ç¼–è¯‘å™¨å®žçŽ°ç›¸å…³ï¼Œä½†ä¸€èˆ¬è€Œè¨€ï¼Œæ»¡è¶³ä¸‰ä¸ªå‡†åˆ™: structå†…æ¯ä¸ªæˆå‘˜ç›¸å¯¹structé¦–åœ°å€çš„offsetï¼Œéƒ½æ˜¯è¯¥æˆå‘˜å¤§å°çš„æ•´æ•°å€ã€‚ structå˜é‡çš„é¦–åœ°å€æ˜¯å†…éƒ¨æœ€å¤§æˆå‘˜çš„å€æ•°; sizeof(struct)ä¸ºstructæœ€å®½åŸºæœ¬ç±»åž‹æˆå‘˜å¤§å°çš„æ•´æ•°å€ã€‚ å‡†åˆ™ 1ç»“æž„(struct)æˆ–è”åˆ(union)çš„æ•°æ®æˆå‘˜ï¼Œç¬¬ä¸€ä¸ªæ•°æ®æˆå‘˜æ”¾åœ¨offsetä¸º0çš„åœ°æ–¹ï¼Œæ¯ä¸ªæ•°æ®æˆå‘˜å­˜å‚¨çš„èµ·å§‹ä½ç½®è¦ä»Žè¯¥æˆå‘˜(æ¯ä¸ªæˆå‘˜æœ¬èº«)å¤§å°çš„æ•´æ•°å€å¼€å§‹(æ¯”å¦‚intåœ¨32ä½æœºä¸ºï¼”å­—èŠ‚,åˆ™è¦ä»Žï¼”çš„æ•´æ•°å€åœ°å€å¼€å§‹å­˜å‚¨)ã€‚ 123456struct node&#123; char a;//1 int b//4&#125;;sizeof(node)=8 aå­˜æ”¾åœ¨0offsetçš„ä½ç½®ã€‚bçš„å­˜å‚¨èµ·å§‹ä½ç½®ä¸º1ï¼Œä¸ºäº†æ»¡è¶³å¯¹é½åŽŸåˆ™ï¼Œintå¤§å°ä¸º4ï¼Œbçš„å­˜å‚¨ä½ç½®åº”è¯¥ä¸º4çš„æ•´æ•°å€ï¼Œæ‰€ä»¥è¦åœ¨aåŽè¡¥é½ï¼Œæ‰€ä»¥bçš„å­˜å‚¨èµ·å§‹ä½ç½®ä¸º4ã€‚æ‰€ä»¥nodeå¤§å°ä¸º8ã€‚ å‡†åˆ™2 ç»“æž„ä½“ä½œä¸ºæˆå‘˜å¦‚æžœä¸€ä¸ªç»“æž„é‡Œæœ‰æŸäº›ç»“æž„ä½“æˆå‘˜,åˆ™ç»“æž„ä½“æˆå‘˜è¦ä»Žaé‡Œå­˜æœ‰struct b,bé‡Œæœ‰char,int ,doubleç­‰å…ƒç´ ,é‚£båº”è¯¥ä»Ž8çš„æ•´æ•°å€å¼€å§‹å­˜å‚¨.)12345678```cppstruct pa&#123; char a;//1 node b;//bå†…éƒ¨æœ€å¤§å…ƒç´ å¤§å°æ˜¯4ï¼Œæ‰€ä»¥bçš„èµ·å§‹ä½ç½®è¦æ˜¯4çš„æ•´å€æ•°.åœ¨aåŽé¢è¡¥ä½ã€‚&#125;sizeof(pa)=12//4+8=12. å‡†åˆ™3 sizeof(struct)ç»“æž„ä½“çš„æ€»å¤§å°,ä¹Ÿå°±æ˜¯sizeofçš„ç»“æžœ,.å¿…é¡»æ˜¯å…¶å†…éƒ¨æœ€å¤§æˆå‘˜çš„æ•´æ•°å€ï¼ˆç»“æž„ä½“æˆå‘˜ä»¥æœ€å¤§æˆå‘˜ä¸ºä»£è¡¨ï¼‰.ä¸è¶³çš„è¦è¡¥é½. 123456struct node&#123; double a;//8 char b;//1&#125;sizeof(node)=16//9-&gt;2*8=16 æŒ‰1,2åŽŸåˆ™å¯è®¡ç®—å‡ºç»“æžœåº”ä¸º9;ä½†ç»“æž„ä½“å¤§å°åº”ä¸º12345678å¦‚æžœç¼–è¯‘å™¨ä¸­æä¾›äº†```#pragma pack(n)```ï¼Œä¸Šè¿°å¯¹å…¶æ¨¡å¼å°±ä¸é€‚ç”¨äº†ï¼Œä¾‹å¦‚è®¾å®šå˜é‡ä»¥nå­—èŠ‚å¯¹é½æ–¹å¼ï¼Œåˆ™ä¸Šè¿°æˆå‘˜ç±»åž‹å¯¹é½å®½åº¦ï¼ˆåº”å½“ä¹ŸåŒ…æ‹¬æ”¶å°¾å¯¹é½ï¼‰åº”è¯¥é€‰æ‹©```æˆå‘˜ç±»åž‹å®½åº¦å’Œnä¸­è¾ƒå°è€…```ï¼›## ä¾‹å­ Q: ```CPPä¸ºä»€ä¹ˆsizeofæ“ä½œå‘˜è¿”å›žçš„ç»“æž„å°ºå¯¸å¤§äºŽç»“æž„æˆå‘˜çš„æ€»å°ºå¯¸ï¼Ÿ A: 123456789101112131415161718192021222324252627282930313233struct X&#123; short s; /* 2 bytes */ /* 2 padding bytes å‡†åˆ™1ã€‚structå†…æ¯ä¸ªæˆå‘˜ç›¸å¯¹structé¦–åœ°å€çš„offsetï¼Œéƒ½æ˜¯è¯¥æˆå‘˜å¤§å°çš„æ•´æ•°å€ã€‚*/ int i; /* 4 bytes */ char c; /* 1 byte */ /* 3 padding bytes å‡†åˆ™3ï¼šsizeof(struct)ä¸ºstructæœ€å®½åŸºæœ¬ç±»åž‹æˆå‘˜å¤§å°çš„æ•´æ•°å€*/&#125;;struct Y&#123; int i; /* 4 bytes */ char c; /* 1 byte */ /* 1 padding byte å‡†åˆ™1ã€‚structå†…æ¯ä¸ªæˆå‘˜ç›¸å¯¹structé¦–åœ°å€çš„offsetï¼Œéƒ½æ˜¯è¯¥æˆå‘˜å¤§å°çš„æ•´æ•°å€ã€‚*/ short s; /* 2 bytes */&#125;;struct Z&#123; int i; /* 4 bytes */ short s; /* 2 bytes */ char c; /* 1 byte */ /* 1 padding byte å‡†åˆ™3ï¼šsizeof(struct)ä¸ºstructæœ€å®½åŸºæœ¬ç±»åž‹æˆå‘˜å¤§å°çš„æ•´æ•°å€*/&#125;;const int sizeX = sizeof(struct X); /* = 12 */const int sizeY = sizeof(struct Y); /* = 8 */const int sizeZ = sizeof(struct Z); /* = 8 */å¯ä»¥é€šè¿‡å¯¹é½å¯¹æˆå‘˜è¿›è¡ŒæŽ’åºæ¥æœ€å°åŒ–ç»“æž„çš„å¤§å°ï¼ˆæŒ‰åŸºæœ¬ç±»åž‹ä¸­çš„å¤§å°æŽ’åºï¼‰ï¼ˆZå¦‚ä¸Šä¾‹ä¸­çš„ç»“æž„ï¼‰ã€‚ç¼–è¯‘å™¨è‡ªåŠ¨å¯¹é½çš„åŽŸå› ï¼šä¸ºäº†æé«˜ç¨‹åºçš„æ€§èƒ½ï¼Œæ•°æ®ç»“æž„ï¼ˆå°¤å…¶æ˜¯æ ˆï¼‰åº”è¯¥å°½å¯èƒ½åœ°åœ¨è‡ªç„¶è¾¹ç•Œä¸Šå¯¹é½ã€‚åŽŸå› åœ¨äºŽï¼Œä¸ºäº†è®¿é—®æœªå¯¹é½çš„å†…å­˜ï¼Œå¤„ç†å™¨éœ€è¦ä½œä¸¤æ¬¡å†…å­˜è®¿é—®ï¼›ç„¶è€Œï¼Œå¯¹é½çš„å†…å­˜è®¿é—®ä»…éœ€è¦ä¸€æ¬¡è®¿é—®ã€‚é‡è¦è¯´æ˜Žï¼šCå’ŒC ++æ ‡å‡†éƒ½å£°æ˜Žç»“æž„å¯¹é½æ˜¯å®žçŽ°å®šä¹‰çš„ã€‚å› æ­¤ï¼Œæ¯ä¸ªç¼–è¯‘å™¨å¯èƒ½é€‰æ‹©ä»¥ä¸åŒæ–¹å¼å¯¹é½æ•°æ®ï¼Œä»Žè€Œå¯¼è‡´ä¸åŒä¸”ä¸å…¼å®¹çš„æ•°æ®å¸ƒå±€ã€‚å› æ­¤ï¼Œåœ¨å¤„ç†å°†ç”±ä¸åŒç¼–è¯‘å™¨ä½¿ç”¨çš„åº“æ—¶ï¼Œäº†è§£ç¼–è¯‘å™¨å¦‚ä½•å¯¹é½æ•°æ®éžå¸¸é‡è¦ã€‚æŸäº›ç¼–è¯‘å™¨å…·æœ‰å‘½ä»¤è¡Œè®¾ç½®å’Œ/æˆ–ç‰¹æ®Š#pragma è¯­å¥æ¥æ›´æ”¹ç»“æž„å¯¹é½è®¾ç½®ã€‚]]></content>
      <categories>
        <category>ã€ŠC++ Primerã€‹</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>OOP</tag>
        <tag>struct</tag>
        <tag>sizeof</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode215. Kth Largest Element in an Array]]></title>
    <url>%2F2019%2F03%2F12%2FLeetCode215-Kth-Largest-Element-in-an-Array%2F</url>
    <content type="text"><![CDATA[Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Example 1: Input: [3,2,1,5,6,4] and k = 2Output: 5Example 2: Input: [3,2,3,1,2,4,5,5,6] and k = 4Output: 4Note:You may assume k is always valid, 1 â‰¤ k â‰¤ arrayâ€™s length. std::sort(),reverse().O(nlogn)12345678class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; sort(nums.begin(),nums.end()); reverse(nums.begin(),nums.end()); return nums[k-1]; &#125;&#125;; Partition.O(nï¼‰123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;vector&gt;using namespace std;class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; if(nums.empty()||k&gt;nums.size()) return 0; k=nums.size()-k;//ä»Žå°åˆ°å¤§æŽ’åˆ—åŽçš„k QuickSort_Recur(nums,0,nums.size()-1); return nums[k]; &#125; void QuickSort_Recur(vector&lt;int&gt;&amp; nums, int low, int high) &#123; if(low&lt;high) &#123; int index = Partition(nums,low,high);//æ‰¾åˆ°ä¸€ä¸ªåŸºå‡†ï¼Œå¹¶å°†æ‰€æœ‰å°äºŽåŸºå‡†çš„æ•°æ”¾åœ¨åŸºå‡†å·¦è¾¹ã€‚ QuickSort_Recur(nums,low,index-1); QuickSort_Recur(nums,index+1,high); &#125; &#125; int Partition(vector&lt;int&gt;&amp; nums,int start,int end) &#123; if(start&lt;0||end&gt;=nums.size()) return 0; int pivot = random(start,end); swap(&amp;nums[pivot],&amp;nums[end]);//æŠŠåŸºå‡†ç§»åˆ°å°¾éƒ¨ int left = start -1;//æœ€å·¦è¾¹åŽŸåœ°åˆ’åˆ†ä¸€ä¸ªå­é›† for(int i =start;i&lt;end;i++) &#123; if(nums[i]&lt;nums[end])//å¦‚æžœå°äºŽåŸºå‡†å°±æ”¾å…¥å­é›†ä¸­ &#123; left++; if(left!=i) swap(&amp;nums[i],&amp;nums[left]); &#125; &#125; left++; swap(&amp;nums[left],&amp;nums[end]);//å°†æœ€å°¾éƒ¨çš„åŸºå‡†æ”¾åœ¨å·¦å­é›†çš„ä¸‹ä¸€ä¸ªä½ç½® return left;//è¿”å›žåŸºå‡† &#125; int random(int min,int max) &#123; int random =rand()%(max-min+1) +min; return random; &#125; void swap(int *in1,int* in2)&#123; int temp=*in1; *in1=*in2; *in2=temp; &#125;&#125;; Heapsortmax-heapï¼šå°†Nä¸ªå…ƒç´ å¡žå…¥ä¸€ä¸ªæœ€å¤§å †ï¼Œå°†å †é¡¶å…ƒç´ åˆ é™¤k-1æ¬¡ã€‚å †é¡¶å°±æ˜¯è¦æ‰¾çš„ç¬¬Kå¤§çš„å…ƒç´ ã€‚min-heapï¼šå°†Kä¸ªæœ€å¤§å…ƒç´ å¡žå…¥ä¸€ä¸ªæœ€å°å †ã€‚å †é¡¶å°±æ˜¯è¦æ‰¾çš„ç¬¬Kå¤§çš„å…ƒç´ ã€‚åœ¨STLä¸­ã€‚priority_queueå’Œmultisetå¯ä»¥å®žçŽ°æœ€å¤§å †/æœ€å°å †ã€‚ using priority_queuemin-heap12345678910111213class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq; for (int num : nums) &#123; pq.push(num); if (pq.size() &gt; k) &#123; pq.pop(); &#125; &#125; return pq.top(); &#125;&#125;; max-heap12345678910class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; priority_queue&lt;int&gt; pq(nums.begin(), nums.end()); for (int i = 0; i &lt; k - 1; i++) &#123; pq.pop(); &#125; return pq.top(); &#125;&#125;; using multisetï¼ˆrbt)min-heap12345678910111213class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; multiset&lt;int&gt; mset; for (int num : nums) &#123; mset.insert(num); if (mset.size() &gt; k) &#123; mset.erase(mset.begin()); &#125; &#125; return *mset.begin(); &#125;&#125;; max-heap12345678910class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; multiset&lt;int, greater&lt;int&gt;&gt; mset(nums.begin(), nums.end()); for (int i = 0; i &lt; k - 1; i++) &#123; mset.erase(mset.begin()); &#125; return *mset.begin(); &#125;&#125;; STLçš„nth_elementå’Œpartial_sort(æ²¡æŽŒæ¡)1234567891011121314class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; nth_element(nums.begin(), nums.begin() + k - 1, nums.end(), greater&lt;int&gt;()); return nums[k - 1]; &#125;&#125;;class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; partial_sort(nums.begin(), nums.begin() + k, nums.end(), greater&lt;int&gt;()); return nums[k - 1]; &#125;&#125;; è¯·æ³¨æ„ä¸¤ä¸ªå†…ç½®å‡½æ•°çš„ç¬¬äºŒä¸ªå‚æ•°ä¸­çš„1ä¹‹å·®ã€‚]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>RBT</tag>
        <tag>Sort</tag>
        <tag>priority_queue</tag>
        <tag>Algorithms library</tag>
        <tag>Heapsort</tag>
        <tag>multiset</tag>
        <tag>Partition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ è¯­è¨€ç¯‡ Pointer to Function]]></title>
    <url>%2F2019%2F03%2F12%2FC-%E8%AF%AD%E8%A8%80%E7%AF%87-Pointer-to-Function%2F</url>
    <content type="text"><![CDATA[pointer to functionInitialized &amp; Implicit Conversion A [pointer to function] can be initialized with an address of a [non-member function] or a [static member function]. [function-to-pointer implicit conversion] 123void f(int);void (*p1)(int) = &amp;f;void (*p2)(int) = f; // same as &amp;f, [function-to-pointer implicit conversion] [this] invokes the [pointed-to function] Unlike [functions] or [references to functions], [pointers to functions] are [objects] and thus can be stored in [arrays, copied, assigned], etc. A [pointer to function] can be used as the [left-hand operand] of the function call operator, [this] invokes the [pointed-to function]: 1234567891011int f(int n)&#123; std::cout &lt;&lt; n &lt;&lt; '\n'; return n * n;&#125; int main()&#123; int (*p)(int) = f;//(int)-&gt;argument type int x = p(7);//p invokes f&#125; DereferencingDereferencing a function pointer yields the [lvalue identifying the pointed-to function]: 1234567891011int f();int (*p)() = f; // pointer p is pointing to fint (&amp;r)() = *p; // the [lvalue that identifies f] is bound to a [reference]r(); // function f invoked through [lvalue reference](*p)(); // function f invoked through the [function lvalue]p(); // function f invoked directly through the [pointer] Initialized from an overloadA pointer to function may be initialized from an overload set which may include functions, function template specializations, and function templates, if only one overload matches the type of the pointer (see address of an overloaded function for more detail): 1234567template&lt;typename T&gt; T f(T n) &#123; return n; &#125;double f(double n) &#123; return n; &#125; int main()&#123; int (*p)(int) = f; // instantiates and selects f&lt;int&gt;&#125; Equality comparison operators are defined for pointers to functions (they compare equal if pointing to the same function). to be continuedâ€¦]]></content>
      <categories>
        <category>ã€ŠC++ Primerã€‹</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>pointer</tag>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ ç®—æ³•ç¯‡ std::sort]]></title>
    <url>%2F2019%2F03%2F11%2FC-%E7%AE%97%E6%B3%95%E7%AF%87-std-sort%2F</url>
    <content type="text"><![CDATA[STL Defined in header &lt;algorithm&gt; template&lt; class RandomIt &gt; void sort( RandomIt first, RandomIt last ); (until C++20) template&lt; class RandomIt &gt; constexpr void sort( RandomIt first, RandomIt last ); (since C++20) template&lt; class ExecutionPolicy, class RandomIt &gt; void sort( ExecutionPolicy&amp;&amp; policy, RandomIt first, RandomIt last ); (since C++17) template&lt; class RandomIt, class Compare &gt; void sort( RandomIt first, RandomIt last, Compare comp ); (until C++20) template&lt; class RandomIt, class Compare &gt; constexpr void sort( RandomIt first, RandomIt last, Compare comp ); (since C++20) template&lt; class ExecutionPolicy, class RandomIt, class Compare &gt; void sort( ExecutionPolicy&amp;&amp; policy, RandomIt first, RandomIt last, Compare comp ); (since C++17) Sorts the elements in the range [first, last) in ascending order. The order of equal elements is not guaranteed to be preserved. 1) Elements are compared using operator&lt;. 3) Elements are compared using the given binary comparison function comp. 2,4) Same as (1,3), but executed according to policy. These overloads do not participate in overload resolution unless std::is_execution_policy_v&lt;std::decay_t&gt; is true Parameters first, last - the range of elements to sort policy - the execution policy to use. See execution policy for details. comp - comparison function object (i.e. an object that satisfies the requirements of Compare ) which returns true if the first argument is less than (i.e. is ordered before) the second. è‹¥ç¬¬ä¸€å‚æ•°å°äºŽï¼ˆå³å…ˆåºäºŽï¼‰ç¬¬äºŒå‚æ•°åˆ™è¿”å›ž trueã€‚ The signature of the comparison function should be equivalent to the following: 1bool cmp(const Type1 &amp;a, const Type2 &amp;b); While the signature does not need to have const &amp;, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2regardless of value category (thus, Type1 &amp; is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)).è™½ç„¶ç­¾åä¸å¿…æœ‰ const &amp; ï¼Œå‡½æ•°ä¹Ÿä¸èƒ½ä¿®æ”¹ä¼ é€’ç»™å®ƒçš„å¯¹è±¡ï¼Œè€Œä¸”å¿…é¡»æŽ¥å—ï¼ˆå¯ä¸º const çš„ï¼‰ç±»åž‹ Type1 ä¸Ž Type2 çš„å€¼ï¼Œæ— å…³ä¹Žå€¼ç±»åˆ«ï¼ˆä»Žè€Œä¸å…è®¸ Type1 &amp; ï¼Œäº¦ä¸å…è®¸ Type1 ï¼Œé™¤éž Type1 çš„ç§»åŠ¨ç­‰ä»·äºŽå¤åˆ¶(C++11 èµ·)ï¼‰ã€‚ The types Type1 and Type2 must be such that an object of type RandomIt can be dereferenced and then implicitly converted to both of them. ç±»åž‹ Type1 ä¸Ž Type2 å¿…é¡»ä½¿å¾— RandomIt ç±»åž‹çš„å¯¹è±¡èƒ½åœ¨è§£å¼•ç”¨åŽéšå¼è½¬æ¢åˆ°è¿™ä¸¤ä¸ªç±»åž‹ã€‚ Complexity O(NÂ·log(N)), where N = std::distance(first, last) comparisons on average. (until C++11) O(NÂ·log(N)), where N = std::distance(first, last) comparisons. (since C++11) Example123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;array&gt;#include &lt;iostream&gt; int main()&#123; std::array&lt;int, 10&gt; s = &#123;5, 7, 4, 2, 8, 6, 1, 9, 0, 3&#125;; // sort using the default operator&lt; std::sort(s.begin(), s.end()); for (auto a : s) &#123; std::cout &lt;&lt; a &lt;&lt; " "; &#125; std::cout &lt;&lt; '\n'; // sort using a standard library compare function object std::sort(s.begin(), s.end(), std::greater&lt;int&gt;()); for (auto a : s) &#123; std::cout &lt;&lt; a &lt;&lt; " "; &#125; std::cout &lt;&lt; '\n'; // sort using a custom function object struct &#123; bool operator()(int a, int b) const &#123; return a &lt; b; &#125; &#125; customLess; std::sort(s.begin(), s.end(), customLess); for (auto a : s) &#123; std::cout &lt;&lt; a &lt;&lt; " "; &#125; std::cout &lt;&lt; '\n'; // sort using a lambda expression std::sort(s.begin(), s.end(), [](int a, int b) &#123; return a &gt; b; &#125;); for (auto a : s) &#123; std::cout &lt;&lt; a &lt;&lt; " "; &#125; std::cout &lt;&lt; '\n';&#125; Output: 12340 1 2 3 4 5 6 7 8 9 9 8 7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7 8 9 9 8 7 6 5 4 3 2 1 0 how to implement ? Quicksort Also known as (partition-exchange sort). Average : O(nlogn), Worst : O(n^2)ï¼Œä½†ä¸€èˆ¬O(n^2)ä¸å¸¸è§ã€‚ Faster than other O(nlogn) algorithmsï¼Œå› ä¸ºQuicksortçš„inner loopåœ¨å¤§éƒ¨åˆ†çš„æž¶æž„ä¸Šå¾ˆæœ‰æ•ˆçŽ‡è¢«å®žçŽ°ã€‚ Algorithm divide and conquer algorithm: æŠŠä¸€ä¸ªåºåˆ—åˆ†ä¸ºä¸¤ä¸ªå­åºåˆ—ï¼Œå†é€’å½’åœ°è§£å†³è¿™äº›å­é—®é¢˜ï¼Œæœ€åŽè¿™äº›å­é—®é¢˜åœ°ç»„åˆä¸ºåŽŸé—®é¢˜çš„è§£ã€‚ The steps are: Pick a pivot Partitioning Recursively PartitionEasy-version(S:Î©(n))Pseudocode:123456789101112function quicksort(q) var list less, pivotList, greater if length(q) â‰¤ 1 &#123; return q &#125; else &#123; select a pivot value pivot from q for each x in q except the pivot element if x &lt; pivot then add x to less if x â‰¥ pivot then add x to greater add pivot to pivotList return concatenate(quicksort(less), pivotList, quicksort(greater)) &#125; éœ€è¦Î©(n)çš„é¢å¤–å­˜å‚¨ç©ºé—´ï¼Œè·ŸMergesortä¸€æ ·ä¸å¥½ã€‚é¢å¤–éœ€è¦çš„å­˜å‚¨å™¨ç©ºé—´é…ç½®ï¼Œåœ¨å®žé™…ä¸Šçš„å®žçŽ°ï¼Œä¹Ÿä¼šæžåº¦å½±å“é€Ÿåº¦å’Œç¼“å­˜çš„æ€§èƒ½ã€‚ In-place-version(S:O(log n))æœ‰ä¸€ä¸ªæ¯”è¾ƒå¤æ‚ä½¿ç”¨åŽŸåœ°ï¼ˆin-placeï¼‰åˆ†åŒºç®—æ³•çš„ç‰ˆæœ¬ï¼Œä¸”åœ¨å¥½çš„åŸºå‡†é€‰æ‹©ä¸Šï¼Œå¹³å‡å¯ä»¥è¾¾åˆ°O(log n)ç©ºé—´çš„ä½¿ç”¨å¤æ‚åº¦ã€‚ Pseudocode:12345678910function partition(a, left, right, pivotIndex) pivotValue := a[pivotIndex] swap(a[pivotIndex], a[right]) // æŠŠpivotç§»åˆ°çµå°¾ storeIndex := left for i from left to right-1 if a[i] &lt;ï¼ pivotValue swap(a[storeIndex], a[i]) storeIndex := storeIndex + 1 swap(a[right], a[storeIndex]) // æŠŠpivotç§»åˆ°å®ƒæœ€å¾Œçš„åœ°æ–¹ return storeIndex è¿™æ˜¯åŽŸåœ°åˆ†åŒºç®—æ³•ï¼Œå®ƒåˆ†åŒºäº†æ ‡ç¤ºä¸ºâ€å·¦è¾¹ï¼ˆleftï¼‰â€å’Œâ€å³è¾¹ï¼ˆrightï¼‰â€çš„åºåˆ—éƒ¨åˆ†ï¼Œå€Ÿç”±ç§»åŠ¨å°äºŽa[pivotIndex]çš„æ‰€æœ‰å…ƒç´ åˆ°å­åºåˆ—çš„å¼€å¤´ï¼Œç•™ä¸‹æ‰€æœ‰å¤§äºŽæˆ–ç­‰äºŽçš„å…ƒç´ æŽ¥åœ¨ä»–ä»¬åŽé¢ã€‚åœ¨è¿™ä¸ªè¿‡ç¨‹å®ƒä¹Ÿä¸ºåŸºå‡†å…ƒç´ æ‰¾å¯»æœ€åŽæ‘†æ”¾çš„ä½ç½®ï¼Œä¹Ÿå°±æ˜¯å®ƒå›žä¼ çš„å€¼ã€‚å®ƒæš‚æ—¶åœ°æŠŠåŸºå‡†å…ƒç´ ç§»åˆ°å­åºåˆ—çš„ç»“å°¾ï¼Œè€Œä¸ä¼šè¢«å‰è¿°æ–¹å¼å½±å“åˆ°ã€‚ç”±äºŽç®—æ³•åªä½¿ç”¨äº¤æ¢ï¼Œå› æ­¤æœ€åŽçš„æ•°åˆ—ä¸ŽåŽŸå…ˆçš„æ•°åˆ—æ‹¥æœ‰ä¸€æ ·çš„å…ƒç´ ã€‚è¦æ³¨æ„çš„æ˜¯ï¼Œä¸€ä¸ªå…ƒç´ åœ¨åˆ°è¾¾å®ƒçš„æœ€åŽä½ç½®å‰ï¼Œå¯èƒ½ä¼šè¢«äº¤æ¢å¾ˆå¤šæ¬¡ã€‚ä¸€æ—¦æˆ‘ä»¬æœ‰äº†è¿™ä¸ªåˆ†åŒºç®—æ³•ï¼Œè¦å†™å¿«é€ŸæŽ’åˆ—æœ¬èº«å°±å¾ˆå®¹æ˜“ï¼š Pseudocode:123456procedure quicksort(a, left, right) if right &gt; left select a pivot value a[pivotIndex] pivotNewIndex := partition(a, left, right, pivotIndex) quicksort(a, left, pivotNewIndex-1) quicksort(a, pivotNewIndex+1, right) ImplementationOne-way scanningarr = [3,7,8,5,2,1,9,5,4] ä»Žå·¦åˆ°å³ï¼ˆé™¤äº†æœ€åŽçš„åŸºå‡†å…ƒç´ ï¼‰ï¼Œå¾ªçŽ¯ç§»åŠ¨å°äºŽåŸºå‡†å…ƒç´  5 çš„æ‰€æœ‰å…ƒç´ åˆ°æ•°ç»„å¼€å¤´ï¼Œç•™ä¸‹å¤§äºŽç­‰äºŽåŸºå‡†å…ƒç´ çš„å…ƒç´ æŽ¥åœ¨åŽé¢ã€‚åœ¨è¿™ä¸ªè¿‡ç¨‹å®ƒä¹Ÿä¸ºåŸºå‡†å…ƒç´ æ‰¾å¯»æœ€åŽæ‘†æ”¾çš„ä½ç½®ã€‚ In C++:12345678910111213141516171819202122232425262728293031323334353637383940414243444546int random(int min,int max)&#123; int random =rand()%(max-min+1) +min; return random;&#125;void swap(int *in1,int* in2)&#123; int temp=*in1; *in1=*in2; *in2=temp;&#125;int Partition(vector&lt;int&gt;&amp; nums,int start,int end)&#123; if(start&lt;0||end&gt;=nums.size()) return 0; int pivot = random(start,end); swap(&amp;nums[pivot],&amp;nums[end]);//æŠŠåŸºå‡†ç§»åˆ°å°¾éƒ¨ int left = start -1;//æœ€å·¦è¾¹åŽŸåœ°åˆ’åˆ†ä¸€ä¸ªå­é›† for(int i =start;i&lt;end;i++) &#123; if(nums[i]&lt;nums[end])//å¦‚æžœå°äºŽåŸºå‡†å°±æ”¾å…¥å­é›†ä¸­ &#123; left++; if(left!=i) swap(&amp;nums[i],&amp;nums[left]); &#125; &#125; left++; swap(&amp;nums[left],&amp;nums[end]);//å°†æœ€å°¾éƒ¨çš„åŸºå‡†æ”¾åœ¨å·¦å­é›†çš„ä¸‹ä¸€ä¸ªä½ç½® return left;//è¿”å›žåŸºå‡†&#125;void QuickSort_Recur(vector&lt;int&gt;&amp; nums, int low, int high)&#123; if(low&lt;high) &#123; int index = Partition(nums,low,high);//æ‰¾åˆ°ä¸€ä¸ªåŸºå‡†ï¼Œå¹¶å°†æ‰€æœ‰å°äºŽåŸºå‡†çš„æ•°æ”¾åœ¨åŸºå‡†å·¦è¾¹ã€‚ QuickSort_Recur(nums,low,index-1); QuickSort_Recur(nums,index+1,high); &#125;&#125; Two-way scanningvar items = [4, 2, 6, 5, 3, 9]; In the previous example, the array becomes [4, 2, 3, 5, 6, 9] after one partition and the index returned is 4 (the last spot of the left pointer). After that, the left side of the overall array (items 0 through 3) is partitioned, as in the following figure. In C++:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#define Max(a, b) ( (a &gt; b) ? a : b )#define Min(a, b) ( (a &lt; b) ? a : b )#define RANDOM_INIT() srand(time(NULL))#define RANDOM(L, R) (L + rand() % ((R) - (L) + 1)) // gen a random integer in [L, R]/*** swap 2-element, orignal value */template&lt;typename T&gt; static inline void swap(T &amp;x, T &amp;y) &#123; T _t(x); x = y; y = _t; &#125; /*** the quick-sort partition routine*/template&lt;typename T&gt; static int partition_(T list[],int begin, int end) &#123; int pivot_idx = RANDOM(begin,end); T pivot = list[pivot_idx]; swap(list[begin], list[pivot_idx]); int i = begin + 1;//low int j = end;//high while(i &lt;= j) &#123; while((i &lt;= end) &amp;&amp; (list[i] &lt;= pivot)) i++; while((j &gt;= begin) &amp;&amp; (list[j] &gt; pivot)) j--; if(i &lt; j) swap(list[i],list[j]); &#125; swap(list[begin],list[j]); return j; // final pivot position &#125;/*** quick sort an array of range [begin, end]*/template&lt;typename T&gt; static void quicksort(T list[],int begin,int end) &#123; if( begin &lt; end) &#123; int pivot_idx = partition_&lt;T&gt;(list, begin, end); quicksort(list, begin, pivot_idx-1); quicksort(list, pivot_idx+1, end); &#125; &#125; Optimizations BST : å¿«é€ŸæŽ’åºæ˜¯äºŒå‰æŸ¥æ‰¾æ ‘ï¼ˆäºŒå‰æœç´¢æ ‘ï¼‰çš„ä¸€ä¸ªç©ºé—´æœ€ä¼˜åŒ–ç‰ˆæœ¬ã€‚ä¸æ˜¯å¾ªåºåœ°æŠŠæ•°æ®é¡¹æ’å…¥åˆ°ä¸€ä¸ªæ˜Žç¡®çš„æ ‘ä¸­ï¼Œè€Œæ˜¯ç”±å¿«é€ŸæŽ’åºç»„ç»‡è¿™äº›æ•°æ®é¡¹åˆ°ä¸€ä¸ªç”±é€’å½’è°ƒç”¨æ‰€éšå«çš„æ ‘ä¸­ã€‚è¿™ä¸¤ä¸ªç®—æ³•å®Œå…¨åœ°äº§ç”Ÿç›¸åŒçš„æ¯”è¾ƒæ¬¡æ•°ï¼Œä½†æ˜¯é¡ºåºä¸åŒã€‚å¯¹äºŽæŽ’åºç®—æ³•çš„ç¨³å®šæ€§æŒ‡æ ‡ï¼ŒåŽŸåœ°åˆ†å‰²ç‰ˆæœ¬çš„å¿«é€ŸæŽ’åºç®—æ³•æ˜¯ä¸ç¨³å®šçš„ã€‚å…¶ä»–å˜ç§æ˜¯å¯ä»¥é€šè¿‡ç‰ºç‰²æ€§èƒ½å’Œç©ºé—´æ¥ç»´æŠ¤ç¨³å®šæ€§çš„ã€‚ Heapsort : Worst:O(nlog n)çš„ä¼˜åŠ¿ï¼Œå †æŽ’é€šå¸¸æ¯”å¿«æŽ’æ…¢ï¼Œä½†æ˜¯å¿«æŽ’ä¹Ÿæœ‰æœ€å·®æƒ…å†µå‘ç”ŸO(n^2)ã€‚å¦‚æžœäº‹å…ˆçŸ¥é“å¯ä»¥ç”¨å †æŽ’ï¼Œå°±ç›´æŽ¥ä½¿ç”¨å †æŽ’ã€‚å †æŽ’åºä¹Ÿæ‹¥æœ‰é‡è¦çš„ç‰¹ç‚¹ï¼Œä»…ä½¿ç”¨å›ºå®šé¢å¤–çš„ç©ºé—´ï¼ˆå †æŽ’åºæ˜¯åŽŸåœ°æŽ’åºï¼‰ï¼Œè€Œå³ä½¿æ˜¯æœ€ä½³çš„å¿«é€ŸæŽ’åºå˜åŒ–ç‰ˆæœ¬ä¹Ÿéœ€è¦ O(log n)çš„ç©ºé—´ã€‚ç„¶è€Œï¼Œå †æŽ’åºéœ€è¦æœ‰æ•ˆçŽ‡çš„éšæœºå­˜å–æ‰èƒ½å˜æˆå¯è¡Œã€‚ Mergesort : Worst:O(nlog n)çš„ä¼˜åŠ¿ã€‚ä¸åƒå¿«æŽ’æˆ–å †æŽ’ï¼Œå½’æŽ’æ˜¯ä¸€ä¸ªç¨³å®šæŽ’åºï¼Œä¸”å¯ä»¥è½»æ˜“åœ°è¢«é‡‡ç”¨åœ¨linked listå’Œå­˜å‚¨åœ¨æ…¢é€Ÿè®¿é—®åª’ä½“ä¸Š(åƒæ˜¯ç£ç›˜å­˜å‚¨æˆ–ç½‘ç»œè¿žæŽ¥å­˜å‚¨çš„éžå¸¸å·¨å¤§æ•°åˆ—)ã€‚å°½ç®¡å¿«æŽ’å¯ä»¥è¢«é‡æ–°æ”¹å†™ä½¿ç”¨åœ¨é“¾ä¸²åˆ—ä¸Šï¼Œä½†æ˜¯å®ƒé€šå¸¸ä¼šå› ä¸ºæ— æ³•éšæœºå­˜å–è€Œå¯¼è‡´å·®çš„åŸºå‡†é€‰æ‹©ã€‚å½’æŽ’çš„ä¸»è¦ç¼ºç‚¹ï¼Œæ˜¯åœ¨æœ€ä½³æƒ…å†µä¸‹éœ€è¦O(n)é¢å¤–çš„ç©ºé—´ã€‚ Reference Quicksort From Wikipedia å¯¹partitionçš„ä¼˜åŒ– å¿«é€ŸæŽ’åº]]></content>
      <categories>
        <category>ã€ŠC++ Primerã€‹</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>Sort</tag>
        <tag>Algorithms library</tag>
        <tag>Partition</tag>
        <tag>Quicksort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode169. Majority Element]]></title>
    <url>%2F2019%2F03%2F10%2FLeetcode169-Majority-Element%2F</url>
    <content type="text"><![CDATA[æ•°ç»„ä¸­æœ‰ä¸€ä¸ªæ•°å­—å‡ºçŽ°çš„æ¬¡æ•°è¶…è¿‡æ•°ç»„é•¿åº¦çš„ä¸€åŠï¼Œè¯·æ‰¾å‡ºè¿™ä¸ªæ•°å­—ã€‚ä¾‹å¦‚è¾“å…¥ä¸€ä¸ªé•¿åº¦ä¸º9çš„æ•°ç»„{1,2,3,2,2,2,5,4,2}ã€‚ç”±äºŽæ•°å­—2åœ¨æ•°ç»„ä¸­å‡ºçŽ°äº†5æ¬¡ï¼Œè¶…è¿‡æ•°ç»„é•¿åº¦çš„ä¸€åŠï¼Œå› æ­¤è¾“å‡º2ã€‚å¦‚æžœä¸å­˜åœ¨åˆ™è¾“å‡º0ã€‚ Quicksort , O(nlogn) , æ”¹å˜æ•°ç»„å¿«æŽ’std::sort.ä»Žå°åˆ°å¤§çš„æ•°ç»„ã€‚O(nlogn).æ‰¾åˆ°æœ‰åºæ•°ç»„çš„ä¸­ä½æ•°ã€‚è®¡ç®—ä»–çš„ä¸ªæ•°ã€‚å¦‚æžœå¤§äºŽæ•°ç»„é•¿åº¦çš„ä¸€åŠå°±æ˜¯è¦æ‰¾çš„æ•°å­—ï¼Œå¦åˆ™è¿”å›ž0 è¿™ç§åšæ³•ä¼šå¯¼è‡´æ•°ç»„æ”¹å˜ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;array&gt;using namespace std;namespace yy&#123; int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; if (numbers.empty()) return 0; sort(numbers.begin(), numbers.end()); int mid = numbers[numbers.size() / 2]; int count = 0; for (int a = 0; a&lt;numbers.size(); a++) &#123; if (numbers[a] == mid) count++; &#125; if (count&gt;numbers.size()/2) return mid; return 0; &#125; &#125;int main()&#123; string str; getline(cin, str); istringstream input(str); vector&lt;int&gt; v; char a[100]; // æ³¨æ„ï¼šä¸‹åˆ—å¾ªçŽ¯åœ¨ä»Ž getline() è¿”å›žçš„æµä¸Šçš„ // std::ios_base::operator bool() è¿”å›ž false æ—¶ç»ˆæ­¢ while(input.getline(&amp;a[0], 100, ',') ) &#123; v.push_back(atoi(a)); &#125; cout&lt;&lt;yy::MoreThanHalfNum_Solution(v); return 0;&#125; è®¡æ•°æ³• ï¼ŒO(n) ï¼Œä¸æ”¹å˜æ•°ç»„O(n)çš„åšæ³•ã€‚è¿™ä¸ªæ•°å­—å‡ºçŽ°çš„æ¬¡æ•°ä¸€å®šæ¯”å…¶å®ƒæ‰€æœ‰æ•°å­—å‡ºçŽ°çš„æ¬¡æ•°å¤šã€‚è®¾ä¸¤ä¸ªå˜é‡ï¼Œresultå­˜æ”¾å½“å‰æ•°å­—ï¼Œtimeså­˜æ”¾è¿™ä¸ªæ•°å­—å‡ºçŽ°çš„æ¬¡æ•°ã€‚å¦‚æžœå‡ºçŽ°æ¬¡æ•°ä¸º0ï¼Œå°±è®¾ç½®ä¸ºä¸‹ä¸ªæ•°å­—ï¼Œå¹¶ä¸”æ›´æ–°timesä¸º1ï¼›å¦‚æžœä¸‹ä¸ªæ•°å­—ä¸ç­‰äºŽresultï¼Œæ¬¡æ•°å‡ä¸€ï¼›å¦‚æžœä¸‹ä¸ªæ•°å­—ç­‰äºŽresultï¼ŒtimesåŠ ä¸€ã€‚å¦‚æžœè¿™ä¸ªæ•°å­—æ˜¯å‡ºçŽ°æ¬¡æ•°è¶…è¿‡äº†ä¸€åŠçš„ï¼Œé‚£ä¹ˆæœ€åŽä¸€æ¬¡è®¾ç½®çš„resultä¸€å®šæ˜¯è¦æ‰¾çš„æ•°å­—ã€‚ æœ€åŽå†æ£€æŸ¥resultå‡ºçŽ°çš„æ¬¡æ•°æ˜¯ä¸æ˜¯è¶…è¿‡äº†æ•°ç»„ä¸€åŠã€‚ 12345678910111213141516171819202122232425262728293031namespace yy2 &#123; int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; if (numbers.empty()) return 0; int result=numbers[0]; int times=1; for (int i = 0; i &lt; numbers.size(); i++) &#123; if (times == 0)//è¯´æ˜Žä¸Šä¸€ä¸ªä¸æ˜¯è¦æ‰¾çš„å‡ºçŽ°æœ€å¤šå…ƒç´ ï¼ˆè‡³å°‘timesè¦ä¸º1ï¼‰ï¼Œè®¾ç½®ä¸ºä¸‹ä¸€ä¸ª &#123; result = numbers[i]; times = 1; &#125; else if (result == numbers[i]) &#123; times++; &#125; else times--; &#125;//æœ€åŽä¸€ä¸ªè®¾ç½®ä¸ºresultçš„è¦ä¹ˆæ˜¯å‡ºçŽ°æœ€å¤šçš„ï¼Œè¦ä¹ˆä¸æ˜¯ï¼Œæ‰€ä»¥è¦éªŒè¯ã€‚ int count = 0; for (int i=0; i &lt; numbers.size(); i++) &#123; if (numbers[i] == result) count++; &#125; return count &gt; numbers.size() / 2 ? result : 0; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Quicksort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ è¯­è¨€ç¯‡ Range-Forï¼šObserving and Modifying [c++11]]]></title>
    <url>%2F2019%2F03%2F10%2FC-%E8%AF%AD%E8%A8%80%E7%AF%87-Range-For-c-11%2F</url>
    <content type="text"><![CDATA[Range-For[c++11] What is the correct way of using C++11â€™s range-based for?What syntax should be used? for (auto elem : container), or for (auto&amp; elem : container) or for (const auto&amp; elem : container)? Or some other? ç­”æ¡ˆç›´æŽ¥åœ¨Generic code éƒ¨åˆ†ã€‚ä¸‹é¢æ˜¯è§£é‡Šï¼š Thereâ€™re some difference between observing the elements in the continer vs. modifying them in place. Observingcheap-to-copy :by valueé€‚ç”¨ç®€å•ç±»åž‹çš„å…ƒç´ ï¼Œæ¯”å¦‚ int,double 1for (auto elem : container) for (auto x : v) ç®€å•ç±»åž‹observing â€œintâ€ in â€œvectorâ€. 123vector&lt;int&gt; v = &#123;1, 3, 5, 7, 9&#125;;for (auto x : v) cout &lt;&lt; x &lt;&lt; ' '; output: 11 3 5 7 9 general case : by const referencefor (auto x : v) å¤æ‚ç±»åž‹å¤æ‚ç±»åž‹çš„by value(æ•ˆçŽ‡ä½Žï¼Œä¼šè°ƒç”¨æ‹·è´æž„é€ ã€‚) observing â€œcustomclass_typeâ€ in â€œvectorâ€. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// A sample test class, with custom copy semantics.class X&#123;public: X() : m_data(0) &#123;&#125; X(int data) : m_data(data) &#123;&#125; ~X() &#123;&#125; X(const X&amp; other) : m_data(other.m_data) &#123; cout &lt;&lt; "X copy ctor.\n"; &#125; X&amp; operator=(const X&amp; other) &#123; m_data = other.m_data; cout &lt;&lt; "X copy assign.\n"; return *this; &#125; int Get() const &#123; return m_data; &#125;private: int m_data;&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; os, const X&amp; x)&#123; os &lt;&lt; x.Get(); return os;&#125;vector&lt;X&gt; v = &#123;1, 3, 5, 7, 9&#125;;cout &lt;&lt; "\nElements:\n";for (auto x : v)&#123; cout &lt;&lt; x &lt;&lt; ' ';&#125; output: åœ¨vectoråˆå§‹åŒ–æ—¶ï¼Œæ‹·è´æž„é€ å‡½æ•° è¢«è°ƒç”¨äº†ã€‚ 1234567Elements:X copy ctor.1 X copy ctor.3 X copy ctor.5 X copy ctor.7 X copy ctor.9 åœ¨range-based for loop iterationsçš„æ—¶å€™ï¼Œé‡‡ç”¨çš„æ˜¯by valueçš„æ–¹æ³•ï¼Œåˆå§‹åŒ–å®¹å™¨ä¸­æ¯ä¸ªå…ƒç´ æ—¶ï¼Œcopy constructor è¢«è°ƒç”¨äº†ã€‚è¿™æ ·åšå¾ˆä½Žæ•ˆï¼Œå› ä¸ºæˆ‘ä»¬åªæƒ³è§‚å¯Ÿå®¹å™¨ä¸­çš„å…ƒç´ ,è€Œä¸æ˜¯æƒ³æ‹·è´ä¸€ä¸ªä¸´æ—¶å¯¹è±¡ã€‚ï¼ˆe.g. if these elements are instances of std::string, heap memory allocations can be done, with expensive trips to the memory manager, etc.ï¼‰ for (const auto&amp; x : v)æ‰€ä»¥æœ€å¥½çš„è§‚æµ‹æ–¹æ³•æ˜¯å¸¸é‡å¼•ç”¨ä¼ é€’ const auto &amp; 123456vector&lt;X&gt; v = &#123;1, 3, 5, 7, 9&#125;;cout &lt;&lt; "\nElements:\n";for (const auto&amp; x : v)&#123; cout &lt;&lt; x &lt;&lt; ' ';&#125; output:æ²¡æœ‰ æ‹·è´æž„é€ å‡½æ•° è°ƒç”¨ã€‚æ›´åŠ é«˜æ•ˆã€‚12Elements:1 3 5 7 9 Modifyingå¦‚æžœè¦ä¿®æ”¹å®¹å™¨ä¸­çš„å…ƒç´ ï¼Œ for (auto elem : container) æˆ–è€… for (const auto&amp; elem : container) çš„å†™æ³•æ˜¯é”™è¯¯çš„ã€‚ for (auto elem : container)ä¿®æ”¹çš„æ˜¯æ‹·è´å±€éƒ¨ä¸´æ—¶å˜é‡çš„å€¼ï¼Œä¸æ˜¯åŽŸå§‹æ•°æ®123456vector&lt;int&gt; v = &#123;1, 3, 5, 7, 9&#125;;for (auto x : v) // &lt;-- capture by value (copy) x *= 10; // &lt;-- a local temporary copy ("x") is modified, // *not* the original vector element.for (auto x : v) cout &lt;&lt; x &lt;&lt; ' '; output11 3 5 7 9 for (const auto&amp; elem : container)ä¿®æ”¹å¸¸é‡å¼•ç”¨ä¼šå¯¼è‡´ç¼–è¯‘ä¸é€šè¿‡123TestRangeFor.cpp:138:11: error: assignment of read-only reference 'x' x *= 10; ^ for (auto&amp; x : v)æ­£ç¡®æ–¹æ³•æ˜¯éžå¸¸é‡å¼•ç”¨ 123456789vector&lt;string&gt; v = &#123;"Bob", "Jeff", "Connie"&#125;;// Modify elements in place: use "auto &amp;"for (auto&amp; x : v) x = "Hi " + x + "!";// Output elements (*observing* --&gt; use "const auto&amp;")for (const auto&amp; x : v) cout &lt;&lt; x &lt;&lt; ' '; output 1Hi Bob! Hi Jeff! Hi Connie! Case of Proxy Iteratoréœ€æ±‚ï¼šæƒ³é€šè¿‡éžå¸¸é‡å¼•ç”¨ä¿®æ”¹å®¹å™¨ä¸­boolçš„çŠ¶æ€ã€‚ for (auto&amp; x : v)123vector&lt;bool&gt; v = &#123;true, false, false, true&#125;;for (auto&amp; x : v) x = !x; ç¼–è¯‘ä¸é€šè¿‡ 12345TestRangeFor.cpp:168:20: error: invalid initialization of non-const reference of type 'std::_Bit_reference&amp;' from an rvalue of type 'std::_Bit_iterator::reference &#123;aka std::_Bit_reference&#125;' for (auto&amp; x : v) ^ ä¸ºboolç‰¹åŒ–çš„std::vectoræ¨¡æ¿ï¼Œæ˜¯ç”±æŠŠboolæ‰“åŒ…ä¼˜åŒ–ç©ºé—´åŽå®žçŽ°çš„ï¼Œæ¯ä¸ªbooleanå€¼å 1bit,8ä¸ªbooleanæ‰å 1byteã€‚å› ä¸ºä¸èƒ½è¿”å›žä¸€ä¸ªå•ç‹¬çš„bitçš„referenceï¼Œæ‰€ä»¥vectorä½¿ç”¨äº†ä¸€ä¸ªproxy iteratorè®¾è®¡æ¨¡å¼ã€‚proxy iteratoråœ¨è§£å¼•ç”¨çš„æ—¶å€™ï¼Œä¸äº§ç”Ÿæ™®é€šçš„bool&amp;ï¼Œè€Œæ˜¯è¿”å›ž(by value)ä¸€ä¸ªä¸´æ—¶å¯¹è±¡ï¼Œè¿™ä¸ªå¯¹è±¡æ˜¯ä¸€ä¸ªå¯ä»¥è¡¨è¾¾boolçš„proxy classã€‚ REF: The problem is that std::vector template is specialized for bool, with an implementation that packs the bools to optimize space (each boolean value is stored in one bit, eight â€œbooleanâ€ bits in a byte). Because of that (since itâ€™s not possible to return a reference to a single bit), vector uses a so called â€œproxy iteratorâ€ pattern. A â€œproxy iteratorâ€ is an iterator that, when dereferenced, does not yield an ordinary bool &amp;, but instead returns (by value) a temporary object, which is a proxy class convertible to bool. (See also this question and related answers here on StackOverflow.) for (auto&amp;&amp; x : v)12345678vector&lt;bool&gt; v = &#123;true, false, false, true&#125;;// Invert boolean statusfor (auto&amp;&amp; x : v) // &lt;-- note use of "auto&amp;&amp;" for proxy iterators x = !x;// Print new element valuescout &lt;&lt; boolalpha; for (const auto&amp; x : v)// éµä»Žobservingçš„const auto&amp; cout &lt;&lt; x &lt;&lt; ' '; output 1false true true false proxy iteratorsä¹Ÿéµä»Žobservingçš„for (const auto&amp; elem : container) for (auto&amp;&amp; elem : container)ä¹Ÿé€‚ç”¨ordinary (non-proxy) iterators,æ¯”å¦‚vector&lt;int>æˆ–è€…vector&lt;string>ã€‚ Summary If the objects are cheap to copy (like ints, doubles, etc.) OR NEED to make a local copy. 1for (auto elem : container) // capture by value For observing the complex elements (not need to copy) 1for (const auto&amp; elem : container) // capture by const reference For modifying the elements in place 1for (auto&amp; elem : container) // capture by (non-const) reference If the container uses â€œproxy iteratorsâ€ (like std::vector&lt;bool>) 1for (auto&amp;&amp; elem : container) // capture by &amp;&amp; Generic code For observing the elements 1for (const auto&amp; elem : container) // capture by const reference For modifying the elements in place 1for (auto&amp;&amp; elem : container) // capture by &amp;&amp;]]></content>
      <categories>
        <category>ã€ŠC++ Primerã€‹</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>const</tag>
        <tag>reference</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æŽ’åºç®—æ³•]]></title>
    <url>%2F2019%2F03%2F08%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Inner Sortæ‰€æœ‰æ•°æ®å·²ç»è¯»å…¥å†…å­˜ï¼Œåœ¨å†…å­˜ä¸­è¿›è¡ŒæŽ’åºçš„ç®—æ³•ã€‚æŽ’åºè¿‡ç¨‹ä¸éœ€è¦å¯¹ç£ç›˜è¿›è¡Œè¯»å†™ã€‚è¾…åŠ©ç©ºé—´ä¹Ÿç›´æŽ¥å­˜äºŽå†…å­˜ä¹‹ä¸­ã€‚ Comparison Sorts Insertion Sorts Insertion Sort æ¯æ­¥å°†ä¸€ä¸ªå¾…æŽ’åºçš„è®°å½•ï¼ŒæŒ‰å…¶å…³é”®ç å€¼çš„å¤§å°æ’å…¥å‰é¢å·²ç»æŽ’åºçš„æ–‡ä»¶ä¸­é€‚å½“ä½ç½®ä¸Šï¼Œç›´åˆ°å…¨éƒ¨æ’å…¥å®Œä¸ºæ­¢ã€‚ ä¸é€‚åˆå¯¹äºŽæ•°æ®é‡æ¯”è¾ƒå¤§çš„æŽ’åºåº”ç”¨ã€‚ä½†æ˜¯ï¼Œå¦‚æžœéœ€è¦æŽ’åºçš„æ•°æ®é‡å¾ˆå°ï¼Œä¾‹å¦‚ï¼Œé‡çº§å°äºŽåƒï¼Œé‚£ä¹ˆæ’å…¥æŽ’åºè¿˜æ˜¯ä¸€ä¸ªä¸é”™çš„é€‰æ‹©ã€‚ æ—¶é—´ï¼šÎ©(n)ã€‚ Î˜(n^2)ã€‚ O(n^2)ã€‚ ç©ºé—´ï¼šO(1)ã€‚ Shell Sort (improved InsertionSort) æ—¶é—´ï¼šÎ©(nlogn)ã€‚ Î˜(nlogn^2)ã€‚ O(nlogn^2)ã€‚ ç©ºé—´ï¼šO(1)ã€‚ Exchange Sorts Bubble Sort æ—¶é—´ï¼šÎ©(n)ã€‚ Î˜(n^2)ã€‚ O(n^2)ã€‚ ç©ºé—´ï¼šO(1)ã€‚ Quick Sort(Divide and Conquer) å¿«æŽ’æ˜¯å¹³å‡çŠ¶æ€ä¸‹é€Ÿåº¦æœ€å¿«çš„ä¸€ç§æŽ’åºç®—æ³•ã€‚éšæœºé€‰å®šâ¼€ä¸ªå…ƒç´ ä½œä¸ºè½´å€¼ï¼Œåˆ©â½¤è¯¥è½´å€¼å°†æ•°ç»„åˆ†ä¸ºå·¦å³ä¸¤éƒ¨åˆ†ï¼Œå·¦è¾¹å…ƒç´ éƒ½â½è½´å€¼â¼©ï¼Œå³è¾¹å…ƒç´ éƒ½â½è½´å€¼â¼¤ï¼Œä½†å®ƒä»¬ä¸æ˜¯å®Œå…¨æŽ’åºçš„ã€‚åœ¨æ­¤åŸºç¡€ä¸Šï¼Œåˆ†åˆ«å¯¹å·¦å³ä¸¤éƒ¨åˆ†åˆ†åˆ«é€’å½’è°ƒâ½¤quick sortï¼Œä½¿å¾—å·¦å³éƒ¨åˆ†å®Œå…¨æŽ’åºã€‚ æ—¶é—´ï¼šÎ©(nlogn) ã€‚Î˜(nlogn) ã€‚O(n^2) ã€‚ ç©ºé—´ï¼šO(log(n)) ä¸ç¨³å®š â€‹ Selection Sorts Selection Sort æ¯ä¸€æ¬¡ä»Žå¾…æŽ’åºçš„æ•°æ®å…ƒç´ ä¸­é€‰å‡ºæœ€å°ï¼ˆæˆ–æœ€å¤§ï¼‰çš„ä¸€ä¸ªå…ƒç´ ï¼Œå­˜æ”¾åœ¨åºåˆ—çš„èµ·å§‹ä½ç½®ï¼Œå†ä»Žå‰©ä½™æœªæŽ’åºå…ƒç´ ä¸­ç»§ç»­å¯»æ‰¾æœ€å°ï¼ˆå¤§ï¼‰å…ƒç´ ï¼Œæ”¾åˆ°å·²æŽ’åºåºåˆ—çš„æœ«å°¾ã€‚ é€‰æ‹©æŽ’åºæ˜¯ä¸ç¨³å®šçš„æŽ’åºæ–¹æ³•ã€‚ æ—¶é—´ï¼šÎ©(n^2)ã€‚ Î˜(n^2)ã€‚ O(n^2)ã€‚ ç©ºé—´ï¼šO(1)ã€‚ Heap Sort Heap,å°†è¾“å…¥arrayå˜æˆæœ€å¤§/å°å€¼å †ã€‚ å †çš„å¼¹å‡ºæ“ä½œï¼šå°†å †é¡¶å…ƒç´ ä¸Žå †æœ«å…ƒç´ äº¤æ¢ï¼Œå †çš„â¼¤â¼©å‡â¼€ï¼Œå‘ä¸‹ç§»åŠ¨æ–°çš„å †é¡¶ä»¥ç»´æŠ¤å †çš„æ€§è´¨ã€‚ç›¸å½“äºŽæ¯æ¬¡å°†å‰©ä½™çš„æœ€â¼¤å…ƒç´ ç§»åŠ¨åˆ°æ•°ç»„çš„æœ€å³è¾¹ï¼Œé‡å¤è¿™æ ·çš„æ“ä½œæœ€ç»ˆå°±èƒ½èŽ·å¾—ç”±â¼©åˆ°â¼¤æŽ’åºçš„æ•°ç»„ã€‚ æ—¶é—´ï¼šÎ©(nlogn) ã€‚Î˜(nlogn)ã€‚ O(nlogn)ã€‚ åˆæ¬¡å»ºå †çš„æ—¶é—´å¤æ‚åº¦O(n)ï¼Œåˆ é™¤å †é¡¶å…ƒç´ å¹¶ç»´æŠ¤å †çš„æ€§è´¨éœ€è¦O(logn)ï¼Œè¿™æ ·çš„æ“ä½œâ¼€å…±è¿›â¾næ¬¡ï¼Œæ•…æœ€ç»ˆæ—¶é—´å¤æ‚åº¦O(nlogn) ç©ºé—´ï¼šO(1)ã€‚ Tree Sort æ—¶é—´ï¼šÎ©(nlogn)ã€‚ Î˜(nlogn)ã€‚ O(n^2)ã€‚ ç©ºé—´ï¼šO(n)ã€‚ Timsort(mergeSort_insetionSort) Merge Sort(Divide and Conquer) ä¸ä¾èµ–äºŽéšæœºè¯»å†™ï¼Œå› æ­¤å…·æœ‰å¾ˆå¼ºçš„æ™®é€‚æ€§ï¼Œé€‚â½¤äºŽlistã€‚ å°†çº¿æ€§æ•°æ®ç»“æž„ï¼ˆå¦‚array, vectoræˆ–list ï¼‰åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†ï¼Œå¯¹ä¸¤éƒ¨åˆ†åˆ†åˆ«è¿›â¾æŽ’åºï¼ŒæŽ’åºå®ŒæˆåŽï¼Œå†å°†å„â¾ƒæŽ’åºå¥½çš„ä¸¤ä¸ªéƒ¨åˆ†åˆå¹¶è¿˜åŽŸæˆâ¼€ä¸ªæœ‰åºæ•°ç»„ã€‚ æ—¶é—´ï¼šÎ©(nlogn) ã€‚Î˜(nlogn)ã€‚ O(nlogn)ã€‚ ç©ºé—´ï¼šO(n)ã€‚ Non-Comparison Sorts Bucket Sort ä¸éœ€è¦æ•°æ®ä¹‹é—´çš„ä¸¤ä¸¤æ¯”è¾ƒï¼Œä½†éœ€è¦äº‹å…ˆçŸ¥é“æ•°ç»„çš„ä¸€äº›å…·ä½“æƒ…å†µã€‚ å°†æ•°æ®æ ¹æ®å…¶å¤§å°ï¼Œæ”¾å…¥åˆé€‚çš„æ¡¶å®¹å™¨ä¸­ï¼Œå†ä¾æ¬¡ä»Žæ¡¶ä¸­å–å‡ºï¼Œå½¢æˆæœ‰åºåºåˆ—ã€‚ æ¡¶æŽ’åºé€‚ç”¨äºŽçŸ¥é“å¾…æŽ’åºæ•°ç»„å¤§å°èŒƒå›´çš„æƒ…å†µã€‚ æ—¶é—´ï¼šÎ©(n+k)ã€‚ Î˜(n+k)ã€‚ O(n^2)ã€‚ ç©ºé—´ï¼šO(n)ã€‚ Radix Sort ä¸éœ€è¦æ•°æ®ä¹‹é—´çš„ä¸¤ä¸¤æ¯”è¾ƒï¼Œä½†éœ€è¦äº‹å…ˆçŸ¥é“æ•°ç»„çš„ä¸€äº›å…·ä½“æƒ…å†µã€‚ æ—¶é—´ï¼šÎ©(nk)ã€‚ Î˜(nk)ã€‚ O(nk) ã€‚ ç©ºé—´ï¼šO(n+k)ã€‚ Counting Sort æ—¶é—´ï¼šÎ©(n+k)ã€‚ Î˜(n+k)ã€‚ O(n+k) ã€‚ ç©ºé—´ï¼šO(k)ã€‚ Outer Sortå†…å­˜ä¸­æ— æ³•ä¿å­˜å…¨éƒ¨æ•°æ®ï¼Œéœ€è¦ç£ç›˜è®¿é—®ï¼Œæ¯æ¬¡è¯»å…¥éƒ¨åˆ†æ•°æ®åˆ°å†…å­˜è¿›è¡ŒæŽ’åºã€‚å¤–æŽ’åºç®—æ³•çš„æ ¸â¼¼æ€è·¯åœ¨äºŽæŠŠâ½‚ä»¶åˆ†å—è¯»åˆ°å†…å­˜ï¼Œåœ¨å†…å­˜ä¸­å¯¹æ¯å—â½‚ä»¶ä¾æ¬¡è¿›â¾æŽ’åºï¼Œæœ€åŽåˆå¹¶æŽ’åºåŽçš„å„å—æ•°æ®ï¼Œä¾æ¬¡æŒ‰é¡ºåºå†™å›žâ½‚ä»¶ã€‚ç›¸â½äºŽå†…æŽ’åºï¼Œå¤–æŽ’åºéœ€è¦è¿›â¾å¤šæ¬¡ç£ç›˜è¯»å†™ï¼Œå› æ­¤æ‰§â¾æ•ˆçŽ‡å¾€å¾€ä½ŽäºŽå†…æŽ’åºï¼Œæ—¶é—´ä¸»è¦èŠ±è´¹äºŽç£ç›˜è¯»å†™ä¸Šã€‚ Quick Selectionåˆ©ç”¨å¿«æŽ’çš„æ€æƒ³ï¼Œå°†æ•°ç»„ä¾ç…§â¼€ä¸ªè½´å€¼åˆ†å‰²æˆä¸¤ä¸ªéƒ¨åˆ†ï¼Œå·¦è¾¹å…ƒç´ éƒ½â½è½´å€¼â¼©ï¼Œå³è¾¹å…ƒç´ éƒ½â½è½´å€¼â¼¤ã€‚ç”±äºŽè½´å€¼ä¸‹æ ‡å·²çŸ¥ï¼Œåˆ™å¯ä»¥åˆ¤æ–­æ‰€æ±‚å…ƒç´ è½åœ¨æ•°ç»„çš„å“ªâ¼€éƒ¨åˆ†ï¼Œå¹¶åœ¨é‚£â¼€éƒ¨åˆ†ç»§ç»­è¿›â¾ä¸Šè¿°æ“ä½œï¼Œç›´â¾„æ‰¾åˆ°è¯¥å…ƒç´ ã€‚ å¹³å‡O(n)æ—¶é—´å†…ä»Žâ¼€ä¸ªâ½†åºæ•°ç»„ä¸­è¿”å›žç¬¬kâ¼¤çš„å…ƒç´ ã€‚ ä¸Žå¿«æŽ’ä¸åŒï¼Œç”±äºŽå¿«é€Ÿé€‰æ‹©ç®—æ³•åªåœ¨ä¹Žæ‰€æ±‚å…ƒç´ æ‰€åœ¨çš„é‚£â¼€éƒ¨åˆ†ï¼Œæ•…æ•ˆçŽ‡å¯ä»¥ä»ŽO(nlogn)è¿›â¼€æ­¥æå‡â¾„O(n)ã€‚ Core Mind å‡è®¾â½‚ä»¶éœ€è¦åˆ†æˆkå—è¯»â¼Šï¼Œéœ€è¦ä»Žâ¼©åˆ°â¼¤è¿›â¾æŽ’åºï¼š 1) ä¾æ¬¡è¯»â¼Šæ¯ä¸ªâ½‚ä»¶å—ï¼Œåœ¨å†…å­˜ä¸­å¯¹å½“å‰â½‚ä»¶å—è¿›â¾æŽ’åº(åº”â½¤æ°å½“çš„å†…æŽ’åºç®—æ³•)ã€‚æ­¤æ—¶ï¼Œæ¯å—â½‚ä»¶ç›¸å½“äºŽâ¼€ä¸ªç”±â¼©åˆ°â¼¤æŽ’åˆ—çš„æœ‰åºé˜Ÿåˆ— 2) åœ¨å†…å­˜ä¸­å»ºâ½´â¼€ä¸ªæœ€â¼©å€¼å †ï¼Œè¯»â¼Šæ¯å—â½‚ä»¶çš„é˜Ÿåˆ—å¤´ 3) å¼¹å‡ºå †é¡¶å…ƒç´ ï¼Œå¦‚æžœå…ƒç´ æ¥â¾ƒç¬¬iå—ï¼Œåˆ™ä»Žç¬¬iå—â½‚ä»¶ä¸­è¡¥å……â¼€ä¸ªå…ƒç´ åˆ°æœ€â¼©å€¼å †ã€‚å¼¹å‡ºçš„å…ƒç´ æš‚å­˜â¾„ä¸´æ—¶æ•°ç»„ 4) å½“ä¸´æ—¶æ•°ç»„å­˜æ»¡æ—¶ï¼Œå°†æ•°ç»„å†™â¾„ç£ç›˜ï¼Œå¹¶æ¸…ç©ºæ•°ç»„å†…å®¹ã€‚ 5) é‡å¤è¿‡ç¨‹3)ï¼Œ 4)ï¼Œç›´â¾„æ‰€æœ‰â½‚ä»¶å—è¯»å–å®Œæ¯• HeapMethod Add O(logN) Remove O(logNï¼‰ Min/Max O(1) Build heap O(n) Heap sort O(nlogn) Implementation left child : i*2 right chilf: i*2+1 STL std::priority_queue Example Merge K Sorted List K-th Largest Closest to Origin Binary SortOrdered linear containerRecursion start + 1 &lt; end left + (right - left) / 2 A[mid] == , &lt; , &gt; A[start/end] == target Programming Pearls A generic binary search template Scalability &amp; Memory LimitsDivide &amp; ConquerHash functionHash tableÂ©All rights reserved by lightmare.cn]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Sort</tag>
        <tag>Heapsort</tag>
        <tag>Quicksort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ é¢å‘å¯¹è±¡ç¯‡ Static members]]></title>
    <url>%2F2019%2F03%2F08%2FC-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AF%87-Static-members%2F</url>
    <content type="text"><![CDATA[In class definitionï¼šstatic Inside a class definition, the keyword static [declares] members that are not bound to class instances. Outside a class definition, it has a different meaning: see storage duration. Syntax [ declaration ]12static data_member (1) //è„±ç¦»äº†å¯¹è±¡è¿™ä¸ªæ¦‚å¿µï¼Œæ¯”å¦‚åˆ©çŽ‡ã€‚static member_function (2) //æ²¡æœ‰thisæŒ‡é’ˆï¼Œåªèƒ½å¤„ç†static æ•°æ®ã€‚ Explanation Static members of a class are [not associated] with the [objects of the class]: they are independent variables with static [or thread (since C++11) ]storage duration or regular functions. The static keyword is only used with the [declaration] of a static member, inside the class definition, Not with the [definition] of that static member: 12class X &#123; static int n; &#125;; // declaration (uses 'static')int X::n = 1; // definition (does not use 'static') The declaration inside the class body is not a definition and may declare the member to be of incomplete type (other than void), including the type in which the member is declared: 123456789101112struct Foo;struct S&#123; static int a[]; // declaration, incomplete type static Foo x; // declaration, incomplete type static S s; // declaration, incomplete type (inside its own definition)&#125;; int S::a[10]; // definition, complete typestruct Foo &#123;&#125;;Foo S::x; // definition, complete typeS S::s; // definition, complete type However, if the [declaration] uses constexpr [or inline (since C++17)] specifier, the member must be declared to have complete type.(since C++11) To refer to a static member m of class T é€šè¿‡ç±»åè°ƒç”¨ã€‚T::m é€šè¿‡é™æ€å¯¹è±¡è°ƒç”¨ã€‚[E.m] or [E-&gt;m], where E is an expression that evaluates to [T] or [T*] respectively. 1234567891011121314151617181920class Account&#123; public: static double m_rate;//declaration é™æ€æ•°æ®å˜é‡ static void set_rate(const double&amp; x)//declaration é™æ€æˆå‘˜å‡½æ•° &#123; m_rate = x; &#125;&#125;; double Account::m_rate = 8.0;// definitionint main()&#123; Account::set_rate(5.0);//é€šè¿‡ç±»åè°ƒç”¨ Account a; a.set_rate(7.0);//é€šè¿‡å¯¹è±¡è°ƒç”¨ &#125; Static members obey the class member access rules (private, protected, public). Static member functions Static member functions are not associated with any object. When called, they have [no this pointer]. Static member functions[ cannot be virtual, const, or volatile]. The address of a static member function may be stored in a regular pointer to function, but not in a pointer to member function. non-static member functionsï¼šæœ‰ä¸€ä¸ªä¸å¯ä»¥å†™å‡ºæ¥çš„éšè—å‚æ•°æŒ‡é’ˆthisï¼Œä»£è¡¨è¢«è°ƒç”¨å¯¹è±¡çš„åœ°å€ã€‚ 1234567891011class complex&#123; public: double real() const&#123;return this-&gt;re;&#125;//è¢«è°ƒç”¨å¯¹è±¡çš„åœ°å€ private: double re,im;&#125;complex c1,c2,c3;cout&lt;&lt;c1.real();cout&lt;&lt;complex::real(&amp;c1);//thisæŒ‡é’ˆ Static data members Static data members are not associated with any object. They exist even if no objects of the class have been defined. There is only one instance of the static data member in the entire program with static storage duration, unless the keyword thread_local is used, in which case there is one such object per thread with thread storage duration (since C++11). Static data members cannot be mutable.(mutable: permits modification of the class member declared mutable even if the containing object is declared const.) Static data members of a class in namespace scope have external linkage if the class itself has external linkage (i.e. is not a member of unnamed namespace). Local classes (classes defined inside functions) and unnamed classes, including member classes of unnamed classes, cannot have static data members. Constant static membersï¼ˆæ²¡æŽŒæ¡If a static data member of integral or enumeration type is declared const (and not volatile), it can be initialized with an initializer in which every expression is a constant expression, right inside the class definition: 1234567struct X&#123; const static int n = 1; const static int m&#123;2&#125;; // since C++11 const static int k;&#125;;const int X::k = 3; c++ 11If a static data member of LiteralType is declared constexpr, it must be initialized with an initializer in which every expression is a constant expression, right inside the class definition: 12345struct X &#123; constexpr static int arr[] = &#123; 1, 2, 3 &#125;; // OK constexpr static std::complex&lt;double&gt; n = &#123;1,2&#125;; // OK constexpr static int k; // Error: constexpr static requires an initializer&#125;; If a const non-inline (since C++17) static data member or a constexpr static data member (since C++11) is odr-used, a definition at namespace scope is still required, but it cannot have an initializer. This definition is deprecated forconstexpr data members (since C++17). 1234567struct X &#123; static const int n = 1; static constexpr int m = 4;&#125;;const int *p = &amp;X::n, *q = &amp;X::m; // X::n and X::m are odr-usedconst int X::n; // â€¦ so a definition is necessaryconstexpr int X::m; // â€¦ (except for X::m in C++17) to be continuedâ€¦ need to reviewâ€¦]]></content>
      <categories>
        <category>ã€ŠC++ Primerã€‹</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>OOP</tag>
        <tag>static</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ è¯­è¨€ç¯‡ Inline]]></title>
    <url>%2F2019%2F03%2F07%2FC-%E8%AF%AD%E8%A8%80%E7%AF%87-Inline%2F</url>
    <content type="text"><![CDATA[Inline1.C/C++ä¸ºäº†è§£å†³é¢‘ç¹è°ƒç”¨å°å‡½æ•°æ¶ˆè€—æ ˆç©ºé—´çš„é—®é¢˜ï¼Œå¼•å…¥å†…è”å‡½æ•°ã€‚æ ˆç©ºé—´å°±æ˜¯å­˜æ”¾å±€éƒ¨æ•°æ®çš„å†…å­˜ç©ºé—´ã€‚å¤§é‡è°ƒç”¨å‡½æ•°ä¼šé€ æˆæ ˆç©ºé—´ä¸è¶³è€Œç¨‹åºå‡ºé”™ï¼Œinlineé¿å…äº†è°ƒç”¨å‡½æ•°å¯¹æ ˆå†…å­˜é‡å¤å¼€è¾Ÿæ‰€å¸¦æ¥çš„æ¶ˆè€—ã€‚ 123456789101112131415161718192021222324include &lt;string&gt;using std::string;include &lt;iostream&gt;using std::cout; using std::endl;//inline version: find the shorter of two stringsinline const string &amp;shorterString(const string &amp;s1, const string &amp;s2)&#123; return s1.size() &lt;= s2.size() ? s1 : s2;&#125;int main()&#123; string s1("successes"), s2("failure"); cout &lt;&lt; shorterString(s1, s2) &lt;&lt; endl; // call the size member of the string returned by shorterString cout &lt;&lt; shorterString(s1, s2).size() &lt;&lt; endl; // equivalent code as generated by the call to inline version // of shorterString cout &lt;&lt; (s1.size() &lt; s2.size() ? s1 : s2) &lt;&lt; endl; return 0;&#125; 2.inlineä½¿ç”¨é™åˆ¶ï¼šåªèƒ½æ˜¯å°å‡½æ•°ï¼Œä¸èƒ½åŒ…å«å¤æ‚çš„ç»“æž„æŽ§åˆ¶è¯­å¥ï¼Œä¸èƒ½æ˜¯é€’å½’å‡½æ•°ã€‚å¦‚æžœinlineå‡½æ•°ä½“å†…ä»£ç å¤šæˆ–è€…å‡ºçŽ°å¾ªçŽ¯ï¼Œæ‰§è¡Œä»£ç çš„æ—¶é—´æ¯”å‡½æ•°è°ƒç”¨çš„å¼€é”€å¤§ï¼Œé‚£ä¹ˆå†…è”çš„æ•ˆçŽ‡å¾ˆä½Žã€‚å¦å¤–ï¼Œæ¯æ¬¡è°ƒç”¨inlineå‡½æ•°éƒ½è¦å¤åˆ¶ä»£ç ï¼Œä½¿ç¨‹åºæ€»ä»£ç é‡å¢žå¤§ï¼Œæ¶ˆè€—å†…å­˜ã€‚ 3.inlineåªæ˜¯å¯¹ç¼–è¯‘å™¨çš„å»ºè®®ï¼Œæœ€åŽæ˜¯å¦å†…è”ï¼Œçœ‹ç¼–è¯‘å™¨çš„æ„æ€ï¼Œå¦‚æžœä¸å¤æ‚å°±ä¼šåœ¨è°ƒç”¨ç‚¹å±•å¼€ï¼ŒçœŸæ­£å†…è”ã€‚å¹¶ä¸æ˜¯å£°æ˜Žäº†å†…è”å°±ä¼šå†…è”ã€‚ 4.å»ºè®®inlineå‡½æ•°çš„å®šä¹‰æ”¾åœ¨å¤´æ–‡ä»¶ä¸­ã€‚å› ä¸ºåœ¨ä¸åŒçš„å•å…ƒéƒ½ä¼šè°ƒç”¨å†…è”å‡½æ•°ï¼Œæ‰€ä»¥æ”¾åœ¨å¤´æ–‡ä»¶ä¸­æœ€åˆé€‚ã€‚å£°æ˜Žå’Œå®šä¹‰è¦ä¸€è‡´ï¼Œæœ€å¥½å®šä¹‰å’Œå£°æ˜Žæ˜¯ä¸€æ ·çš„ï¼Œå¦‚æžœä¸ä¸€æ ·ï¼Œç”±ç¼–è¯‘å™¨å†³å®šã€‚å†…è”å‡½æ•°æœ€å¥½æ”¾åœ¨æ–‡ä»¶å¤´ã€‚ 1234567891011121314151617181920212223// å¤´æ–‡ä»¶ifndef EXAMPLE_Hdefine EXAMPLE_H// åŒ…å«äºŽå¤šä¸ªæºæ–‡ä»¶çš„å‡½æ•°å¿…é¡»ä¸º inlineinline int sum(int a, int b) &#123; return a + b;&#125;endif// æºæ–‡ä»¶ #2include "example.h"int a()&#123; return sum(1, 2);&#125;// æºæ–‡ä»¶ #1include "example.h"int b()&#123; return sum(3, 4);&#125; 5.ç±»ä¸­ã€ç»“æž„ä½“ã€è”åˆä¸­å®šä¹‰çš„å‡½æ•°ï¼Œä¸ç®¡æ˜¯æˆå‘˜å‡½æ•°è¿˜æ˜¯éžæˆå‘˜çš„å‹å…ƒå‡½æ•°ï¼Œéƒ½ä¸ºéšå¼çš„inlineå‡½æ•°ï¼Œå³ç¼ºçœéƒ½æ˜¯å†…è”çš„ã€‚å¦‚æžœæœªåœ¨ç±»å†…ç»™å‡ºå®šä¹‰ï¼Œåˆæƒ³å†…è”è¯¥å‡½æ•°ï¼Œåœ¨ç±»å¤–è¦åŠ inlineã€‚ ç›´æŽ¥åœ¨ç±»å£°æ˜Žä¸­å®šä¹‰æˆå‘˜å‡½æ•°ï¼Œè™½ç„¶ä¹¦å†™æ–¹ä¾¿ï¼Œä½†æ˜¯ä¸æ˜¯å¾ˆå¥½çš„ç¼–ç¨‹é£Žæ ¼ã€‚ 1234class A&#123; public:void Foo(int x, int y) &#123; &#125; // è‡ªåŠ¨åœ°æˆä¸ºå†…è”å‡½æ•°&#125; åº”è¯¥æ”¹æˆï¼š 12345678// å¤´æ–‡ä»¶class A&#123; public: void Foo(int x, int y);&#125;// å®šä¹‰æ–‡ä»¶inline void A::Foo(int x, int y)&#123;&#125; 6.inline å¿…é¡»å’Œå‡½æ•°å®šä¹‰ä½“æ”¾åœ¨ä¸€èµ·æ‰èƒ½èµ·ä½œç”¨ï¼Œè·Ÿå£°æ˜Žæ”¾åœ¨ä¸€èµ·æ²¡æœ‰ä½œç”¨ã€‚æ‰€ä»¥inlineæ˜¯ä¸€ç§ç”¨äºŽå®žçŽ°çš„å…³é”®å­—ï¼Œè€Œä¸æ˜¯ç”¨äºŽå£°æ˜Žçš„å…³é”®å­—ã€‚å£°æ˜Žå’Œå®šä¹‰ä¸å¯ä»¥æ··ä¸ºä¸€è°ˆï¼Œç”¨æˆ·æ²¡æœ‰å¿…è¦çŸ¥é“å‡½æ•°æ˜¯å¦éœ€è¦å†…è”ã€‚ 7.ç±»çš„æž„é€ å‡½æ•°å’Œæžæž„å‡½æ•°ä¼šéšè—ä¸€äº›è¡Œä¸ºï¼Œæ¯”å¦‚æ‰§è¡Œäº†åŸºç±»æˆ–è€…æˆå‘˜å¯¹è±¡çš„æž„é€ å‡½æ•°æˆ–æžæž„å‡½æ•°ã€‚ä¸è¦å°†æž„é€ /æžæž„å‡½æ•°çš„å®šä¹‰ä½“æ”¾åœ¨å£°æ˜Žä¸­ï¼Œç¼–è¯‘å™¨ä¼šæ ¹æ®å‡½æ•°çš„å®šä¹‰ä½“ï¼Œè‡ªåŠ¨å–æ¶ˆä¸å€¼å¾—çš„å†…è”ï¼Œè¿›ä¸€æ­¥è¯´æ˜Žäº†inlineä¸åº”è¯¥åœ¨å‡½æ•°çš„å£°æ˜Žä¸­ã€‚]]></content>
      <categories>
        <category>ã€ŠC++ Primerã€‹</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>inline</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å­¦ä¹ C++ï¼Œé“é˜»ä¸”é•¿ã€‚]]></title>
    <url>%2F2019%2F03%2F03%2FC%2B%2B%E7%AC%94%E8%AE%B0%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[å°½é‡è‡ªå·±å†™ç¬”è®°ã€‚ä¸»è¦å‚è€ƒã€Šcpp primerã€‹ã€cppreference.comå’Œåšå®¢ã€‚ C++åŸºç¡€è¯­è¨€ inline cvé™å®šç¬¦ | keyword: const , mutable ç±»å¤–çš„static pointer to function | keyword: Initialized &amp; Implicit Conversion, Dereferencing, the lvalue identifying the pointed-to function,overload [c++11]range-forä¸­çš„éåŽ†å’Œä¿®æ”¹ | keyword: proxy iterators, by value, const by reference constexpr | æŒ‡å®šå˜é‡æˆ–å‡½æ•°çš„å€¼èƒ½å‡ºçŽ°åœ¨å¸¸é‡è¡¨è¾¾å¼ä¸­[c++11] é¢å‘å¯¹è±¡ç¨‹åºè®¾è®¡ OOP Static members Union | keyword: [largest data] member, implementation-defined, Member allocating, Conctors and Dectors of members, Member lifetime, Anonymous unions, Union-like classes Struct | 1.structå†…æ¯ä¸ªæˆå‘˜ç›¸å¯¹structé¦–åœ°å€çš„offsetï¼Œéƒ½æ˜¯è¯¥æˆå‘˜å¤§å°çš„æ•´æ•°å€ï¼›2.structå˜é‡çš„é¦–åœ°å€æ˜¯å†…éƒ¨æœ€å¤§æˆå‘˜çš„å€æ•°;3.sizeof(struct)ä¸ºstructæœ€å®½åŸºæœ¬ç±»åž‹æˆå‘˜å¤§å°çš„æ•´æ•°å€ã€‚ æ ‡å‡†åº“å…·åè¦æ±‚ Named requirements keyword: FunctionObject, Predicate, BinaryPredicate, Compare | å®¹å™¨åº“Container adaptors std::priority_queue | next time to complete whats the meaning of decltype..ç®—æ³•åº“ Sorting operations æŽ’åºç®—æ³•çš„æ€»ç»“ std::sort |keyword: quicksort/in-place partition/one-way/two-way/O(n) ä¸éœ€è¦é¢å¤–ç©ºé—´ std::nth_element | to be conituedâ€¦ Heap operations std::sort_heap | ç”¨stlçš„ä¼˜å…ˆé˜Ÿåˆ—å’Œçº¢é»‘æ ‘multisetå®žçŽ°ã€‚ä¸€ä¸ªimplements a max-heapçš„ä¾‹å­ã€‚ Numeric operations iota[c++11] å·¥å…·åº“ ä»¿å‡½æ•° | to be continued.. lambdaè¡¨è¾¾å¼[c++11] IOåº“ IOåº“ to be continuedâ€¦]]></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode51. N-Queens]]></title>
    <url>%2F2019%2F03%2F03%2FLeetCode51-N-Queens%2F</url>
    <content type="text"><![CDATA[The n-queens puzzle is the problem of placing n queens on an nÃ—n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queensâ€™ placement, where &#39;Q&#39; and &#39;.&#39; both indicate a queen and an empty space respectively. Example: 12345678910111213Input: 4Output: [ [".Q..", // Solution 1 "...Q", "Q...", "..Q."], ["..Q.", // Solution 2 "Q...", "...Q", ".Q.."]]Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above. å›žæº¯æ³•å°†ä¸€è¡Œstringçœ‹åšä¸€ä¸ªæŽ’åˆ—ã€‚åˆå§‹éƒ½è®¾ä¸ºâ€.â€œã€‚ç„¶åŽä»Žcol=0åŸºäºŽåˆ¤æ–­å¼€å§‹æŽ’åˆ—ã€‚åˆ¤æ–­å‡½æ•°æ˜¯ï¼ˆ1.colä¸é‡å¤ã€‚2.45Â°ä¸é‡å¤ã€‚3.135Â°ä¸é‡å¤ã€‚ï¼‰æ»¡è¶³è¿™ä¸‰ä¸ªæ¡ä»¶å°±è®¾ä¸ºâ€Qâ€ã€‚å¼€å§‹é€’å½’ã€‚é€’å½’çš„å˜é‡æ˜¯row++ã€‚é€’å½’æ¡ä»¶æ˜¯row==nã€‚ç»“æŸé€’å½’ä¹‹åŽã€‚è¦å›žæº¯ï¼Œä¿è¯å‰é¢çš„colçš„æŽ’åˆ—ä¸å˜ï¼Œéƒ½æ˜¯â€.â€ ç»†èŠ‚éªŒè¯çš„æ—¶å€™ï¼Œä¸ç”¨éªŒè¯rowä¸Šçš„Qåªæœ‰ä¸€ä¸ªã€‚å› ä¸ºé€’å½’çš„å‚æ•°æ˜¯row+1ã€‚å·²ç»ä¿è¯äº†ã€‚ Nçš‡åŽï¼šæ³¨æ„å¾ªçŽ¯æ˜¯æŒ‡æŽ’åˆ—çš„colå˜åŠ¨ï¼Œä»Ž0å¼€å§‹ï¼›é€’å½’æ˜¯æŒ‡ä¸‹ä¸€ä¸ªstringï¼Œrowçš„å˜åŠ¨ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; vector&lt;vector&lt;string&gt;&gt; ret; vector&lt;string&gt; myqueen(n,string(n,'.')); Helper(ret,myqueen,n,0); return ret; &#125; void Helper(vector&lt;vector&lt;string&gt;&gt;&amp;ret,vector&lt;string&gt; &amp;myqueen,int n,int row)&#123; if(row==n) &#123; ret.push_back(myqueen); return; &#125; for(int col=0;col&lt;n;col++)//æŽ’åºçš„æ˜¯col &#123; if(!IsValid(myqueen,n,row,col))//åŸºäºŽæ¡ä»¶å¯¹stringè¿›è¡ŒæŽ’åºã€‚colæ˜¯å˜é‡ continue; myqueen[row][col]='Q'; Helper(ret,myqueen,n,row+1);//å¾€myqueençš„ä¸‹ä¸€ä¸ªstring,æ‰€ä»¥æ˜¯row+1 myqueen[row][col]='.'; &#125; &#125; bool IsValid(vector&lt;string&gt; myqueen,int n,int row,int col)&#123; //row // for(int c = col; c &gt;=0; c--) // &#123; // if(myqueen[row][c]=='Q') // return false; // &#125; //å› ä¸ºå·²ç»Helper(row+1),æ‰€ä»¥ä¸€è¡Œä¸­åªæœ‰ä¸€ä¸ªQæ˜¯å›ºå®šäº†çš„ã€‚ //col for(int r=row;r&gt;=0;r--) &#123; if(myqueen[r][col]=='Q') return false; &#125; //45Â° for(int i=row-1,j=col-1;i&gt;=0&amp;&amp;j&gt;=0;i--,j--) &#123; if(myqueen[i][j]=='Q') return false; &#125; //135Â° for(int i=row-1,j=col+1;i&gt;=0&amp;&amp;j&lt;n;i--,j++) &#123; if(myqueen[i][j]=='Q') return false; &#125; return true; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Array</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ é¢å‘å¯¹è±¡ç¯‡ OOPæ¦‚è¿°]]></title>
    <url>%2F2019%2F02%2F25%2FC-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AF%87-OOP%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[æ¦‚è¿° ç»§æ‰¿1234567891011struct Base &#123; int a, b, c;&#125;;// æ¯ä¸ª Derived ç±»åž‹å¯¹è±¡åŒ…å« Base ä¸ºå­å¯¹è±¡struct Derived : Base &#123; int b;&#125;;// æ¯ä¸ª Derived2 ç±»åž‹å¯¹è±¡åŒ…å« Derived ä¸Ž Base ä¸ºå­å¯¹è±¡struct Derived2 : Derived &#123; int c;&#125;; ä»Žå†…å­˜çš„è§’åº¦ï¼šæ´¾ç”Ÿç±»ç»§æ‰¿äº†åŸºç±»çš„æˆå‘˜å˜é‡ï¼ˆdata)ã€‚ ä»Žå¤šæ€çš„è§’åº¦ï¼šå¯ä»¥é‡å†™åŸºç±»çš„æˆå‘˜å‡½æ•°ã€‚å‡½æ•°çš„ç»§æ‰¿æ˜¯ç»§æ‰¿çˆ¶ç±»çš„è°ƒç”¨æƒã€‚ åŸºç±»åŸºç±»çš„æˆå‘˜å‡½æ•°å®šä¹‰åŸºç±»å¿…é¡»å·²ç»å®šä¹‰ï¼Œæ‰èƒ½æ´¾ç”Ÿã€‚ non-virtual fun éžè™šå‡½æ•°ï¼šä¸å¸Œæœ›æ´¾ç”Ÿç±»é‡å†™ã€‚ virtual fun è™šå‡½æ•° ï¼šå¸Œæœ›æ´¾ç”Ÿç±»é‡å†™ã€‚ pure virtual fun çº¯è™šå‡½æ•° ï¼š æ´¾ç”Ÿç±»å¿…é¡»é‡å†™ã€‚ è™šæžæž„å‡½æ•°è™½ç„¶æžæž„å‡½æ•°æ˜¯ä¸ç»§æ‰¿çš„ï¼Œè‹¥åŸºç±»å£°æ˜Žå™¨å…¶æžæž„å‡½æ•°ä¸º virtual ï¼Œåˆ™æ´¾ç”Ÿçš„æžæž„å‡½æ•°å§‹ç»ˆè¦†å†™å®ƒã€‚ è¿™ä½¿å¾—å¯ä»¥é€šè¿‡æŒ‡å‘åŸºç±»çš„æŒ‡é’ˆ delete åŠ¨æ€åˆ†é…çš„å¤šæ€ç±»åž‹å¯¹è±¡ã€‚ 1234567891011121314151617class Base &#123; public: virtual ~Base() &#123; /* é‡Šæ”¾ Base çš„èµ„æº */ &#125;&#125;; class Derived : public Base &#123; ~Derived() &#123; /* é‡Šæ”¾ Derived çš„èµ„æº */ &#125;&#125;; int main()&#123; Base* b = new Derived; delete b; // è¿›è¡Œåˆ° Base::~Base() çš„è™šå‡½æ•°è°ƒç”¨ // å› ä¸ºå®ƒä¸ºè™šï¼Œæ•…å®ƒè°ƒç”¨ Derived::~Derived() ï¼Œ // èƒ½é‡Šæ”¾æ´¾ç”Ÿç±»çš„èµ„æºï¼Œç„¶åŽéµå¾ªé€šå¸¸æžæž„é¡ºåº // è°ƒç”¨ Base::~Base()&#125; ã€é‡è¦ï¼ã€‘ä»»ä½•åŸºç±»çš„æžæž„å‡½æ•°å¿…é¡»ä¸ºå…¬å¼€ä¸”è™špublic virtualï¼Œæˆ–protectedå—ä¿æŠ¤ä¸”éžè™š ã€‚è‹¥ç±»ä¸ºå¤šæ€ï¼ˆå£°æ˜Žæˆ–ç»§æ‰¿è‡³å°‘ä¸€ä¸ªè™šå‡½æ•°ï¼‰ï¼Œä¸”å…¶æžæž„å‡½æ•°éžè™šï¼Œä¼šå¯¼è‡´èµ„æºæ³„æ¼ã€‚å› ä¸ºæ´¾ç”Ÿç±»çš„èµ„æºæœªé‡Šæ”¾ã€‚ æ´¾ç”Ÿç±» æ´¾ç”Ÿç±»å¿…é¡»ç”¨ ï¼šæŒ‡å®šçˆ¶ç±»ã€‚ ç”¨é€—å·åˆ†å¼€ã€‚åŸºç±»å‰é¢å¯ä»¥åŠ ä¸‰ç§è®¿é—®è¯´æ˜Žç¬¦ä¹‹ä¸€ã€‚ è‹¥çœç•¥è®¿é—®è¯´æ˜Žç¬¦ ï¼Œåˆ™å®ƒå¯¹ä»¥ç±»å…³é”® struct å£°æ˜Žçš„ç±»é»˜è®¤ä¸º public ï¼Œå¯¹ä»¥ç±»å…³é”® class å£°æ˜Žçš„ç±»ä¸º private ã€‚ åˆ—äºŽ base-clause çš„ç±»æ˜¯ç›´æŽ¥åŸºç±»ï¼Œå…¶åŸºç±»æ˜¯é—´æŽ¥åŸºç±»ã€‚ åŒä¸€ç±»ä¸èƒ½æŒ‡å®šäºŽç›´æŽ¥åŸºç±»å¤šäºŽä¸€æ¬¡ï¼Œä½†åŒä¸€ç±»å¯ä»¥æ—¢æ˜¯ç›´æŽ¥åˆæ˜¯é—´æŽ¥åŸºç±»ã€‚ æ¯ä¸ªç›´æŽ¥å’Œé—´æŽ¥åŸºç±»éƒ½ä½œä¸ºåŸºç±»å­å¯¹è±¡ï¼Œä»¥å®žçŽ°å®šä¹‰çš„åç§»å­˜åœ¨äºŽæ´¾ç”Ÿç±»çš„å¯¹è±¡è¡¨ç¤ºä¸­ã€‚ å› ä¸ºç©ºåŸºç±»ä¼˜åŒ–ï¼Œç©ºåŸºç±»é€šå¸¸ä¸ä¼šå¢žåŠ æ´¾ç”Ÿç±»å¯¹è±¡çš„å¤§å°ã€‚ ç±»ä¸èƒ½æ´¾ç”Ÿè‡ªå·±ã€‚ æ´¾ç”Ÿç±»å£°æ˜Žä¸­ã€‚ä¸èƒ½åŒ…å«åŸºç±»åˆ—è¡¨ã€‚ æ´¾ç”Ÿç±»å¯ä»¥éšå¼è½¬æ¢ä¸ºåŸºç±»ã€‚ ç©ºåŸºç±»ä¼˜åŒ–ï¼ˆæœ¬èŠ‚ä¸ç†è§£å…è®¸ç©ºçš„åŸºç±»å­å¯¹è±¡å¤§å°ä¸ºé›¶ã€‚ ä¸ºä¿è¯åŒä¸€ç±»åž‹çš„ä¸åŒå¯¹è±¡åœ°å€å§‹ç»ˆæœ‰åˆ«ï¼Œè¦æ±‚ä»»ä½•å¯¹è±¡æˆ–æˆå‘˜å­å¯¹è±¡çš„å¤§å°è‡³å°‘ä¸º 1 ï¼Œå³ä½¿è¯¥ç±»åž‹æ˜¯ç©ºç±»ç±»åž‹ï¼ˆå³æ— éžé™æ€æ•°æ®æˆå‘˜çš„ class æˆ– struct ï¼‰ã€‚ ç„¶è€Œï¼ŒåŸºç±»å­å¯¹è±¡ä¸å—è¿™ç§åˆ¶çº¦ï¼Œè€Œä¸”å¯ä»¥å®Œå…¨ä»Žå¯¹è±¡å¸ƒå±€ä¸­è¢«ä¼˜åŒ–æŽ‰ï¼š 12345678910111213141516#include &lt;cassert&gt; struct Base &#123;&#125;; // ç©ºç±» struct Derived1 : Base &#123; int i;&#125;; int main()&#123; // ä»»ä½•ç©ºç±»ç±»åž‹çš„å¯¹è±¡å¤§å°è‡³å°‘ä¸º 1 assert(sizeof(Base) &gt; 0); // åº”ç”¨ç©ºåŸºä¼˜åŒ– assert(sizeof(Derived1) == sizeof(int));&#125; è‹¥ç©ºåŸºç±»ä¹‹ä¸€äº¦ä¸ºé¦–ä¸ªéžé™æ€æ•°æ®æˆå‘˜çš„ç±»åž‹æˆ–å…¶ç±»åž‹çš„åŸºç±»ï¼Œåˆ™ç¦ç”¨ç©ºåŸºä¼˜åŒ–ï¼Œå› ä¸ºè¦æ±‚åŒç±»åž‹äºŒä¸ªåŸºç±»å­å¯¹è±¡åœ¨æœ€ç»ˆæ´¾ç”Ÿç±»çš„å¯¹è±¡è¡¨ç¤ºä¸­æ‹¥æœ‰ä¸åŒåœ°å€ã€‚ è¿™ç§æƒ…å†µçš„å…¸ä¾‹æ˜¯ std::reverse_iterator çš„æœ´ç´ å®žçŽ°ï¼ˆæ´¾ç”Ÿè‡ªç©ºåŸºç±» std::iterator ï¼‰ï¼Œå®ƒä¿æœ‰åº•å±‚è¿­ä»£å™¨ï¼ˆäº¦æ´¾ç”Ÿè‡ª std::iterator ï¼‰ä¸ºå…¶é¦–ä¸ªéžé™æ€æ•°æ®æˆå‘˜ã€‚ 12345678910111213141516171819202122232425262728#include &lt;cassert&gt; struct Base &#123;&#125;; // ç©ºç±» struct Derived1 : Base &#123; int i;&#125;; struct Derived2 : Base &#123; Base c; // Base ï¼Œå ç”¨ 1 å­—èŠ‚ï¼ŒåŽéšä¸º i çš„å¡«å…… int i;&#125;; struct Derived3 : Base &#123; Derived1 c; // ä»Ž Base æ´¾ç”Ÿï¼Œå ç”¨ sizeof(int) å­—èŠ‚ int i;&#125;; int main()&#123; // ä¸åº”ç”¨ç©ºåŸºä¼˜åŒ– // åŸºç±»å ç”¨ 1 å­—èŠ‚ï¼ŒBase æˆå‘˜å ç”¨ 1 å­—èŠ‚ï¼ŒåŽéš2ä¸ªå¡«å……å­—èŠ‚ä»¥æ»¡è¶³ int å¯¹é½è¦æ±‚ assert(sizeof(Derived2) == 2*sizeof(int)); // ä¸åº”ç”¨ç©ºåŸºç±»ä¼˜åŒ–ï¼Œ // åŸºç±»å ç”¨è‡³å°‘ 1 å­—èŠ‚åŠ å¡«å……ä»¥æ»¡è¶³é¦–ä¸ªæˆå‘˜çš„å¯¹é½è¦æ±‚ï¼ˆå…¶å¯¹é½è¦æ±‚åŒ int ï¼‰ assert(sizeof(Derived3) == 3*sizeof(int));&#125; ã€C++11ã€‘ï¼šå¯¹äºŽæ ‡å‡†å¸ƒå±€ç±»åž‹ (StandardLayoutType) è¦æ±‚æœ‰ç©ºåŸºç±»ä¼˜åŒ–ï¼Œä»¥ç»´æŒæŒ‡å‘æ ‡å‡†å¸ƒå±€å¯¹è±¡çš„æŒ‡é’ˆï¼Œç”¨ reinterpret_cast è½¬æ¢åŽï¼Œè¿˜æŒ‡å‘å…¶é¦–æˆå‘˜ï¼Œè¿™æ˜¯æ ‡å‡†å¸ƒå±€ç±»åž‹â€œæ— æ‹¥æœ‰éžé™æ€æ•°æ®æˆå‘˜çš„åŸºç±»ï¼Œä¸”æ— ä¸Žå…¶é¦–ä¸ªéžé™æ€æ•°æ®æˆå‘˜åŒç±»åž‹çš„åŸºç±»â€çš„åŽŸå› ã€‚ è™šåŸºç±»ã€æ³¨æ„ã€‘å¯¹äºŽæ¯ä¸ªæŒ‡å®šä¸º virtual çš„ç›¸å¼‚åŸºç±»ï¼Œæœ€ç»ˆæ´¾ç”Ÿç±»å¯¹è±¡ä»…å«æœ‰è¯¥ç±»åž‹çš„ä¸€ä¸ªåŸºç±»å­å¯¹è±¡ï¼Œå³ä½¿è¯¥ç±»åœ¨ç»§æ‰¿å±‚çº§ä¸­å‡ºçŽ°å¤šæ¬¡ï¼ˆåªè¦å®ƒæ¯æ¬¡éƒ½ä»¥ virtual ç»§æ‰¿ï¼‰ã€‚ ä¸‹é¢çš„AAå¯¹è±¡åªæœ‰2ä¸ªBåŸºç±»å­å¯¹è±¡ï¼ŒXYå…±æœ‰ä¸€ä¸ªè™šBåŸºç±»ï¼ŒZæœ‰ä¸€ä¸ªéžè™šBåŸºç±»ã€‚ 123456789101112131415struct B &#123; int n; &#125;;class X : public virtual B &#123;&#125;;//ç›¸å¼‚åŸºç±»class Y : virtual public B &#123;&#125;;//ç›¸å¼‚åŸºç±»class Z : public B &#123;&#125;;// æ¯ä¸ª AA ç±»åž‹å¯¹è±¡æ‹¥æœ‰ä¸€ä¸ª X ï¼Œä¸€ä¸ª Y ï¼Œä¸€ä¸ª Z å’ŒäºŒä¸ª B ï¼š// å…¶ä¸€æ˜¯ Z çš„åŸºç±»ï¼Œå¦ä¸€è€…ä¸º X ä¸Ž Y æ‰€å…±äº«struct AA : X, Y, Z &#123; void f() &#123; X::n = 1; // ä¿®æ”¹è™š B åŸºç±»å­å¯¹è±¡çš„æˆå‘˜ Y::n = 2; // ä¿®æ”¹åŒä¸€è™š B åŸºç±»å­å¯¹è±¡çš„æˆå‘˜ Z::n = 3; // ä¿®æ”¹éžè™š B åŸºç±»å­å¯¹è±¡çš„æˆå‘˜ std::cout &lt;&lt; X::n &lt;&lt; Y::n &lt;&lt; Z::n &lt;&lt; '\n'; // æ‰“å° 223 &#125;&#125;; iostreamç»§æ‰¿å±‚çº§æœ‰è™šåŸºç±»çš„ä¾‹å­ä¹‹ä¸€æ˜¯æ ‡å‡†åº“çš„ iostream çš„ç»§æ‰¿å±‚çº§ï¼š std::istream ä¸Ž std::ostream ä»Ž std::ios ä½¿ç”¨è™šç»§æ‰¿æ´¾ç”Ÿã€‚ std::iostream ç»§æ‰¿ std::istream å’Œ std::ostream ï¼Œ æ•…æ¯ä¸ª std::iostream å®žä¾‹å«ä¸€ä¸ª std::ostream å­å¯¹è±¡ã€ä¸€ä¸ª std::istream å­å¯¹è±¡å’Œä»…ä¸€ä¸ª std::ios å­å¯¹è±¡ï¼ˆç»§è€Œæœ‰ä¸€ä¸ª std::ios_base ï¼‰ã€‚ ï¼ˆè¿™é‡Œä¸ç†è§£ï¼‰ æ‰€æœ‰ è™šåŸºç±»å­å¯¹è±¡ åœ¨ ä»»ä½• éžè™šåŸºç±»å­å¯¹è±¡ å‰ åˆå§‹åŒ–ï¼Œæ•… åªæœ‰ æœ€ç»ˆæ´¾ç”Ÿç±»äºŽå…¶æˆå‘˜åˆå§‹åŒ–å™¨åˆ—è¡¨è°ƒç”¨è™šåŸºç±»çš„æž„é€ å‡½æ•°ï¼š 1234567891011121314151617181920struct B &#123; int n; B(int x) : n(x) &#123;&#125;&#125;;struct X : virtual B &#123; X() : B(1) &#123;&#125; &#125;;struct Y : virtual B &#123; Y() : B(2) &#123;&#125; &#125;;struct AA : X, Y&#123; AA() : B(3),X(),Y() &#123;&#125; //é€—å·åˆ†éš”åŸºç±»åˆ—è¡¨ã€‚å‰é¢å¯ä»¥æœ‰è®¿é—®è¯´æ˜Žã€‚&#125;; // AA çš„é»˜è®¤æž„é€ å‡½æ•°è°ƒç”¨ X å’Œ Y çš„é»˜è®¤æž„é€ å‡½æ•°// ä½†è¿™äº›æž„é€ å‡½æ•°ä¸è°ƒç”¨ B çš„æž„é€ å‡½æ•°ï¼Œå› ä¸º B æ˜¯è™šåŸºç±»AA a; // a.n == 3// X çš„é»˜è®¤æž„é€ å‡½æ•°è°ƒç”¨ B çš„æž„é€ å‡½æ•°X x; // x.n == 1 æ¶‰åŠè™šç»§æ‰¿æ—¶ï¼Œç±»æˆå‘˜çš„éžé™å®šåç§°æŸ¥æ‰¾æœ‰ç‰¹æ®Šè§„åˆ™ï¼ˆæœ‰æ—¶è¢«å¼•ç”¨ä¸ºæ”¯é…è§„åˆ™ï¼‰ï¼Œè§ unqualified_lookup#æˆå‘˜å‡½æ•°å®šä¹‰ã€‚ ç»§æ‰¿æ–¹å¼ å…¬å¼€ç»§æ‰¿ publicå…¬å¼€ç»§æ‰¿æ¨¡æ‹Ÿé¢å‘å¯¹è±¡ç¼–ç¨‹çš„å­ç±»åž‹å…³ç³»ï¼šæ´¾ç”Ÿç±»å¯¹è±¡æ˜¯ï¼ˆ IS-A ï¼‰åŸºç±»å­å¯¹è±¡ã€‚æœŸå¾…æ´¾ç”Ÿç±»å¯¹è±¡çš„å¼•ç”¨å’ŒæŒ‡é’ˆï¼Œå¯ä¸ºä½¿ç”¨æœŸå¾…åˆ°å…¶ä»»ä½•åŸºç±»çš„å¼•ç”¨å’ŒæŒ‡é’ˆçš„ä»£ç æ‰€ç”¨ï¼ˆè§ LSP ï¼‰ï¼Œæˆ–è€…ä¸ºäº† DbC ï¼Œæ´¾ç”Ÿç±»åº”è¯¥ç»´æŠ¤å…¶å…¬å¼€åŸºç±»çš„ç±»ä¸å˜é‡ï¼Œä¸åº”å¼ºåŒ–ä»»ä½•å…¶æ‰€è¦†å†™çš„æˆå‘˜å‡½æ•°çš„å‰ç½®æ¡ä»¶ï¼Œæˆ–å¼±åŒ–ä»»ä½•å…¶åŽç½®æ¡ä»¶ã€‚ å—ä¿æŠ¤ç»§æ‰¿ protectedå—ä¿æŠ¤ç»§æ‰¿å¯ç”¨äºŽâ€œå—æŽ§åˆ¶çš„å¤šæ€â€ï¼šåœ¨æ´¾ç”Ÿç±»çš„æˆå‘˜ä¸­ï¼Œè¿˜æœ‰åœ¨æ‰€æœ‰è¿›ä¸€æ­¥æ´¾ç”Ÿç±»çš„æˆå‘˜ä¸­ï¼Œæ´¾ç”Ÿç±»æ˜¯ï¼ˆ IS-A ï¼‰åŸºç±»ï¼šåˆ°æ´¾ç”Ÿç±»çš„å¼•ç”¨å’ŒæŒ‡é’ˆå¯ç”¨äºŽæœŸå¾…åˆ°åŸºç±»çš„å¼•ç”¨å’ŒæŒ‡é’ˆå¤„ã€‚ ç§æœ‰ç»§æ‰¿ privateç§æœ‰ç»§æ‰¿å¸¸ç”¨äºŽåŸºäºŽç­–ç•¥çš„è®¾è®¡ï¼Œå› ä¸ºç­–ç•¥å¸¸æ˜¯ç©ºåŸºç±»ï¼Œè€Œä½¿ç”¨åŸºç±»å¯ä»¥å¯ç”¨é™å¤šæ€å¹¶æ´»ç”¨ç©ºåŸºç±»ä¼˜åŒ–. ç§æœ‰ç»§æ‰¿äº¦å¯ç”¨äºŽå®žçŽ°åˆæˆå…³ç³»ï¼ˆåŸºç±»å­å¯¹è±¡æ˜¯æ´¾ç”Ÿç±»å¯¹è±¡çš„å®žçŽ°ç»†èŠ‚ï¼‰ã€‚æˆå‘˜ä½¿ç”¨æä¾›æ›´å¥½çš„å°è£…ï¼Œè€Œä¸”é€šå¸¸å—åˆ°åå¥½ï¼Œé™¤éžæ´¾ç”Ÿç±»è¦æ±‚è®¿é—®åŸºç±»çš„å—ä¿æŠ¤æˆå‘˜ï¼ˆåŒ…å«æž„é€ å‡½æ•°ï¼‰ã€éœ€è¦è¦†å†™åŸºç±»çš„è™šæˆå‘˜ã€éœ€è¦åŸºç±»æž„é€ å…ˆäºŽæˆ–æžæž„åŽäºŽæŸå…¶ä»–åŸºç±»å­å¯¹è±¡ï¼Œéœ€è¦å…±äº«è™šåŸºç±»æˆ–éœ€è¦æŽ§åˆ¶è™šåŸºç±»çš„æž„é€ ã€‚å®žçŽ°åˆæˆçš„æˆå‘˜ä½¿ç”¨äº¦ä¸å¯åº”ç”¨äºŽä»Žå‚æ•°åŒ…å¤šé‡ç»§æ‰¿çš„æƒ…å†µï¼Œæˆ–åœ¨ç¼–è¯‘æ—¶é€šè¿‡æ¨¡æ¿å…ƒç¼–ç¨‹ç¡®å®šåŸºç±»èº«ä»½çš„æƒ…å†µã€‚ åŒå—ä¿æŠ¤ç»§æ‰¿ï¼Œç§æœ‰ç»§æ‰¿äº¦å¯ç”¨äºŽå—æŽ§åˆ¶çš„å¤šæ€ï¼šåœ¨æ´¾ç”Ÿç±»çš„æˆå‘˜å†…ï¼ˆä½†ä¸åœ¨è¿›ä¸€æ­¥æ´¾ç”Ÿç±»å†…ï¼‰ï¼Œæ´¾ç”Ÿç±»æ˜¯ï¼ˆ IS-A ï¼‰åŸºç±»ã€‚ 123456789101112131415161718192021template&lt;typename Transport&gt;class service : Transport // ä»Ž Transport ç­–ç•¥ç§æœ‰ç»§æ‰¿&#123;public: void transmit() &#123; this-&gt;send(...); // å‘é€ä¼ è¾“æ‰€æä¾›çš„ä»»ä½•å†…å®¹ &#125;&#125;;// TCP ä¼ è¾“ç­–ç•¥class tcp &#123;public: void send(...);&#125;;// UDP ä¼ è¾“ç­–ç•¥class udp &#123;public: void send(...);&#125;; service&lt;tcp&gt; service(host, port); service.transmit(...); // å‘é€å®Œæ¯• TCP æˆå‘˜åç§°æŸ¥æ‰¾ï¼ˆä¸ç†è§£ï¼‰ç±»æˆå‘˜éžé™å®šåŠé™å®šåç§°æŸ¥æ‰¾çš„è§„åˆ™è¯¦ç»†åˆ—äºŽåç§°æŸ¥æ‰¾ã€‚ C++11æ–°å¢žæ´¾ç”Ÿç±»å†…éƒ¨å¿…é¡»å¯¹æ‰€æœ‰é‡å®šä¹‰çš„è™šå‡½æ•°è¿›è¡Œå£°æ˜Žï¼Œå¯ä»¥åœ¨å‡½æ•°å‰åŠ ä¸Švirtualå…³é”®å­—ï¼Œä¹Ÿå¯ä»¥ä¸åŠ ã€‚ åªæœ‰è™šå‡½æ•°æ‰èƒ½è¢«è¦†ç›–ã€‚ç­¾åè¦åŒ¹é…ã€‚ ä¸ºäº†æ–¹ä¾¿ç¼–è¯‘å™¨æ‰¾å‡ºé”™è¯¯ã€‚C++é€šè¿‡overrideå’Œfinalæ˜¾å¼è¯´æ˜Žæ´¾ç”Ÿç±»çš„è™šå‡½æ•°ï¼Œè¿™ä¸¤ä¸ªè¯´æ˜Žç¬¦åœ¨è¯­å¥çš„æœ€åŽã€‚ overrideåœ¨æˆå‘˜å‡½æ•°å£°æ˜Žæˆ–å®šä¹‰ä¸­ï¼Œ override å¯ä»¥æ˜¾å¼åœ°æŒ‡å‡ºè¯¥å‡½æ•°ä¸ºè™šå‡½æ•°ï¼Œå¹¶è¦†å†™æ¥è‡ªåŸºç±»çš„è™šå‡½æ•°ã€‚ 12345678910111213struct A&#123; virtual void foo(); void bar();&#125;; struct B : A&#123; void foo() const override; // é”™è¯¯ï¼š B::foo ä¸è¦†å†™ A::foo // ï¼ˆç­¾åä¸åŒ¹é…ï¼‰ void foo() override; // OK ï¼š B::foo è¦†å†™ A::foo void bar() override; // é”™è¯¯ï¼š A::bar éžè™š&#125;; finalåœ¨è™šå‡½æ•°å£°æ˜Žæˆ–å®šä¹‰ä¸­ä½¿ç”¨æ—¶ï¼Œ final ç¡®ä¿å‡½æ•°ä¸ºè™šï¼Œä¸”ä¸å¯è¢«æ´¾ç”Ÿç±»è¦†å†™ã€‚ final äº¦å¯ç”¨äºŽè”åˆä½“å®šä¹‰ï¼Œæ­¤æƒ…å†µä¸‹å®ƒæ— æ•ˆï¼ˆé™¤äº† std::is_final ä¸Šçš„ç»“æžœï¼‰ï¼Œå› ä¸ºä¸èƒ½æ´¾ç”Ÿè”åˆä½“ã€‚final æ˜¯åœ¨ç”¨äºŽæˆå‘˜å‡½æ•°å£°æ˜Žæˆ–ç±»å¤´éƒ¨æ—¶æœ‰ç‰¹æ®Šå«ä¹‰çš„æ ‡è¯†ç¬¦ã€‚å…¶ä»–è¯­å¢ƒä¸­å®ƒéžä¿ç•™è€Œä¸”å¯ç”¨äºŽå‘½åå¯¹è±¡æˆ–å‡½æ•°ã€‚ 12345678910111213141516171819struct Base&#123; virtual void foo();&#125;; struct A : Base&#123; void foo() final; // A::foo è¢«è¦†å†™ä¸”æ˜¯æœ€ç»ˆè¦†å†™ void bar() final; // é”™è¯¯ï¼šéžè™šå‡½æ•°ä¸èƒ½è¢«è¦†å†™æˆ–æ˜¯ final&#125;; struct B final : A // struct B ä¸º final&#123; void foo() override; // é”™è¯¯ï¼š foo ä¸èƒ½è¢«è¦†å†™ï¼Œå› ä¸ºå®ƒåœ¨ A ä¸­æ˜¯ final&#125;; struct C : B // é”™è¯¯ï¼š B ä¸º final&#123;&#125;; åŠ¨æ€ç»‘å®š(éžå¸¸é‡è¦ï¼‰ä½¿ç”¨åŸºç±»çš„å¼•ç”¨æˆ–æŒ‡é’ˆï¼Œè°ƒç”¨ä¸€ä¸ªè™šå‡½æ•°ï¼Œè™šå‡½æ•°è¿è¡Œæ—¶ï¼Œå½¢å‚çš„ç‰ˆæœ¬ç”±å®žå‚å¯¹è±¡çš„ç±»åž‹å†³å®šã€‚ C++ OOPçš„å…³é”®ï¼šåŸºç±»å’Œæ´¾ç”Ÿç±»ä¹‹é—´çš„ç±»åž‹è½¬æ¢ã€‚ å¯¹è±¡æ¨¡åž‹ï¼šè™šè¡¨å’Œè™šæŒ‡é’ˆ å‡½æ•°ä¹Ÿå å†…å­˜ï¼Œä¹Ÿæœ‰åœ°å€ã€‚è™šå‡½æ•°æ‰æœ‰è™šæŒ‡é’ˆï¼Œè™šå‡½æ•°è¡¨ï¼ˆé‡Œé¢éƒ½æ˜¯æŒ‡å‘å‡½æ•°çš„æŒ‡é’ˆã€‚ cè°ƒç”¨ï¼š é™æ€ç»‘å®š call+åœ°å€ã€‚c++è°ƒç”¨ï¼šåŠ¨æ€ç»‘å®šã€‚æŒ‡å‘Cçš„æŒ‡é’ˆpæƒ³è°ƒç”¨è™šå‡½æ•°v1ï¼ˆåŠ¨æ€ç»‘å®šï¼‰é€šè¿‡æŒ‡é’ˆæ‰¾åˆ°vptrè™šæŒ‡é’ˆï¼Œæ‰¾åˆ°vtblè™šå‡½æ•°è¡¨ï¼Œå¾—åˆ°è¦è°ƒç”¨çš„å‡½æ•°åœ°å€ã€‚ p-&gt;vptr[n]æ˜¯cè¯­è¨€çš„æè¿°ï¼Œnæ˜¯è™šå‡½æ•°åœ¨vtblä¸­çš„ç¬¬å‡ ä¸ªä½ç½®ã€‚ç¼–è¯‘å™¨åœ¨ç¼–è¯‘çš„æ—¶å€™çœ‹vfunæ˜¯ç¬¬å‡ ä¸ªå‡ºçŽ°çš„ï¼Œå°±ç¡®å®šäº†nçš„å€¼ã€‚ ç±»çš„å†…å­˜ï¼šçˆ¶ç±»æ•°æ®+è‡ªå·±æ•°æ®+1ä¸ªæˆ–0ä¸ªè™šæŒ‡é’ˆã€‚ å®¹å™¨é‡Œè£…çš„ä¸€å®šæ˜¯ä¸€ä¸ªæŒ‡å‘çˆ¶ç±»çš„æŒ‡é’ˆã€‚list&lt;A*&gt;ï¼Œå› ä¸ºæ²¡æ³•ç¡®å®šå½¢çŠ¶çš„å¤§å°æ‰€ä»¥æ˜¯æŒ‡é’ˆï¼Œè€Œä¸”å¿…é¡»å¾—æ˜¯çˆ¶ç±»ã€‚ åªæœ‰è™šå‡½æ•°æ‰èƒ½è¢«overrideï¼ˆc++)ã€‚ä¸ç”¨åƒcé‚£æ ·åŽ»åˆ¤æ–­ç±»åž‹ã€‚å› ä¸ºçˆ¶ç±»å¯èƒ½åŠ æ–°çš„å­ç±»ã€‚ ##åŠ¨æ€ç»‘å®šçš„ä¸‰ä¸ªæ¡ä»¶ é€šè¿‡æŒ‡é’ˆæˆ–å¼•ç”¨è°ƒç”¨ã€‚ æŒ‡é’ˆå¿…é¡»å‘ä¸Šè½¬åž‹ã€‚ç”±å­ç±»è½¬å‘çˆ¶ç±»ã€‚ è°ƒç”¨çš„æ˜¯è™šå‡½æ•°ã€‚ static typeå’Œdynamic typeåŒºåˆ« é™æ€ç±»åž‹åœ¨ç¼–è¯‘æ—¶å°±è¢«ç¡®å®šäº†ã€‚å®ƒæ˜¯ã€å˜é‡å£°æ˜Žæ—¶çš„ç±»åž‹ã€‘ æˆ–ã€è¡¨è¾¾å¼ç”Ÿæˆçš„ç±»åž‹ã€‘ã€‚ åŠ¨æ€ç±»åž‹åœ¨è¿è¡Œæ—¶æ‰çŸ¥é“ã€‚å®ƒæ˜¯ã€å˜é‡æˆ–è¡¨è¾¾å¼ä»£è¡¨çš„å†…å­˜ä¸­çš„å¯¹è±¡çš„ç±»åž‹ã€‘ã€‚ å…³äºŽthis thisæ˜¯ä¸ªæŒ‡é’ˆã€‚ä¹Ÿå¯ä»¥è¯´thisæŒ‡çš„é‚£ä¸ªobjectã€‚ main(){derivedclass object;object.func();}ç›¸å½“äºŽè°ƒç”¨baseclass::func(&amp;object);&amp;objectå°±æ˜¯thisï¼Œé€šå¸¸ä¸å†™ã€‚ ç±»åž‹è½¬æ¢åªæœ‰åœ¨æŒ‡é’ˆå’Œå¼•ç”¨ä¹‹é—´æ‰æœ‰ç±»åž‹è½¬æ¢ã€‚åœ¨å¯¹è±¡ä¹‹é—´æ²¡æœ‰ç±»åž‹è½¬æ¢ã€‚ è™šæˆå‘˜ã€è™šå‡½æ•°å®šä¹‰ åŸºç±»å¸Œæœ›è¯¥æˆå‘˜åœ¨æ´¾ç”Ÿç±»ä¸­é‡æ–°å®šä¹‰ï¼Œé™¤äº†æž„é€ å‡½æ•°å’Œé™æ€æˆå‘˜ï¼Œç±»ä¸­ä»»ä½•æˆå‘˜éƒ½å¯ä»¥è¢«virtualå£°æ˜Žä¸ºè™šæˆå‘˜ã€‚ è¯¥å‡½æ•°åœ¨æ´¾ç”Ÿç±»ä¸­éšå¼çš„ä¹Ÿæ˜¯è™šå‡½æ•°ã€‚ è°ƒç”¨ï¼ˆé‡è¦ï¼‰è‹¥ä½¿ç”¨åˆ°åŸºç±»çš„æŒ‡é’ˆæˆ–å¼•ç”¨å¤„ç†æ´¾ç”Ÿç±»ï¼Œåˆ™å¯¹è¢«è¦†å†™è™šå‡½æ•°çš„è°ƒç”¨ï¼Œå°†ä¼šè°ƒç”¨å®šä¹‰äºŽæ´¾ç”Ÿç±»çš„è¡Œä¸ºã€‚ è‹¥ä½¿ç”¨æœ‰é™å®šåç§°æŸ¥æ‰¾ï¼ˆä½œç”¨åŸŸè§£å†³è¿ç®—ç¬¦ :: ï¼‰ï¼Œè°ƒç”¨ä½œç”¨åŸŸå†…éƒ¨çš„éžè™šå‡½æ•°ã€‚ 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;struct Base &#123; virtual void f() &#123; std::cout &lt;&lt; "base\n"; &#125;&#125;;struct Derived : Base &#123; void f() override &#123; // 'override' å¯é€‰ std::cout &lt;&lt; "derived\n"; &#125;&#125;;int main()&#123; Base b; Derived d; // é€šè¿‡å¼•ç”¨è°ƒç”¨è™šå‡½æ•° Base&amp; br = b; // br çš„ç±»åž‹æ˜¯ Base&amp; Base&amp; dr = d; // dr çš„ç±»åž‹ä¹Ÿæ˜¯ Base&amp; br.f(); // æ‰“å° "base" dr.f(); // æ‰“å° "derived" // é€šè¿‡æŒ‡é’ˆè°ƒç”¨è™šå‡½æ•° Base* bp = &amp;b; // bp çš„ç±»åž‹æ˜¯ Base* Base* dp = &amp;d; // dp çš„ç±»åž‹ä¹Ÿæ˜¯ Base* bp-&gt;f(); // æ‰“å° "base" dp-&gt;f(); // æ‰“å° "derived" // éžè™šå‡½æ•°è°ƒç”¨ br.Base::f(); // æ‰“å° "base" dr.Base::f(); // æ‰“å° "base"&#125; è¦†å†™ï¼ˆé‡è¦ï¼‰è‹¥æŸæˆå‘˜å‡½æ•° vf åœ¨ç±» Base ä¸­å£°æ˜Žä¸º virtual ï¼Œä¸”æŸä¸ªç›´æŽ¥æˆ–é—´æŽ¥ä»Ž Base æ´¾ç”Ÿçš„ç±» Derived æ‹¥æœ‰ä¸‹åˆ—å‡ ç‚¹ä¸Žä¹‹ç›¸åŒçš„æˆå‘˜å‡½æ•°å£°æ˜Ž åç§° å‚æ•°åˆ—è¡¨ï¼ˆä½†éžè¿”å›žç±»åž‹ï¼‰ cv é™å®šç¬¦ å¼•ç”¨é™å®šç¬¦ åˆ™ç±» Derived ä¸­çš„æ­¤å‡½æ•°äº¦ä¸ºè™šï¼ˆæ— è®ºæ˜¯å¦äºŽå…¶å£°æ˜Žä½¿ç”¨å…³é”®è¯ virtual ï¼‰å¹¶è¦†å†™ Base::vf ï¼ˆæ— è®ºæ˜¯å¦äºŽå…¶å£°æ˜Žä½¿ç”¨è¯ overrideï¼‰ã€‚ è¦è¦†å†™çš„ Base::vf ä¸éœ€è¦å¯è§ï¼ˆå¯å£°æ˜Žä¸º private ï¼Œæˆ–ç”¨ç§æœ‰ç»§æ‰¿ç»§æ‰¿ï¼‰ã€‚ 123456789101112131415class B &#123; virtual void do_f(); // ç§æœ‰æˆå‘˜ public: void f() &#123; do_f(); &#125; // å…¬å¼€ç»§æ‰¿&#125;;struct D : public B &#123; void do_f() override; // è¦†å†™ B::do_f&#125;; int main()&#123; D d; B* bp = &amp;d; bp-&gt;f(); // å†…éƒ¨è°ƒç”¨ D::do_f();&#125; å¯¹äºŽæ¯ä¸ªè™šå‡½æ•°ï¼Œå­˜åœ¨æœ€ç»ˆè¦†å†™è€…ï¼Œå®ƒåœ¨è™šå‡½æ•°è°ƒç”¨è¿›è¡Œæ—¶æ‰§è¡Œã€‚åŸºç±» Base è™šæˆå‘˜å‡½æ•° vf æ˜¯æœ€ç»ˆè¦†å†™è€…ï¼Œé™¤éžæ´¾ç”Ÿç±»å£°æ˜Žæˆ–ç»§æ‰¿ï¼ˆé€šè¿‡å¤šé‡ç»§æ‰¿ï¼‰å¦ä¸€è¦†å†™ vf çš„å‡½æ•°ã€‚ 123456789101112struct A &#123; virtual void f(); &#125;; // A::f ä¸º virtualstruct B : A &#123; void f(); &#125;; // B::f è¦†å†™ A::f in Bstruct C : virtual B &#123; void f(); &#125;; // C::f è¦†å†™ A::f in Cstruct D : virtual B &#123;&#125;; // D ä¸å¼•å…¥è¦†å†™è€…ï¼Œ B::f åœ¨ D ä¸­ä¸ºæœ€ç»ˆstruct E : C, D &#123; // E ä¸å¼•å…¥è¦†å†™è€…ï¼Œ C::f åœ¨ E ä¸­ä¸ºæœ€ç»ˆ using A::f; // éžå‡½æ•°å£°æ˜Žï¼Œä»…ä»¤ A::f èƒ½ä¸ºæŸ¥æ‰¾æ‰€è§&#125;;int main() &#123; E e; e.f(); // è™šè°ƒç”¨è°ƒç”¨ C::f ï¼Œ e ä¸­çš„æœ€ç»ˆè¦†å†™è€… e.E::f(); // éžè™šè°ƒç”¨è°ƒç”¨ A::f ï¼Œå®ƒåœ¨ E ä¸­å¯è§&#125; è™šå‡½æ•°åªèƒ½æœ‰ä¸€ä¸ªæœ€ç»ˆè¦†å†™è€…ï¼š 12345678910111213141516171819struct A &#123; virtual void f();&#125;;struct VB1 : virtual A &#123; void f(); // è¦†å†™ A::f&#125;;struct VB2 : virtual A &#123; void f(); // è¦†å†™ A::f&#125;;// struct Error : VB1, VB2 &#123;// // é”™è¯¯ï¼š A::f åœ¨ Error ä¸­æ‹¥æœ‰äºŒä¸ªæœ€ç»ˆè¦†å†™è€…// &#125;;struct Okay : VB1, VB2 &#123; void f(); // OK ï¼šè¿™æ˜¯ A::f çš„æœ€ç»ˆè¦†å†™è€…&#125;;struct VB1a : virtual A &#123;&#125;; // ä¸å£°æ˜Žè¦†å†™è€…struct Da : VB1a, VB2 &#123; // Da ä¸­ï¼Œ A::f çš„æœ€ç»ˆè¦†å†™è€…æ˜¯ VB2::f&#125;; æ‹¥æœ‰åŒåå’Œç›¸å¼‚å‚æ•°åˆ—è¡¨çš„å‡½æ•°ä¸è¦†å†™åŒåçš„åŸºç±»å‡½æ•°ï¼Œä½†éšè—å®ƒï¼šåœ¨éžé™å®šåç§°æŸ¥æ‰¾æ£€éªŒæ´¾ç”Ÿç±»çš„ä½œç”¨åŸŸæ—¶ï¼ŒæŸ¥æ‰¾æ‰¾åˆ°è¯¥å£°æ˜Žï¼Œä¸”ä¸æ£€éªŒåŸºç±»ã€‚ 1234567891011121314151617181920212223struct B &#123; virtual void f();&#125;;struct D : B &#123; void f(int); // D::f éšè— B::f ï¼ˆé”™è¯¯çš„å‚æ•°åˆ—è¡¨ï¼‰&#125;;struct D2 : D &#123; void f(); // D2::f è¦†å†™ B::f ï¼ˆå®ƒä¸å¯è§æ˜¯ä¸è¦ç´§çš„ï¼‰&#125;; int main()&#123; B b; B&amp; b_as_b = b; D d; B&amp; d_as_b = d; D&amp; d_as_d = d; D2 d2; B&amp; d2_as_b = d2; D&amp; d2_as_d = d2; b_as_b.f(); // è°ƒç”¨ B::f() d_as_b.f(); // è°ƒç”¨ B::f() d2_as_b.f(); // è°ƒç”¨ D2::f() d_as_d.f(); // é”™è¯¯ï¼š D ä¸­çš„æŸ¥æ‰¾åªæ‰¾åˆ° f(int) d2_as_d.f(); // é”™è¯¯ï¼š D ä¸­çš„æŸ¥æ‰¾åªæ‰¾åˆ° f(int)&#125; éžæˆå‘˜å‡½æ•°å’Œé™æ€æˆå‘˜å‡½æ•°ä¸èƒ½ä¸ºè™šã€‚ å‡½æ•°æ¨¡æ¿ä¸èƒ½ä¸ºè™š virtual ã€‚è¿™åªåº”ç”¨äºŽè‡ªèº«æ˜¯æ¨¡æ¿çš„å‡½æ•°â€”â€”ç±»æ¨¡æ¿çš„å¸¸è§„æˆå‘˜å‡½æ•°èƒ½å£°æ˜Žä¸ºè™šã€‚ åœ¨ç¼–è¯‘æ—¶æ›¿æ¢è™šå‡½æ•°çš„é»˜è®¤å®žå‚ã€‚ åå˜è¿”å›žç±»åž‹è‹¥å‡½æ•° Derived::f è¦†å†™ Base::f ï¼Œåˆ™å…¶è¿”å›žç±»åž‹å¿…é¡»ç›¸åŒæˆ–ä¸ºåå˜ã€‚è‹¥æ»¡è¶³æ‰€æœ‰ä¸‹åˆ—è¦æ±‚ï¼Œåˆ™äºŒä¸ªç±»åž‹ä¸ºåå˜ï¼š äºŒä¸ªç±»åž‹å‡ä¸ºåˆ°ç±»çš„æŒ‡é’ˆæˆ–å¼•ç”¨ï¼ˆå·¦å€¼æˆ–å³å€¼ï¼‰ã€‚ä¸å…è®¸å¤šçº§æŒ‡é’ˆæˆ–å¼•ç”¨ã€‚ Base::f() çš„è¿”å›žç±»åž‹ä¸­è¢«å¼•ç”¨/æŒ‡å‘çš„ç±»ï¼Œå¿…é¡»æ˜¯ Derived::f() çš„è¿”å›žç±»åž‹ä¸­è¢«å¼•ç”¨/æŒ‡å‘çš„ç±»çš„æ— æ­§ä¹‰ä¸”å¯ç›´æŽ¥æˆ–é—´æŽ¥è®¿é—®çš„åŸºç±»ã€‚ Derived::f() çš„è¿”å›žç±»åž‹å¿…é¡»æœ‰ç›¸å¯¹äºŽ Base::f() çš„è¿”å›žç±»åž‹çš„ç›¸ç­‰æˆ–è¾ƒå°‘çš„ cv é™å®šã€‚ Derived::f çš„è¿”å›žç±»åž‹ä¸­çš„ç±»å¿…é¡»æ˜¯ Derived è‡ªèº«ï¼Œæˆ–å¿…é¡»æ˜¯äºŽ Derived::f å£°æ˜Žç‚¹çš„å®Œæ•´ç±»åž‹ã€‚ è¿›è¡Œè™šå‡½æ•°è°ƒç”¨æ—¶ï¼Œæœ€ç»ˆè¦†å†™è€…çš„è¿”å›žç±»åž‹è¢«éšå¼è½¬æ¢æˆæœ¬è¯¥è°ƒç”¨çš„è¢«è¦†å†™å‡½æ•°çš„è¿”å›žç±»åž‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738class B &#123;&#125;; struct Base &#123; virtual void vf1(); virtual void vf2(); virtual void vf3(); virtual B* vf4(); virtual B* vf5();&#125;; class D : private B &#123; friend struct Derived; // Derived ä¸­ï¼Œ B æ˜¯ D çš„å¯è®¿é—®åŸºç±»&#125;; class A; // å‰ç½®å£°æ˜Žç±»æ˜¯ä¸å®Œæ•´ç±»åž‹ struct Derived : public Base &#123; void vf1(); // è™šï¼Œè¦†å†™ Base::vf1() void vf2(int); // éžè™šï¼Œéšè— Base::vf2()// char vf3(); // é”™è¯¯ï¼šè¦†å†™ Base::vf3 ï¼Œä½†æœ‰ç›¸å¼‚è€Œéžåå˜è¿”å›žç±»åž‹ D* vf4(); // è¦†å†™ Base::vf4() å¹¶ç”¨æœ‰åå˜è¿”å›žç±»åž‹// A* vf5(); // é”™è¯¯ï¼š A æ˜¯ä¸å®Œæ•´ç±»åž‹&#125;; int main()&#123; Derived d; Base&amp; br = d; Derived&amp; dr = d; br.vf1(); // è°ƒç”¨ Derived::vf1() br.vf2(); // è°ƒç”¨ Base::vf2()// dr.vf2(); // é”™è¯¯ï¼š vf2(int) éšè— vf2() B* p = br.vf4(); // è°ƒç”¨ Derived::vf4() å¹¶è½¬æ¢ç»“æžœä¸º B* D* q = dr.vf4(); // è°ƒç”¨ Derived::vf4() å¹¶ä¸è½¬æ¢ç»“æžœä¸º B* &#125; åœ¨æž„é€ ä¸Žæžæž„æœŸé—´ æ´¾ç”Ÿç±»æž„é€ å‡½æ•°ã€‚é¦–å…ˆåˆå§‹åŒ–åŸºç±»çš„éƒ¨åˆ†ã€‚å†æŒ‰ç…§å£°æ˜Žçš„é¡ºåºä¾æ¬¡åˆå§‹åŒ–æ´¾ç”Ÿç±»çš„æˆå‘˜ã€‚ æ¯ä¸ªç±»æŽ§åˆ¶å®ƒè‡ªå·±çš„æˆå‘˜åˆå§‹åŒ–è¿‡ç¨‹ã€‚ï¼ˆå…³é”®;è¦æƒ³ä¸Žç±»çš„å¯¹è±¡äº¤äº’ã€‚å¿…é¡»ä½¿ç”¨è¯¥ç±»çš„æŽ¥å£ã€‚ï¼‰ å½“ç›´æŽ¥æˆ–é—´æŽ¥ä»Žæž„é€ å‡½æ•°æˆ–ä»Žæžæž„å‡½æ•°è°ƒç”¨è™šå‡½æ•°ï¼ˆåŒ…å«åœ¨ç±»çš„éžé™æ€æˆå‘˜å‡½æ•°çš„æž„é€ æˆ–æžæž„æœŸé—´ï¼Œä¾‹å¦‚åœ¨åˆå§‹åŒ–å™¨åˆ—è¡¨ä¸­ï¼‰ï¼Œä¸”åº”ç”¨è°ƒç”¨çš„å¯¹è±¡æ˜¯æ­£åœ¨æž„é€ æˆ–æžæž„ä¸­çš„å¯¹è±¡ï¼Œåˆ™æ‰€è°ƒç”¨çš„å‡½æ•°æ˜¯æž„é€ å‡½æ•°æˆ–æžæž„å‡½æ•°çš„ç±»ä¸­çš„æœ€ç»ˆè¦†å†™è€…ï¼Œè€Œéžè¿›ä¸€æ­¥æ´¾ç”Ÿç±»ä¸­çš„è¦†å†™è€…ã€‚ æ¢è¨€ä¹‹ï¼Œåœ¨æž„é€ å’Œæžæž„æœŸé—´ï¼Œè¿›ä¸€æ­¥æ´¾ç”Ÿç±»ä¸å­˜åœ¨ã€‚ æž„å»ºæœ‰å¤šåˆ†æ”¯çš„å¤æ‚ç±»æ—¶ï¼Œåœ¨å±žäºŽä¸€ä¸ªåˆ†æ”¯çš„æž„é€ å‡½æ•°å†…ï¼Œå¤šæ€è¢«é™åˆ¶åˆ°è¯¥ç±»ä¸Žå…¶åŸºç±»ï¼šè‹¥å®ƒèŽ·å¾—åˆ°å…¶å­å±‚çº§å¤–çš„åŸºç±»å­å¯¹è±¡çš„æŒ‡é’ˆï¼Œä¸”è¯•å›¾è¿›è¡Œè™šå‡½æ•°è°ƒç”¨ï¼ˆä¾‹å¦‚é€šè¿‡æ˜¾å¼æˆå‘˜è®¿é—®ï¼‰ï¼Œåˆ™è¡Œä¸ºæœªå®šä¹‰ï¼š 12345678910111213141516171819202122232425262728293031323334353637struct V &#123; virtual void f(); virtual void g();&#125;; struct A : virtual V &#123; virtual void f(); // A::f æ˜¯ V::f åœ¨ A ä¸­çš„æœ€ç»ˆè¦†å†™è€…&#125;;struct B : virtual V &#123; virtual void g(); // B::g æ˜¯ V::g åœ¨ B ä¸­çš„æœ€ç»ˆè¦†å†™è€… B(V*, A*);&#125;;struct D : A, B &#123; virtual void f(); // D::f æ˜¯ V::f åœ¨ D ä¸­çš„æœ€ç»ˆè¦†å†™è€… virtual void g(); // D::g æ˜¯ V::g åœ¨ D ä¸­çš„æœ€ç»ˆè¦†å†™è€… // æ³¨æ„ï¼š A åˆå§‹åŒ–å…ˆäºŽ B D() : B((A*)this, this) &#123; &#125;&#125;; // B çš„æž„é€ å‡½æ•°ï¼Œä»Ž D çš„æž„é€ å‡½æ•°è°ƒç”¨ B::B(V* v, A* a)&#123; f(); // å¯¹ V::f çš„è™šè°ƒç”¨ï¼ˆå°½ç®¡ D æ‹¥æœ‰æœ€ç»ˆè¦†å†™è€…ï¼Œ D ä¹Ÿä¸å­˜åœ¨ï¼‰ g(); // å¯¹ B::g çš„è™šè°ƒç”¨ï¼Œåœ¨ B ä¸­æ˜¯æœ€ç»ˆè¦†å†™è€… v-&gt;g(); // v çš„ç±»åž‹ V æ˜¯ B çš„åŸºç±»ï¼Œè™šè°ƒç”¨å¦‚å‰è°ƒç”¨ B::g a-&gt;f(); // a çš„ç±»åž‹ A ä¸æ˜¯ B çš„åŸºç±»ï¼Œå®ƒå±žäºŽå±‚çº§ä¸­çš„ä¸åŒåˆ†æ”¯ã€‚ // å°è¯•é€šè¿‡ä¸åŒåˆ†æ”¯çš„è™šè°ƒç”¨å¯¼è‡´æœªå®šä¹‰è¡Œä¸ºï¼Œ // å³ä½¿æ­¤æƒ…å†µä¸‹ A å·²å®Œå…¨æž„é€  // ï¼ˆå®ƒåœ¨ B å‰æž„é€ ï¼Œå› ä¸ºå®ƒåœ¨ D çš„åŸºç±»åˆ—è¡¨ä¸­å‡ºçŽ°å…ˆäºŽ B ï¼‰ // å®žè·µä¸­ï¼Œå¯¹ A::f çš„è™šè°ƒç”¨ä¼šè¯•å›¾ä½¿ç”¨ B çš„è™šæˆå‘˜å‡½æ•°è¡¨ï¼Œ // å› ä¸ºå®ƒåœ¨ B çš„æž„é€ ä¸­æ´»è·ƒ&#125; æŠ½è±¡ç±» ä¸Ž çº¯è™šç±»å®šä¹‰ä¸èƒ½è¢«å®žä¾‹åŒ–ï¼Œä½†èƒ½ç”¨ä½œåŸºç±»çš„æŠ½è±¡ç±»åž‹ã€‚ çº¯è™š (pure virtual) å‡½æ•°çº¯è™š (pure virtual) å‡½æ•°æ˜¯å£°æ˜Žå™¨æ‹¥æœ‰ä¸‹åˆ—è¯­æ³•çš„è™šå‡½æ•°ï¼š æ­¤å¤„åºåˆ— **= 0** è¢«ç§°ä½œ pure-specifier ï¼Œä¸”ç«‹å³å‡ºçŽ°äºŽ declarator åŽæˆ–äºŽå¯é€‰çš„ virt-specifier ï¼ˆ override æˆ– final ï¼‰åŽã€‚ pure-specifier ä¸èƒ½å‡ºçŽ°äºŽæˆå‘˜å‡½æ•°å®šä¹‰ä¸­ã€‚ 123456789struct Base &#123; virtual int g(); virtual ~Base() &#123;&#125; &#125;;struct A : Base&#123; // OK ï¼šå£°æ˜Žä¸‰ä¸ªæˆå‘˜è™šå‡½æ•°ï¼Œå…¶äºŒä¸ºçº¯ virtual int f() = 0, g() override = 0, h(); // OK ï¼šæžæž„å‡½æ•°äº¦èƒ½ä¸ºçº¯ ~A() = 0; // é”™è¯¯ï¼šçº¯æŒ‡å®šç¬¦åœ¨å‡½æ•°å®šä¹‰ä¸Š virtual int b()=0 &#123;&#125;&#125;; abstract class æ˜¯å®šä¹‰æˆ–ç»§æ‰¿äº†è‡³å°‘ä¸€ä¸ªæœ€ç»ˆè¦†å†™ä¸º pure virtual çš„å‡½æ•°çš„ç±»ã€‚ æŠ½è±¡ç±»ç”¨äºŽè¡¨ç¤ºé€šç”¨æ¦‚å¿µï¼ˆä¾‹å¦‚ Shape ã€ Animal ï¼‰ï¼Œå®ƒå¯ç”¨ä½œå…·ä½“ç±»ï¼ˆä¾‹å¦‚ Circle ã€ Dog ï¼‰çš„åŸºç±»ã€‚ ä¸èƒ½åˆ›å»ºæŠ½è±¡ç±»çš„å®žä¾‹ã€‚æŠ½è±¡ç±»åž‹ä¸èƒ½ç”¨ä½œå‚æ•°ç±»åž‹ã€å‡½æ•°è¿”å›žç±»åž‹æˆ–æ˜¾å¼è½¬æ¢çš„ç±»åž‹ã€‚å¯ä»¥å£°æ˜Žåˆ°æŠ½è±¡ç±»çš„æŒ‡é’ˆæˆ–å¼•ç”¨ã€‚ 123456789101112131415161718192021struct Abstract &#123; virtual void f() = 0; // çº¯è™š&#125;; // "Abstract" ä¸ºæŠ½è±¡ struct Concrete : Abstract &#123; void f() override &#123;&#125; // éžçº¯è™š virtual void g(); // éžçº¯è™š&#125;; // "Concrete" ä¸ºéžæŠ½è±¡ struct Abstract2 : Concrete &#123; void g() override = 0; // çº¯è™šè¦†å†™&#125;; // "Abstract2" ä¸ºæŠ½è±¡ int main()&#123; // Abstract a; // é”™è¯¯ï¼šæŠ½è±¡ç±» Concrete b; // OK Abstract&amp; a = b; // OK ï¼šåˆ°æŠ½è±¡åŸºç±»çš„å¼•ç”¨ a.f(); // åˆ° Concrete::f() çš„è™šæ´¾å‘ // Abstract2 a2; // é”™è¯¯ï¼šæŠ½è±¡ç±»ï¼ˆ g() çš„æœ€ç»ˆè¦†å†™ä¸ºçº¯ï¼‰&#125; å¯ä»¥æä¾›çº¯è™šå‡½æ•°çš„å®šä¹‰ï¼ˆè€Œä¸”è‹¥æžæž„å‡½æ•°ä¸ºçº¯è™šåˆ™å¿…é¡»æä¾›ï¼‰ï¼šå¯¼å‡ºç±»çš„æˆå‘˜å‡½æ•°å¯ä»¥è‡ªç”±åœ°ç”¨æœ‰é™å®šå‡½æ•° id è°ƒç”¨è™šåŸºç±»çš„çº¯è™šå‡½æ•°ã€‚æ­¤å®šä¹‰å¿…é¡»åœ¨ç±»ä½“å¤–ï¼ˆå‡½æ•°å£°æ˜Žçš„è¯­æ³•ä¸å…è®¸çº¯è™šæŒ‡å®šç¬¦ **= 0** å’Œå‡½æ•°ä½“ä¸€èµ·å‡ºçŽ°ï¼‰ã€‚ ä»ŽæŠ½è±¡ç±»çš„æž„é€ å‡½æ•°æˆ–æžæž„å‡½æ•°è¿›è¡Œçº¯è™šå‡½æ•°çš„è™šè°ƒç”¨æ˜¯æœªå®šä¹‰è¡Œä¸ºï¼ˆæ— è®ºçº¯è™šå‡½æ•°æ˜¯å¦æ‹¥æœ‰å®šä¹‰ï¼‰ã€‚ 1234567891011121314151617181920212223struct Abstract &#123; virtual void f() = 0; // çº¯è™š virtual void g() &#123;&#125; // éžçº¯è™š ~Abstract() &#123; g(); // OK ï¼šè°ƒç”¨ Abstract::g() // f(); // æœªå®šä¹‰è¡Œä¸ºï¼ Abstract::f(); // OK ï¼šéžè™šè°ƒç”¨ &#125;&#125;; // çº¯è™šå‡½æ•°çš„å®šä¹‰void Abstract::f() &#123; std::cout &lt;&lt; "A::f()\n"; &#125; struct Concrete : Abstract &#123; void f() override &#123; Abstract::f(); // OK ï¼šè°ƒç”¨çº¯è™šå‡½æ•° &#125; void g() override &#123;&#125; ~Concrete() &#123; g(); // OK ï¼šè°ƒç”¨ Concrete::g() f(); // OK ï¼šè°ƒç”¨ Concrete::f() &#125;&#125;;]]></content>
      <categories>
        <category>ã€ŠC++ Primerã€‹</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ STLç¯‡ IOåº“]]></title>
    <url>%2F2019%2F02%2F24%2FC-STL%E7%AF%87-IO%E5%BA%93%2F</url>
    <content type="text"><![CDATA[é¢å‘å¯¹è±¡çš„æ ‡å‡†åº“ å¤šç§IOæ ‡å‡†åº“å·¥å…· istreamï¼Œæä¾›è¾“å…¥æ“ä½œ ostreamï¼Œæä¾›è¾“å‡ºæ“ä½œ cinï¼šè¯»å…¥æ ‡å‡†è¾“å…¥çš„istreamå¯¹è±¡.å…¨å±€å¯¹è±¡extern std::istream cin;å®šä¹‰äºŽå¤´æ–‡ä»¶ &lt;iostream&gt; coutï¼šå†™åˆ°æ ‡å‡†è¾“å‡ºçš„ostreamå¯¹è±¡ cerrï¼šè¾“å‡ºæ ‡å‡†é”™è¯¯çš„ostreamå¯¹è±¡ã€‚å¸¸ç”¨è¯­ç¨‹åºé”™è¯¯ä¿¡æ¯ >&gt;ï¼Œç”¨äºŽä»Žistreamå¯¹è±¡ä¸­è¯»å…¥è¾“å…¥.ä»Žå·¦åˆ°å³ &lt;&lt;ï¼Œç”¨äºŽæŠŠè¾“å‡ºå†™åˆ°ostreamå¯¹è±¡ä¸­ getlineï¼ŒåŠŸèƒ½æ˜¯ä»Žistreamå¯¹è±¡è¯»å–ä¸€ä¸ªå•è¯ï¼Œç„¶åŽå†™å…¥stringå¯¹è±¡ä¸­ IOç±»ä¹‹é—´çš„å…³ç³» IOå¯¹è±¡ä¸å¯å¤åˆ¶æˆ–èµ‹å€¼æµå¯¹è±¡ä¸èƒ½å­˜å‚¨åœ¨vectoræˆ–å…¶ä»–å®¹å™¨ä¸­ã€‚ å½¢å‚æˆ–è¿”å›žç±»åž‹ä¹Ÿä¸èƒ½ä¸ºæµç±»åž‹ï¼Œå¦‚æžœéœ€è¦ï¼Œåˆ™å¿…é¡»ä¼ é€’æˆ–è¿”å›žæŒ‡å‘è¯¥å¯¹è±¡çš„æŒ‡é’ˆæˆ–å¼•ç”¨ï¼Œè€Œä¸”ä¸èƒ½æ˜¯constå¼•ç”¨ï¼Œå› ä¸ºè¯»å†™ä¸€ä¸ªIOå¯¹è±¡ä¼šæ”¹å˜å…¶çŠ¶æ€ã€‚ IOåº“çš„æ¡ä»¶çŠ¶æ€æµçš„çŠ¶æ€ç”±bad,fail,eof,goodæ“ä½œæ­ç¤ºã€‚ æ ‡å¿— iostate:æœºå™¨ç›¸å…³çš„ç±»åž‹ï¼Œè¡¨è¾¾æ¡ä»¶çŠ¶æ€ã€‚ badbit:ç³»ç»Ÿçº§çš„æ•…éšœ failbit:å¯æ¢å¤çš„é”™è¯¯,æ¯”å¦‚ æŠŠå­—ç¬¦è¾“å…¥åˆ°æ•°å€¼å˜é‡ä¸­ã€‚ eofbit:é‡åˆ°æ–‡ä»¶ç»“æŸç¬¦ï¼Œfailä¹Ÿç½®ä½ goodbit:æµæœªå¤„äºŽé”™è¯¯çŠ¶æ€ï¼Œä¿è¯ä¸º0. å‡½æ•°ï¼ˆsè¡¨ç¤ºæµ s.bad(): è‹¥badbitç½®ä½ï¼Œè¿”å›žtrue s.fail(): è‹¥failbitç½®ä½ï¼Œè¿”å›žtrue s.eof(): è‹¥eofbitç½®ä½ï¼Œè¿”å›žtrue s.good(): è‹¥goodbitç½®ä½ï¼Œè¿”å›žtrue s.clear():æµçš„æ‰€æœ‰æ¡ä»¶çŠ¶æ€ä½å¤ä½ï¼Œå°†æµçš„çŠ¶æ€è®¾ä¸ºæœ‰æ•ˆï¼Œvoid s.clear(flag):æŒ‡å®šä½å¤ä½ï¼Œvoid s.setstate(flag)ï¼šæŒ‡å®šä½ ç½®ä½ï¼Œvoid s.rdstate(): è¿”å›žå½“å‰æµçš„æ¡ä»¶çŠ¶æ€ï¼Œs.iostate ã€Šcpp primerã€‹p280 ï¼šåªæœ‰å½“ä¸€ä¸ªæµå¤„äºŽæ— é”™çŠ¶æ€æ—¶ï¼Œæ‰èƒ½ä»Žä»–è¯»å†™æ•°æ®ã€‚åœ¨ä½¿ç”¨æµä¹‹å‰ï¼Œåº”è¯¥æ£€æŸ¥å®ƒçš„çŠ¶æ€ï¼Œé€šå¸¸ç”¨whileå¾ªçŽ¯æ¥æ£€æŸ¥ã€‚&gt;&gt;è¡¨è¾¾å¼è¿”å›žçš„æ˜¯æµçš„çŠ¶æ€ã€‚ ä½¿ç”¨good()å’Œfail()æ˜¯æ£€æŸ¥æµæ€»ä½“çŠ¶æ€çš„æ­£ç¡®æ–¹æ³•ã€‚å°†æµå½“ä½œæ¡ä»¶çš„ä»£ç ç­‰ä»·ï¼š!fail(); 1234if(cin) //ok to use cin, it is in a valid statewhile(cin &gt;&gt; word) //ok:read operation successfulâ€¦ æ–‡ä»¶IOæ ‡å‡†åº“å¤´æ–‡ä»¶\&lt;fstream> ifstream :ä»Žæ–‡ä»¶ä¸­è¯»æ•°æ® ofstream ï¼šä»Žæ–‡ä»¶ä¸­å†™æ•°æ® fstream ï¼šè¯»å†™æ–‡ä»¶ IOè¿ç®—ç¬¦ &lt;&lt; &gt;&gt;ä¹Ÿå¯ä»¥è¯»å†™æ–‡ä»¶ã€‚ getline(cin,line) cé£Žæ ¼IO1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;cstdlib&gt; int main()&#123; FILE* fp = std::fopen("test.txt", "r"); if(!fp) &#123; std::perror("File opening failed"); return EXIT_FAILURE; &#125; int c; // æ³¨æ„ï¼šæ˜¯ int è€Œéž char ï¼Œè¦æ±‚å¤„ç† EOF while ((c = std::fgetc(fp)) != EOF) &#123; // æ ‡å‡† C I/O æ–‡ä»¶è¯»å–å¾ªçŽ¯ std::putchar(c); &#125; if (std::ferror(fp)) std::puts("I/O error when reading"); else if (std::feof(fp)) std::puts("End of file reached successfully"); std::fclose(fp);&#125; stringæµ ç‰¹æœ‰å‡½æ•°ï¼šå…¬å¼€æˆå‘˜å‡½æ•° std::basic_stringstream::str std::basic_string&lt;CharT,Traits,Allocator&gt; str() const;è¿”å›žstreamä¿å­˜çš„stringæ‹·è´ã€‚ void str(const std::basic_string&lt;CharT,Traits,Allocator&gt;&amp; new_str);å°†stringæ‹·è´åˆ°æµå¯¹è±¡ä¸­ã€‚äº¦å¯ä½¿ç”¨streamobj(string)ã€‚ 12345678910111213141516171819202122#include &lt;sstream&gt;#include &lt;iostream&gt;int main()&#123; int n; std::istringstream in; // äº¦å¯ä½¿ç”¨ in("1 2") in.str("1 2"); in &gt;&gt; n; std::cout &lt;&lt; "after reading the first int from \"1 2\", the int is " &lt;&lt; n &lt;&lt; ", str() = \"" &lt;&lt; in.str() &lt;&lt; "\"\n"; std::ostringstream out("1 2"); out &lt;&lt; 3; std::cout &lt;&lt; "after writing the int '3' to output stream \"1 2\"" &lt;&lt; ", str() = \"" &lt;&lt; out.str() &lt;&lt; "\"\n"; std::ostringstream ate("1 2", std::ios_base::ate); ate &lt;&lt; 3; std::cout &lt;&lt; "after writing the int '3' to append stream \"1 2\"" &lt;&lt; ", str() = \"" &lt;&lt; ate.str() &lt;&lt; "\"\n";&#125; 123after reading the first int from &quot;1 2&quot;, the int is 1, str() = &quot;1 2&quot;after writing the int &apos;3&apos; to output stream &quot;1 2&quot;, str() = &quot;3 2&quot;after writing the int &apos;3&apos; to append stream &quot;1 2&quot;, str() = &quot;1 23&quot; è¯»å–è¾“å…¥æµçš„ä¸ªäººä¿¡æ¯ 123456789101112131415161718struct PersonInfo&#123; /* data */ string name; vector&lt;string&gt; phones;&#125;;string line,word;vector&lt;PersonInfo&gt; people;while(getline(cin,line))&#123; PersonInfo info; istringstream record(line);//lineæ‹·è´åˆ°recordä¸­ record &gt;&gt;info.name; while(record&gt;&gt;word) info.phones.push_back(word); people.push_back(info); /* code */&#125; to be continuedâ€¦]]></content>
      <categories>
        <category>ã€ŠC++ Primerã€‹</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>Input/output library</tag>
        <tag>stringstream</tag>
        <tag>getline</tag>
        <tag>fstream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Solution]]></title>
    <url>%2F2019%2F01%2F21%2Fleetcode%2F</url>
    <content type="text"><![CDATA[é¢˜å· è§£ç­” [1] ä¸¤æ•°ä¹‹å’Œ 1. umap.find(target - nums[i])2. umap.count(target-nums[i]) ðŸ‘ [46] å…¨æŽ’åˆ— 1. é€’å½’. åˆ†å±‚å¸ƒå±€ã€‚1.äº¤æ¢ç¬¬ä¸€ä¸ªæ•°å­—ã€‚2.ç¬¬ä¸€ä¸ªæ•°å›ºå®šã€‚åŽé¢çš„æŽ’åˆ—ã€‚3.äº¤æ¢å½’ä½ã€‚ 2. é€’å½’ã€‚å›žæº¯ã€‚å¡«ç©ºæ ¼æ³•ã€‚è®¿é—®æ•°ç»„æ ‡è®°ã€‚ [47] å…¨æŽ’åˆ—ii setã€‚åŽ»é‡ã€‚é€’å½’ã€‚äº¤æ¢ã€‚ [51] Nçš‡åŽ å›žæº¯ã€‚æŽ’åºã€‚åŸºäºŽæ¡ä»¶å¯¹stringè¿›è¡ŒæŽ’åºã€‚H [52] Nçš‡åŽii å›žæº¯ã€‚è®¡æ•°ã€‚è·Ÿ51é¢˜ä¸€æ ·ã€‚ [53] æœ€å¤§å­åºå’Œ 1. 2*O(n/2)+O(1)=O(n)ã€‚åˆ†æ²»æ³•ã€‚max(divide,merge)ã€‚2. O(n)ã€‚Kadaneâ€™s algorithmã€‚DPã€‚åˆ†ä¸ºå­é—®é¢˜ã€‚ [77] ç»„åˆ 1. å…¬å¼æ³•ï¼šC(K,N)=C(K-1,N-1)+C(K,N-1)ã€‚2. å›žæº¯æ³•ã€‚é€’å½’+å¾ªçŽ¯ã€‚M [94] äºŒå‰æ ‘çš„ä¸­åºéåŽ† 1. ä¸­åºéåŽ†ã€‚é€’å½’ã€‚E2. ä¸­åºéåŽ†ã€‚1ä¸ªæ ˆã€‚Mã€‚ðŸ‘3. ä¸­åºéåŽ†ã€‚O1,éžé€’å½’+ä¸ç”¨æ ˆã€‚çº¿ç´¢äºŒå‰æ ‘ã€‚Hã€‚ [104] äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ dfs.é€’å½’ã€‚E [105] ä»Žå‰åºä¸Žä¸­åºéåŽ†åºåˆ—æž„é€ äºŒå‰æ ‘ é€’å½’ã€‚äºŒåˆ†æŸ¥æ‰¾ã€‚mid.start.end. pos=distance(.begin,find( , , )) [111] äºŒå‰æ ‘çš„æœ€å°æ·±åº¦ dfs.é€’å½’ã€‚E [138] å¤åˆ¶å¸¦éšæœºæŒ‡é’ˆçš„é“¾è¡¨ é“¾è¡¨/å¤åˆ¶åŽŸå§‹(copy,link,next)/å¤åˆ¶éšæœº(copy,next)/åˆ†ç¦»ã€‚M [144] äºŒå‰æ ‘çš„å‰åºéåŽ† 1. é€’å½’2. è¿­ä»£+æ ˆðŸ‘ [145] äºŒå‰æ ‘çš„åŽåºéåŽ† 1. é€’å½’2. è¿­ä»£+1ä¸ªæ ˆðŸ‘3. è¿­ä»£+2ä¸ªæ ˆ [169] æ±‚ä¼—æ•° 1. å¿«æŽ’ã€‚æ‰¾ä¸­ä½æ•°ã€‚O(nlogn)2. ä¸ä¿®æ”¹æ•°ç»„çš„æ–¹æ³•O(n) ðŸ‘ [172] é˜¶ä¹˜åŽçš„é›¶ 1. æ•°å­¦ã€‚é€’å½’ã€‚2. æ•°å­¦ã€‚è¿­ä»£ã€‚ [179] æœ€å¤§æ•° å­—ç¬¦ä¸²æŽ’åº,sort.lambda.string [215] æ•°ç»„ä¸­çš„ç¬¬Kä¸ªæœ€å¤§å…ƒç´  1. O(nlogn)ã€‚å¿«æŽ’sort()ã€‚reverse()ã€‚ä¼šä¿®æ”¹æ•°ç»„ã€‚2. O(n)ã€‚å¿«æŽ’in-place partition/one wayã€‚ä¼šä¿®æ”¹æ•°ç»„ã€‚3. O(nlogk)ã€‚priorityqueue-default-maxheapã€‚åŸºäºŽå †ã€‚æ‰€æœ‰å…ƒç´ æ”¾å…¥pqï¼Œå¼¹å‡ºk-1æ¬¡å †é¡¶ï¼Œè¿”å›žpq.top()ã€‚ä¸éœ€è¦ä¿®æ”¹æ•°ç»„ï¼Œé€‚ç”¨äºŽå¤„ç†æµ·é‡æ•°æ®ã€‚4. O(nlogk)ã€‚multiset-default-minheapã€‚åŸºäºŽrbt,è®¾ç½®ä¸€ä¸ªå¤§å°ä¸ºkçš„æœ€å°å †ã€‚æœ€åŽå¼¹å‡º*set.begin()ã€‚ä¸éœ€è¦ä¿®æ”¹æ•°ç»„ï¼Œé€‚ç”¨äºŽå¤„ç†æµ·é‡æ•°æ®ã€‚.cpp) [233] æ•°å­—1çš„ä¸ªæ•° æ•°å­¦ã€‚T:O(logn),S:O(1)1. å…¬å¼æ³•ï¼šn/(10d)d + min(d,max(0,n\%(10d)-d+1))2.åˆ’åˆ†æ³•ã€‚æ»¡äºŒè¿›ä¸€ä½ï¼ˆæ»¡è½½ï¼‰ï¼Œå¦‚æžœé‡çº§çš„æœ€åŽä¸€ä½æ˜¯1ï¼Œè¦åŠ ä¸Šä½™æ•°+1 [263] ä¸‘æ•° æ•°å­¦ã€‚è¿­ä»£ã€‚ [264] ä¸‘æ•°ii åŠ¨æ€è§„åˆ’.3ä¸ªæŒ‡é’ˆ [295] æ•°æ®æµçš„ä¸­ä½æ•° 1. å¢žåˆ O(logn),æŸ¥O(1).maxheapï¼Œä¸¤ä¸ªstl::pq,ä¸€ä¸ªæ”¾å‰ä¸€åŠå¤§çš„æ•°ï¼Œä¸€ä¸ªæ”¾åŽä¸€åŠå¤§çš„è´Ÿæ•°ã€‚2. AVLã€‚maxheapå’Œminheapã€‚ä¼˜å…ˆé˜Ÿåˆ—ã€‚ [297] äºŒå‰æ ‘çš„åºåˆ—åŒ–ä¸Žååºåˆ—åŒ– 1. bfs/queue/stringstream2. dfsé€’å½’/stringstream in(str)/obj.str()è¿”å›žå€¼ [400] ç¬¬Nä¸ªæ•°å­— è¿­ä»£ã€‚æ•°å­¦ã€‚tostring(int)ã€‚(string)charã€‚stoi(const string&amp;) [426] æŠŠäºŒå‰æœç´¢æ ‘è½¬åŒ–ä¸ºæœ‰åºåŒå‘é“¾è¡¨ åˆ†æ²»æ³•ã€‚é€’å½’ã€‚æŒ‡é’ˆå¼•ç”¨ã€‚ä¸­åºéåŽ†ã€‚M [463] å²›å±¿çš„å‘¨é•¿ 1. å²›å±¿è¾¹ç•Œå¤„ï¼šåœ¨æ•°ç»„æœ€å·¦è¾¹ï¼Œæˆ–è€…å·¦è¾¹æ ¼å­æ²¡æœ‰å²›å±¿2. å…ˆå‡è®¾ç®—4ä¸ªè¾¹ï¼Œåˆ¤æ–­å·¦è¾¹å’Œä¸Šè¾¹æ˜¯å¦æœ‰å²›å±¿ ðŸ‘ [700] äºŒå‰æœç´¢æ ‘çš„æŸ¥æ‰¾ 1. é€’å½’ã€‚BSTã€‚E2. è¿­ä»£ã€‚BSTã€‚Eã€‚ [701] äºŒå‰æœç´¢æ ‘çš„æ’å…¥ 1. é€’å½’ã€‚BSTã€‚2. è¿­ä»£ã€‚BSTã€‚breakã€‚ [705] è®¾è®¡å“ˆå¸Œé›†åˆ hashsetã€‚äºŒç»´æ•°ç»„ã€‚value=0æˆ–è€…1.ä»£è¡¨é›†åˆä¸­æ˜¯å¦å­˜åœ¨ã€‚Eã€‚ [706] è®¾è®¡å“ˆå¸Œæ˜ å°„ hashmapã€‚key-valueã€‚æ˜ å°„ã€‚åˆå€¼ä¸º-1ã€‚Eã€‚ [804] å›½é™…æ‘©å°”æ–¯å¯†ç  unordered_setã€‚hashã€‚Eã€‚]]></content>
      <categories>
        <category>Interview</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ubuntu 16.04 è¿žæŽ¥ wifi]]></title>
    <url>%2F2018%2F08%2F19%2Fubuntu-16-04-%E8%BF%9E%E6%8E%A5-wifi%2F</url>
    <content type="text"><![CDATA[æœ¬æœºé…ç½®æˆ‘çš„ç”µè„‘æ˜¯win10+ubuntu16.04åŒç³»ç»Ÿã€‚åœ¨ubuntuä¸‹æ— æ³•è¿žæŽ¥wifiï¼Œä¸€ç›´ç”¨usbè¿žæŽ¥çš„æ‰‹æœºæµé‡ï¼Œä¸å¤ªæ–¹ä¾¿ã€‚çŽ°åœ¨æ¥ç”¨å®‰è£…æ— çº¿é©±åŠ¨ï¼Œé¡ºä¾¿ç¿»ä¸ªå¢™ã€‚ https://blog.csdn.net/linzhineng44/article/details/78778143 æŸ¥çœ‹ç½‘å¡12yue@akayue:~$ lspci | grep Network03:00.0 Network controller: Intel Corporation Device 24fb (rev 10) æ— çº¿ç½‘å¡123yue@akayue:~$ lspci | grep -i net02:00.1 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8111/8168/8411 PCI Express Gigabit Ethernet Controller (rev 12)03:00.0 Network controller: Intel Corporation Device 24fb (rev 10) æŸ¥çœ‹å®‰è£…çš„å†…æ ¸ç‰ˆæœ¬ï¼ˆä¸é™ä»¥ä¸‹ä¸‰ç§ï¼Œä¸ºäº†ä»¥åŽä½¿ç”¨æ–¹ä¾¿ï¼Œè®°å½•ä»¥ä¸‹ï¼‰123456yue@akayue:~$ dpkg -l | grep linux-imageii linux-image-4.4.0-133-generic 4.4.0-133.159 amd64 Linux kernel image for version 4.4.0 on 64 bit x86 SMPii linux-image-4.4.0-21-generic 4.4.0-21.37 amd64 Linux kernel image for version 4.4.0 on 64 bit x86 SMPii linux-image-extra-4.4.0-133-generic 4.4.0-133.159 amd64 Linux kernel extra modules for version 4.4.0 on 64 bit x86 SMPii linux-image-extra-4.4.0-21-generic 4.4.0-21.37 amd64 Linux kernel extra modules for version 4.4.0 on 64 bit x86 SMPii linux-image-generic 4.4.0.133.139 amd64 Generic Linux kernel image ref æ­¥éª¤æŸ¥çœ‹è‡ªå·±çš„æ— çº¿ç½‘å¡çš„åž‹å· æˆ‘çš„æ˜¯intel dual band wireless ac 3168 ç½‘å¡é©±åŠ¨ä¸‹è½½é“¾æŽ¥ æ³¨æ„é©±åŠ¨çš„è¦æ±‚ å¯ä»¥çœ‹åˆ°ï¼Œéœ€è¦çš„linuxå†…æ ¸è¦æ±‚æ˜¯4.6ä»¥ä¸Šï¼Œ14.04çš„ubuntuè¿˜æ˜¯3.å‡ çš„kernelï¼Œ16.04çš„ä¹Ÿä¸è¿‡4.4kernelï¼Œæ‰€ä»¥éœ€è¦å‡çº§linuxå†…æ ¸ é€šè¿‡ä¸‹é¢çš„å‘½ä»¤æ¥æŸ¥çœ‹å†…æ ¸ 12yue@akayue:~$ uname -r4.4.0-133-generic å‡çº§linuxå†…æ ¸Ubuntu 16.04 Linuxç³»ç»Ÿå†…æ ¸å‡çº§æ–¹æ³• é€‰æ‹©åˆé€‚å’Œå†…æ ¸è¿›è¡Œå‡çº§ å®‰è£…å†…æ ¸æ–‡ä»¶sudo dpkg -i *.deb å®‰è£…å®Œæˆä»¥åŽï¼Œé‡æ–°å¯åŠ¨ç³»ç»Ÿï¼ŒéªŒè¯å†…æ ¸çš„ç‰ˆæœ¬ å®‰è£…é©±åŠ¨ä¸‹å¥½çš„é©±åŠ¨ æŸ¥çœ‹readmeæ–‡ä»¶ï¼Œå¯ä»¥çœ‹åˆ°æˆ‘ä»¬éœ€è¦è¿›è¡Œå†…æ ¸é…ç½® 12345$ cd /usr/src/$ ls$cd linux-4.18.3-.. Device Drivers -&gt;Generic Driver Options -&gt;Userspace firmware loading support Linux å†…æ ¸é…ç½®æœºåˆ¶ï¼ˆmake menuconfigã€Kconfigã€makefileï¼‰è®²è§£ é…ç½®å†…æ ¸ï¼ˆmake menuconfigï¼‰è¯¦è¿° $make menuconfig bugmake: *** No rule to make target â€˜menuconfigâ€™. Stop.` è§£å†³åŠžæ³•sudo apt-get install ncurses-dev å½“ç„¶åœ¨é…ç½®å†…æ ¸æœ€å¥½è¿˜è¦æŸ¥çœ‹.configé‡Œé¢çš„CONFIG_FW_LOADERæ˜¯å¦ä¸ºY é…ç½®å¥½å†…æ ¸åŽ 1cp iwlwifi-3168-22.ucode /lib/firmware é‡å¯]]></content>
      <categories>
        <category>Configuration</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ã€ŠEffective C++ã€‹ æ¡æ¬¾04ï¼šStackä¸ŽHeap / å†…å­˜ç®¡ç†]]></title>
    <url>%2F2018%2F08%2F04%2F%E3%80%8AEffective-C-%E3%80%8B-%E6%9D%A1%E6%AC%BE04%EF%BC%9AStack%E4%B8%8EHeap-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[é˜…è¯»effective c++ 04 ï¼ˆ30é¡µï¼‰ æåˆ°çš„staticå¯¹è±¡å’Œå †ä¸Žæ ˆå¯¹è±¡ã€‚â€œä¸åŒç¼–è¯‘å•å…ƒå†…å®šä¹‰çš„non-local staticå¯¹è±¡â€ã€‚ Stackä¸ŽHeap / å†…å­˜ç®¡ç†stackstackæ˜¯åœ¨æŸä¸ªä½œç”¨åŸŸå†…çš„ä¸€å—å†…å­˜ç©ºé—´ã€‚å½“è°ƒç”¨å‡½æ•°æ—¶ï¼Œå‡½æ•°æœ¬èº«ä¼šå½¢æˆä¸€ä¸ªæ ˆæ¥ä¿å­˜å‡½æ•°çš„å‚æ•°å’Œè¿”å›žåœ°å€ã€‚å‡½æ•°ä½“å†…å£°æ˜Žçš„æ‰€æœ‰å˜é‡ï¼Œéƒ½æ¥è‡ªstackçš„å†…å­˜ã€‚ heap / system heapå †æ˜¯æ“ä½œç³»ç»Ÿæä¾›çš„å…¨å±€globalå†…å­˜ç©ºé—´ã€‚ç¨‹åºåŠ¨æ€åˆ†é…dynamic allocatedæ—¶ï¼Œä»Žå †é‡Œé¢å–ä¸€äº›åŒºå—blocksã€‚ stackå’Œheapçš„å†…å­˜ä¾‹å­ / ç±»å¤–çš„staticå£°æ˜Ž1234567891011class Complex &#123; â€¦ &#125;;...&#123;Complex c1(1,2);//stack/non-static localstatic Complex c2(1,2);//static local Complex* p = new Complex(3);...delete p; &#125;Complex c3(1,2);//global/static stack / æž„é€ å‡½æ•°åž‹ï¼š å±€éƒ¨å¯¹è±¡ c1 çš„å†…å­˜æ¥è‡ªstackï¼Œç”Ÿå‘½å‘¨æœŸåœ¨scopeç»“æŸæ—¶ç»“æŸï¼Œæ‰€ä»¥åˆç§°auto objectï¼Œå› ä¸ºä¼šè¢«è‡ªåŠ¨æ¸…ç†ã€‚ heap / newåž‹ åŠ¨æ€åˆ†é…ï¼š åŠ¨æ€åˆ†é…çš„ä¸´æ—¶å¯¹è±¡Complex(3) ï¼Œå ç”¨ç©ºé—´æ¥è‡ªheapã€‚æŒ‡é’ˆpæŒ‡å‘è¿™ä¸ªä¸´æ—¶å¯¹è±¡ï¼Œpçš„ç”Ÿå‘½åœ¨å®ƒè¢«deleteçš„æ—¶å€™ç»“æŸã€‚å¦‚æžœå½“ä½œç”¨åŸŸç»“æŸï¼ŒpæŒ‡çš„å †å¯¹è±¡ä¾ç„¶å­˜åœ¨ï¼Œä½†æ˜¯pçš„ç”Ÿå‘½ç»“æŸäº†ï¼Œä½œç”¨åŸŸå¤–å†ä¹Ÿæ²¡æœ‰pï¼Œæ— æ³•delete pï¼Œä¼šå¯¼è‡´å†…å­˜æ³„æ¼leakã€‚ static å¯¹è±¡ï¼šåœ¨å†…å­˜ä¸­ã€‚ç¨‹åºç»“æŸï¼Œè‡ªåŠ¨é”€æ¯ local static objectã€‚ c2 ã€‚åœ¨å‡½æ•°ç¬¬ä¸€æ¬¡è°ƒç”¨æ—¶æž„é€ åˆå§‹åŒ–ã€‚åœ¨ç¨‹åºç»“æŸä¹‹åŽè‡ªåŠ¨æžæž„ã€‚ non-local static object global objectã€‚c3ã€‚mainè°ƒç”¨ä¹‹å‰è¢«æž„é€ åˆå§‹åŒ–ã€‚åœ¨ç¨‹åºç»“æŸä¹‹åŽè‡ªåŠ¨æžæž„ã€‚ å®šä¹‰äºŽnamespaceä½œç”¨åŸŸçš„å¯¹è±¡ã€‚mainè°ƒç”¨ä¹‹å‰è¢«æž„é€ åˆå§‹åŒ–ã€‚åœ¨ç¨‹åºç»“æŸä¹‹åŽè‡ªåŠ¨æžæž„ã€‚ ç±»å¤–çš„staticå£°æ˜Žä¸¤ä¸ªç¼–è¯‘å•å…ƒä¸­çš„non-local static objectç›¸äº’å¼•ç”¨æ³¨æ„ï¼šåœ¨åŒä¸€ä¸ªæ–‡ä»¶æˆ–ä¸åŒç¼–è¯‘å•å…ƒï¼ˆä¸åŒæ–‡ä»¶ï¼‰ä¸­ï¼Œå¦‚æžœå­˜åœ¨å¤šä¸ªnon-local static objectï¼Œå®ƒä»¬éƒ½æ˜¯åœ¨ä¸»å‡½æ•°è°ƒç”¨ä¹‹å‰è¢«æž„é€ çš„ï¼Œä½†æ˜¯å®ƒä»¬ä¹‹é—´çš„æž„é€ é¡ºåºæ—¶ä¸å®šçš„ã€‚å³å¯¹ç¼–è¯‘å™¨æ¥è¯´ï¼Œé™æ€æˆå‘˜å¯¹è±¡ä¹‹é—´çš„åˆå§‹åŒ–é¡ºåºå’Œæžæž„é¡ºåºæ˜¯ä¸€ä¸ªæœªå®šä¹‰çš„è¡Œä¸ºã€‚ å› æ­¤ï¼Œä¸èƒ½ç”¨æŸä¸ªnon-local static objectåŽ»åˆå§‹åŒ–non-local static objectï¼Œæ— è®ºè¿™ä¸¤ä¸ªnon-local static objectåœ¨ä¸åœ¨åŒä¸€ä¸ªç¼–è¯‘å•å…ƒä¸­ã€‚ 1234567891011121314151617181920212223242526272829303132class FileSystem&#123;public: â€¦std::size_t numDisks() const;&#125;;extern FileSystem tfs;//å¦ä¸€ç¼–è¯‘å•å…ƒclass Directory&#123;public:Directory(params);&#125;;Directory::Directory(params)&#123;std::size_t disks = tfs.numDisks();//ä½¿ç”¨å¦ä¸€ä¸ªç¼–è¯‘å•å…ƒçš„é™æ€å˜é‡&#125;Directory tempDir (params); ç”±äºŽç¼–è¯‘å™¨æ²¡æœ‰å®šä¹‰non-local static objectä¹‹é—´çš„æž„é€ é¡ºåºï¼Œæ‰€ä»¥æœ‰å¯èƒ½ç±»tfsè¿˜æ²¡æœ‰è¢«æž„é€ ï¼Œæ‰€ä»¥ç¨‹åºå¯èƒ½ä¼šæŠ¥é”™ã€‚ è§£å†³æ–¹æ³•ç”¨local staticå¯¹è±¡æ›¿æ¢non-local staticå¯¹è±¡ã€‚ C++ä¿è¯ï¼Œå‡½æ•°å†…çš„local static å¯¹è±¡ä¼šåœ¨è¯¥å‡½æ•°è¢«è°ƒç”¨æœŸé—´ï¼Œé¦–æ¬¡é‡ä¸Šè¯¥å¯¹è±¡å®šä¹‰å¼æ—¶è¢«åˆå§‹åŒ–ã€‚ 123456789101112131415161718192021222324252627282930313233class FileSystem &#123;â€¦&#125;;FileSystem&amp; tfs()&#123;static FileSystem fs;return fs;&#125;//å¦ä¸€ç¼–è¯‘å•å…ƒclass Directory &#123;â€¦&#125;;Directory::Directory (params)&#123;std::size_t disks = tfs().numDisks();//æ‰§è¡Œå‡½æ•°tfsæ—¶ï¼Œå¯¹è±¡fsè‚¯å®šä¼šè¢«æž„é€ ã€‚&#125;;Directory&amp; tempDir()&#123;static Directory td;return td;&#125;]]></content>
      <categories>
        <category>ã€ŠEffective C++ã€‹</category>
      </categories>
      <tags>
        <tag>static</tag>
        <tag>Stack</tag>
        <tag>Heap</tag>
        <tag>Memory</tag>
      </tags>
  </entry>
</search>
